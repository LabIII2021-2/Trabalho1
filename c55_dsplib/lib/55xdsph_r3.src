!<arch>
//              0           0     0     0       115       `
cfft32_noscale.asm/
cfft32_scale.asm/
cfft_noscale.asm/
cifft32_noscale.asm/
cifft32_scale.asm/
cifft_noscale.asm/

abias.asm/      1362765892  0     0     0       11858     `
;/*
; * Copyright (C) 2013 Texas Instruments Incorporated - http://www.ti.com/ 
; * 
; * 
; *  Redistribution and use in source and binary forms, with or without 
; *  modification, are permitted provided that the following conditions 
; *  are met:
; *
; *    Redistributions of source code must retain the above copyright 
; *    notice, this list of conditions and the following disclaimer.
; *
; *    Redistributions in binary form must reproduce the above copyright
; *    notice, this list of conditions and the following disclaimer in the 
; *    documentation and/or other materials provided with the   
; *    distribution.
; *
; *    Neither the name of Texas Instruments Incorporated nor the names of
; *    its contributors may be used to endorse or promote products derived
; *    from this software without specific prior written permission.
; *
; *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
; *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
; *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
; *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
; *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
; *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
; *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
; *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
; *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
; *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
; *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
; *
;*/

;***********************************************************
; Version 3.00.00                                           
;***********************************************************
;****************************************************************
; Function:    acorr_bias
; Processor:   C55xx
; Description: calculates positive biased auto-correlation
;
; Usage:    short acorr_bias(DATA *x, DATA *r, ushort nx, ushort nr)
;
; Notes:
;   This function uses the dual-mac, but since it is doing an autocorrelation, all 3
;   operands are taken from the same page of memory, thus causing 1 cycle of delay for
;   arrays in DARAM, and 2 cycles of delay for arrays in SARAM.  So intuition would say
;   that it would be simpler and faster to skip the dual-mac and just use single macs.
;   That logic would be true for arrays in DARAM.  But for arrays in SARAM, each single-mac
;   instruction would cause a one-cycle delay.  Hence, the use of the dual-mac for arrays
;   in SARAM will cause a performance improvement of 25%.
;   For better performance, it would be much faster to perform the autocorrelation by
;   first temporarily copying the array to a different block of memory.  Copying to SARAM 
;   would be okay.  Then do the dual-mac autocorrelation between the original and its clone.  
;   This should speed up the autocorrelation by up to 50% from its current speed.
;
; Benchmarks:
;   Cycles:
;     nx =  152:  nr = 152:   12148
;     nx =  128:  nr = 128:    8704
;     nx =   64:  nr =  64:    2336
;     nx =   61:  nr =  61:    2252
;     nx =   61:  nr =  58:    2130
;   Code Size (in bytes):  187
;
; History:
;       Li Yuan - 08/14/2001
; - Modified save and restore AR5/AR6/AR7 to XAR5/XAR6/XAR7 registers.
; 
;       Zhengting He - 10/25/2006
; - Added overflow checking and overflow is returned in T0 instead of 
;   AC0 register
;
;       Craig Leeds - 05/29/2012
;  Fixed bug where T2 & T3 were modified but not restored.
;  Fixed bug where XAR5 was modified but not properly restored.
;  Fixed bug where SXMD not 1 on exit.
;  Fixed bug where overflow bits are not cleared on entry.
;  Fixed bug where compiler told that ARMS is 0 but it is actually 1.
;  Fixed bug when nx or nr is odd.
;  A little optimization.
;
;****************************************************************

	.ARMS_off                      ;enable assembler for ARMS=0
	.CPL_on                       ;enable assembler for CPL=1
	.mmregs                       ;enable mem mapped register names
	.global _acorr_bias

; Stack frame
; -----------
RET_ADDR_SZ       .set 1            ;return address
REG_SAVE_SZ       .set 2            ;save-on-entry registers saved (T2, T3)
FRAME_SZ          .set (4+1)        ;local variables
ARG_BLK_SZ        .set 0            ;argument block

; Register usage
; --------------

PARAM_OFFSET    .set  FRAME_SZ + REG_SAVE_SZ
	.asg    0, temp
        .asg    1, rSUBnr           ; original r[nr] value
        .asg    2, r_save           ; original r
        .asg    3, restoreFlag      ; 
	.asg    0 + FRAME_SZ + REG_SAVE_SZ, RETURN_ADDR
	
	.asg	 AR0,  x_ptr
	.asg	XAR0, Xx_ptr
	.asg	 AR1,  r_ptr
	.asg	XAR1, Xr_ptr
	.asg	 AR2,  x_save
	.asg	XAR2, Xx_save
	.asg     AR3,  x2_save
	.asg    XAR3, Xx2_save
	.asg     AR4,  xb_ptr
	.asg    XAR4, Xxb_ptr

	.asg	T0,   nx  
	.asg	T1,   nr 
	.asg    T2,   loop_count
	.asg	T3,   n_inverse

;
; CSR = counter = nx - 3
; BRC0 = loop_count = MIN(((nr+1)/2), ((nx-1)/2)) - 1;  // number of passes thru RPTBLOCAL block minus 1
; mac2flag = ((nx & 1) == 0) &&((nx - nr) <= 1)         // do 2 macs at the end
; mac1flag = (nx == nr)                                 // do 1 mac  at the end  (note: independent of mac2flag)
; restoreFlag = (nr & 1) && (!(mac2flag | mac1flag))    // restore original r[nr] at end
;
	
        .text
_acorr_bias:

;
; Save any save-on-entry registers that are used
; Configure the status registers as needed.
;----------------------------------------------------------------
        PSH     T2, T3
      ||BCLR    ARMS                 ; clear ARMS
        BSET    FRCT                 ; Set FRCT
        ROR     CARRY, nx, TC2, AC3  ; TC2 = 1 if nx is odd (AC3 is irrelevant)
     || BCLR    ACOV0                ; clear overflow bit
        BCLR    ACOV3                ; clear overflow bit
;
; Allocate the local frame and argument block( +1 is for dbl alignment)
;----------------------------------------------------------------
     || AADD    #-(ARG_BLK_SZ + FRAME_SZ), SP 
;
; Initialize some of the variables
;----------------------------------------------------------------

        SUB     #1, nr, loop_count
        SUB     #3, nx, T3
        MIN     T3, loop_count
        SFTS    loop_count, #-1
        MOV     loop_count, BRC0       ; loop_count = MIN(((nr+1)/2), ((nx-1)/2)) - 1;  

; mac2flag = ((nx & 1) == 0) &&((nx - nr) <= 1)         // do 2 macs at the end
; mac1flag = (nx == nr)                                 // do 1 mac  at the end  (note: independent of mac2flag)
; restoreFlag = (nr & 1) && (!(mac2flag | mac1flag))    // restore original r[nr] at end

        MOV     nx, AC0
     || MOV     #0, AC1
        SUB     nr, AC0                  ; AC0 = (nx - nr)
        SUB     #1, AC0, AC3             ; AC3 = (nx - nr) - 1 
        CMPAND  AC3 <= AC1, !TC2, TC1    ; TC1 = mac2flag = ((nx & 1) == 0) &&((nx - nr) <= 1) 
        CMP     AC0 == AC1, TC2          ; TC2 = mac1flag = (nx == nr) 

     || AND     #1, nr, T3               ; T3 = (nx - nr)
        XCCPART TC1 | TC2
            ||MOV   #0, T3               ; T3 = restoreFlag = (nr & 1) && (!(mac2flag | mac1flag))    // restore original r[nr] at end
        MOV     T3, *SP(restoreFlag)
        XCCPART T3 != #0
            ||MOV     *r_ptr(nr), AC0
        MOV     AC0, *SP(rSUBnr)         ; save original r[nr] 
        MOV     r_ptr, *SP(r_save)       ; r_save = r_ptr

; ---- Prepare the scaling value ----
        MOV     nx, *SP(#temp)
        MOV     #32767, AC0
     || RPT     #16-1
                SUBC    *SP(#temp), AC0
        ADD     #1, AC0, T3         ; T3 = n_inverse

; Generic pointer and loop setup 
;      Generic will be used by both normal dual mac 

        MOV     Xx_ptr, XCDP          ; Setup CDP         
        MOV     Xx_ptr, Xx_save
        MOV     Xx_ptr, Xx2_save
        AMAR    *x_ptr(#1), Xxb_ptr   ; Setup the secondary pointer

        SUB     #3, nx
        MOV     nx, CSR                ; CSR = nx - 3

     || BCC      OuterLoopEnd, loop_count < #0
;
; Perform correlation:                                       
;----------------------------------------------------------------
        
        RPTBLOCAL OuterLoopEnd-1

                ; ---- Preload A ----
                MPY     *x_ptr+, *CDP+, AC0
                ::MPY   *xb_ptr+, *CDP+, AC3

                ; ---- Main Dual MAC loop  ----
              ||RPTSUB  CSR, #2
                        MAC     *x_ptr+, *CDP+, AC0
                        ::MAC   *xb_ptr+, *CDP+, AC3

                ; ---- Do one MAC for A, Load with B  ----
                MACM    *x_ptr, *CDP, AC0
              ||AADD    #2, x2_save

                ; ---- Multiply B with inverse, Load T3 with A  ----
                MPYR    T3, AC3, AC3
              ||MOV     x_save, CDP

                ; ---- Multiply A with inverse, x2 incremented by two because of DUAL MAC ----
                MPYR    T3, AC0, AC0
              ||AMOV    x2_save, x_ptr      

                ; ---- Store A, reset CDP ----
                ; ---- Reload x_pointer (used for A) with new x2_save ----
                MOV     HI(AC0), *r_ptr+
              ||AMOV    x2_save, xb_ptr               ; Setup the secondary pointer

                ; ---- Store B, 
                MOV     HI(AC3), *r_ptr+

                ; ---- Reload xb_ptr (used for B) with one more than x_ptr ----
              ||AADD    #1, xb_ptr               ; Setup the secondary pointer
OuterLoopEnd:

;;;     BCC     Skip2macs, !TC1
        
; ---- 2 -----
; Do 2 macs at the end
; ((nx - nr) <= 1)                     
        XCC    TC1
             ||MPYM    *x_ptr+, *CDP+, AC0
        XCC    TC1
             ||MACM    *x_ptr, *CDP-, AC0
        MPYR    T3, AC0, AC0
        XCC    TC1
             ||MOV     HI(AC0), *r_ptr+
;;;Skip2macs:

; ---- 1 -----
; Do 1 macs at the end
; ((nx - nr) == 0)                     
        MPYM    *x_ptr, *CDP, AC0
        MPYR    T3, AC0, AC0
        XCCPART TC2
            ||MOV    HI(AC0), *r_ptr

        MOV     *SP(r_save), r_ptr     ; r_ptr = r_save
        MOV     *SP(restoreFlag), T2

; Check if overflow occurred, and setup return value
;----------------------------------------------------------------
        MOV     #0, T0               ;clear oflag
        XCCPART overflow(AC0)        ;clears ACOV0
            ||MOV   #1, T0           ;overflow occurred
        XCCPART overflow(AC3)        ;clears ACOV3
            ||MOV   #1, T0           ;overflow occurred
;
; If there were an odd number of output elements 
; then r[nr] may have been incorrectly overwritten.
; So restore r[nr] to its original value.
;
        MOV    *SP(rSUBnr), AC0
        XCCPART T2 != #0
            ||MOV   AC0, *r_ptr(nr)
;
; Restore status regs to expected C-convention values as needed
; Restore any save-on-entry registers that are used
;----------------------------------------------------------------
;
; Deallocate the local frame and argument block
;----------------------------------------------------------------

        AADD    #(ARG_BLK_SZ + FRAME_SZ), SP
        POP     T2, T3
     || BSET    ARMS                 ; set ARMS for C
;
; Return to calling function
;----------------------------------------------------------------
        BCLR    FRCT                 ; Clear FRCT for C
     || RET                        
;----------------------------------------------------------------
;End of file
add.asm/        1364239168  0     0     0       6853      `
;/*
; * Copyright (C) 2013 Texas Instruments Incorporated - http://www.ti.com/ 
; * 
; * 
; *  Redistribution and use in source and binary forms, with or without 
; *  modification, are permitted provided that the following conditions 
; *  are met:
; *
; *    Redistributions of source code must retain the above copyright 
; *    notice, this list of conditions and the following disclaimer.
; *
; *    Redistributions in binary form must reproduce the above copyright
; *    notice, this list of conditions and the following disclaimer in the 
; *    documentation and/or other materials provided with the   
; *    distribution.
; *
; *    Neither the name of Texas Instruments Incorporated nor the names of
; *    its contributors may be used to endorse or promote products derived
; *    from this software without specific prior written permission.
; *
; *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
; *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
; *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
; *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
; *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
; *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
; *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
; *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
; *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
; *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
; *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
; *
;*/

;***********************************************************
; Version 3.00.00                                           
;***********************************************************
; Function:    ADD
; Processor:   C55xx
; Description: Implements a vector add 
;
; Usage: ushort oflag = add (DATA *x,
;                            DATA *y,
;                            DATA *r,
;                            ushort nx,
;                            ushort scale)
;
; Benchmarks:
;   Cycles:       (2 * nx) + 16
;   Code Size (in bytes):  31
;
; History:
;        Craig Leeds  - 05/17/2012
;   AR1 no longer set to a circular buffer.
;   Optimized both loop and housekeeping.
;
;****************************************************************

	.ARMS_on			;enable assembler for ARMS=1
	.CPL_on				;enable assembler for CPL=1
	.mmregs				;enable mem mapped register names

; -----------
; Stack frame
; -----------

RET_ADDR_SZ       .set 1            	;return address
REG_SAVE_SZ       .set 0            	;save-on-entry registers saved
FRAME_SZ          .set 0            	;local variables
ARG_BLK_SZ        .set 0            	;argument block

PARAM_OFFSET      .set ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ + RET_ADDR_SZ

; ------------------------------
; Register usage and definitions
; ------------------------------
	.asg     AR0, x_ptr           	;linear pointer for first input vector
	.asg     AR1, y_ptr           	;linear pointer for second input vector
	.asg     AR2, r_ptr           	;linear pointer for result vector

	.asg     BRC0, outer_cnt      	;outer loop count
	.asg     T0, oflag           	;returned value

	.def _add
	.text

_add:

; ---------------------------------------------------------------
; Allocate the local frame and argument block
; ---------------------------------------------------------------
;      SP = SP - #(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ)
; - not necessary for this function (the above is zero)

; ---------------------------------------------------------------
; Save any save-on-entry registers that are used
; ---------------------------------------------------------------
; - nothing to save for this function

; ---------------------------------------------------------------
; Configure the status registers as needed.
; ---------------------------------------------------------------

        BCLR    ACOV0

; ---------------------------------------------------------------
; Setup passed parameters in their destination registers
; Setup linear CDP/ARx behavior
; ---------------------------------------------------------------
; x pointer - passed in its destination register
; y pointer - passed in its destination register
; r pointer - passed in its destination register
; ---------------------------------------------------------------

; ---------------------------------------------------------------
; Setup loop counts
; ---------------------------------------------------------------

	SUB	#1, T0			;T0 = nx-1
	MOV	T0, outer_cnt		;outer loop executes nx times

; ---------------------------------------------------------------
; Setup output shift
; ---------------------------------------------------------------
        AMOV    #-1, T0
	XCC	T1 == #0        	;testing for scaling
           ||AMOV     #0, T0

; ---------------------------------------------------------------
; Start of outer loop 
; for (i=0; iP<nx; i++)
;    R(i) = X(i) + Y(i);
; ---------------------------------------------------------------

	RPTBLOCAL	LoopEnd-1                  ;start the outer loop
	        ADD	*AR0+, *AR1+, AC0       ;vector add of two inputs
	        MOV	HI(AC0 << T0), *AR2+    ; shift right by 0 or 1
LoopEnd:                                           ;end of outer loop

; ---------------------------------------------------------------
; Check if overflow occurred, and setup return value
; ---------------------------------------------------------------

	MOV	#0, oflag		;clear oflag
	XCCPART	overflow(AC0)
            ||MOV	#1, oflag	;overflow occured

; ---------------------------------------------------------------
; Restore status regs to expected C-convention values as needed
; ---------------------------------------------------------------

; ----------------------------------------------------------------
; Restore any save-on-entry registers that are used
; ----------------------------------------------------------------
; - nothing to restore for this function

; ---------------------------------------------------------------
; Deallocate the local frame and argument block
; ---------------------------------------------------------------
;      SP = SP + #(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ)
; - not necessary for this function (the above is zero)

; ---------------------------------------------------------------
; Return to calling function
; ---------------------------------------------------------------

      RET		 
		
;----------------------------------------------------------------
;End of file 	

araw.asm/       1362765892  0     0     0       11609     `
;/*
; * Copyright (C) 2013 Texas Instruments Incorporated - http://www.ti.com/ 
; * 
; * 
; *  Redistribution and use in source and binary forms, with or without 
; *  modification, are permitted provided that the following conditions 
; *  are met:
; *
; *    Redistributions of source code must retain the above copyright 
; *    notice, this list of conditions and the following disclaimer.
; *
; *    Redistributions in binary form must reproduce the above copyright
; *    notice, this list of conditions and the following disclaimer in the 
; *    documentation and/or other materials provided with the   
; *    distribution.
; *
; *    Neither the name of Texas Instruments Incorporated nor the names of
; *    its contributors may be used to endorse or promote products derived
; *    from this software without specific prior written permission.
; *
; *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
; *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
; *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
; *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
; *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
; *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
; *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
; *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
; *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
; *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
; *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
; *
;*/

;***********************************************************
; Version 3.00.00                                           
;***********************************************************
; Function:    acorr_raw
; Version:     2.0
; Processor:   C55xx
;
; Description: calculates raw auto-correlation
;
; Usage:    short acorr_raw(DATA *x, DATA *r, ushort nx, ushort nr)
;
; Limits:
;     nr <= nx
;     nx != 3
;
; Notes:
;   This function uses the dual-mac, but since it is doing an autocorrelation, all 3
;   operands are taken from the same page of memory, thus causing 1 cycle of delay for
;   arrays in DARAM, and 2 cycles of delay for arrays in SARAM.  So intuition would say
;   that it would be simpler and faster to skip the dual-mac and just use single macs.
;   That logic would be true for arrays in DARAM.  But for arrays in SARAM, each single-mac
;   instruction would cause a one-cycle delay.  Hence, the use of the dual-mac for arrays
;   in SARAM will cause a performance improvement of 25%.
;   For better performance, it would be much faster to perform the autocorrelation by
;   first temporarily copying the array to a different block of memory.  Copying to SARAM 
;   would be okay.  Then do the dual-mac autocorrelation between the original and its clone.  
;   This should speed up the autocorrelation by up to 50% from its current speed.
;
; Benchmarks:
;   Cycles:
;     nx =  128:  nr = 128:    8557
;     nx =  128:  nr = 127:    8557
;     nx =  128:  nr = 126:    8554
;     nx =  128:  nr = 125:    8554
;     nx =   64:  nr =  64:    2252
;     nx =   16:  nr =  15:     212
;   Code Size (in bytes):   162
;
; History:
;       Li Yuan - 08/14/2001
; - Changed save and restore AR5/AR6/AR7 to XAR5/XAR6/XAR7 registers.
; - Fixed XARx init bug (added Xx_ptr,Xx_save,Xx2_save,Xxb_ptr).
;
;       Zhengting He - 10/25/2006
; - Added overflow checking and overflow is returned in T0 instead of 
;   AC0 register
;
;       Craig Leeds - 05/31/2012
;   Bug fixed: AR5 was modified but not restored (if an interrupt occured).
;   Bug fixed: AC0 and AC3 checked for overflow, but their bit not cleared on entry.
;   Bug fixed: if NR is odd, one too many elements were written to r[].
;   Bug fixed: if NX is 1 or 2, output was incorrect.
;   Outer loop optimized.
;
;****************************************************************

	.ARMS_off                     ;enable assembler for ARMS=0
	.CPL_on                       ;enable assembler for CPL=1
	.mmregs                       ;enable mem mapped register names
	.global _acorr_raw

; Stack frame
; -----------
RET_ADDR_SZ       .set 1            ;return address
REG_SAVE_SZ       .set 2            ;save-on-entry registers saved (T2, T3)
FRAME_SZ          .set 2            ;local variables
ARG_BLK_SZ        .set 0            ;argument block

; Register usage
; --------------

PARAM_OFFSET    .set  FRAME_SZ + REG_SAVE_SZ
        .asg    0, rSUBnr           ; original r[nr] value
        .asg    1, r_save           ; original r

        .asg    0 + FRAME_SZ + REG_SAVE_SZ, RETURN_ADDR
        
        .asg    T0, nx
        .asg    T1, nr
        .asg    T2, loop_count

        .asg    AR0, x_ptr
        .asg    XAR0, Xx_ptr
        .asg    AR1, r_ptr
        .asg    AR2, x_save
        .asg    XAR2, Xx_save
        .asg    AR3, x2_save
        .asg    XAR3, Xx2_save
        .asg    AR4, xb_ptr
        .asg    XAR4, Xxb_ptr

;
; CSR = counter = nx - 3;
; BRC0 = loop_count = MIN(((nr+1)/2), ((nx-1)/2)) - 1;  // number of passes thru RPTBLOCAL block minus 1
; mac2flag = ((nx & 1) == 0) &&((nx - nr) <= 1)         // do 2 macs at the end
; mac1flag = (nx == nr)                                 // do 1 mac  at the end  (note: independent of mac2flag)
; restoreFlag = (nr & 1) && (!(mac2flag | mac1flag))    // restore original r[nr] at end
;

        .text
_acorr_raw:

;
; Save any save-on-entry registers that are used
; Configure the status registers as needed.
;----------------------------------------------------------------
        PSH     T3, T2
      ||BCLR    ARMS                     ; clear ARMS
        BSET    FRCT                     ; Set FRCT
        ROR     CARRY, nx, TC2, AC3      ; TC2 = 1 if nx is odd (AC3 is irrelevant)
      ||BCLR    ACOV3                    ; clear overflow bit 

;
; Allocate the local frame and argument block( +1 is for dbl alignment)
;----------------------------------------------------------------
        AADD    #-(ARG_BLK_SZ + FRAME_SZ + 1), SP
     || BCLR    ACOV0                    ; clear overflow bit 
;
; Initialize some of the variables
;----------------------------------------------------------------

        SUB     #1, nr, loop_count
        SUB     #3, nx, T3
        MIN     T3, loop_count
        SFTS    loop_count, #-1
        MOV     loop_count, BRC0       ; loop_count = MIN(((nr+1)/2), ((nx-1)/2)) - 1;  

; mac2flag = ((nx & 1) == 0) &&((nx - nr) <= 1)         // do 2 macs at the end
; mac1flag = (nx == nr)                                 // do 1 mac  at the end  (note: independent of mac2flag)
; restoreFlag = (nr & 1) && (!(mac2flag | mac1flag))    // restore original r[nr] at end

        MOV     nx, AC0
     || MOV     #0, AC1
        SUB     nr, AC0                  ; AC0 = (nx - nr)
        SUB     #1, AC0, AC3             ; AC3 = (nx - nr) - 1 
        CMPAND  AC3 <= AC1, !TC2, TC1    ; TC1 = mac2flag = ((nx & 1) == 0) &&((nx - nr) <= 1) 
        CMP     AC0 == AC1, TC2          ; TC2 = mac1flag = (nx == nr) 

     || AND     #1, nr, T3               ; T3 = (nx - nr)
        XCCPART TC1 | TC2
            ||MOV   #0, T3               ; T3 = restoreFlag = (nr & 1) && (!(mac2flag | mac1flag))    // restore original r[nr] at end
        XCCPART T3 != #0
            ||MOV     *r_ptr(nr), AC0
        MOV     AC0, *SP(rSUBnr)         ; save original r[nr] 
        MOV     r_ptr, *SP(r_save)       ; r_save = r_ptr

;----------------------------------------------------------------
    
        MOV     Xx_ptr, XCDP            ; Setup CDP         
        MOV     Xx_ptr, Xx_save
        MOV     Xx_ptr, Xx2_save
        AMAR    *x_ptr(#1), Xxb_ptr   ; Setup the secondary pointer

        SUB     #3, nx                   ; 
        MOV     nx, CSR                  ; Because of the CSR updates, we need to preload CSR

; If nx < 4, then skip the repeat block.
; If nx is 3, the function will not work!
      
        BCC      OuterLoopEnd, loop_count < #0
;
; Perform correlation:                                       
;----------------------------------------------------------------
        RPTBLOCAL OuterLoopEnd-1

                ; ---- Preload ----
                MPY     *x_ptr+, *CDP+, AC0
                ::MPY   *xb_ptr+, *CDP+, AC3

                ; ---- Main Dual MAC loop  ----
             || RPTSUB  CSR, #2
                        MAC     *x_ptr+, *CDP+, AC0
                        ::MAC   *xb_ptr+, *CDP+, AC3
    
                ; ---- Do final MAC for A  ----
                MACMR   *x_ptr, *CDP, AC0        ;Create the A result (B result already created)
              ||AADD    #2, x2_save              ; increment x2_save to next set of 2 starting points
              
                MOV     rnd(HI(AC0)), *r_ptr+    ; Store A
             || AMOV    x2_save, x_ptr           ; reset x_ptr to next set of 2 starting points
        
                ; ---- Final MAC for A  ----
                MOV     rnd(HI(AC3)), *r_ptr+    ; Store B
             || AMAR    *x_save, XCDP            ; Reset CDP
    

                ; ---- Store B, reload x_pointer (used for A) with new x2_save ----
                ; ---- Reload xb_ptr (used for B) with one more than x_ptr ----
                AMAR    *x2_save(#1), Xxb_ptr         ;xb_ptr = x_ptr + #1 ; Setup the secondary pointer
OuterLoopEnd:

;;;     BCC     Skip2macs, !TC1

; ---- 2 -----
; Do 2 macs at the end
; ((nx - nr) <= 1)                     

        XCC    TC1
             ||MPYM    *x_ptr+, *CDP+, AC0
        XCC    TC1
             ||MACMR   *x_ptr, *CDP-, AC0
        XCC    TC1
             ||MOV    HI(AC0), *r_ptr+
;;;Skip2macs:

; ---- 1 -----
; Do 1 macs at the end
; ((nx - nr) == 0)                     

        MPYMR   *x_ptr, *CDP, AC0
        XCCPART TC2
            ||MOV    HI(AC0), *r_ptr

        MOV     *SP(r_save), r_ptr     ; r_ptr = r_save
;
; Check if overflow occurred, and setup return value
;----------------------------------------------------------------
        MOV     #0, T0               ;clear oflag
        XCCPART overflow(AC0)        ;clears ACOV0
             ||MOV    #1, T0         ;overflow occurred
        XCCPART overflow(AC3)        ;clears ACOV3
             ||MOV    #1, T0         ;overflow occurred
;
; If there were an odd number of output elements (i.e. T3 is set)
; then r[nr] was incorrectly overwritten.
; So restore r[nr] to its original value.
;
        MOV    *SP(rSUBnr), AC0
        XCCPART T3 != #0
            ||MOV   AC0, *r_ptr(nr)
;
; Restore status regs to expected C-convention values as needed
; Restore any save-on-entry registers that are used
;----------------------------------------------------------------
;
; Deallocate the local frame and argument block
;----------------------------------------------------------------
        AADD    #+(ARG_BLK_SZ + FRAME_SZ + 1), SP
        POP     T3, T2
     || BSET    ARMS                 ; set ARMS for C
;
; Return to calling function
;----------------------------------------------------------------
        RET     
     || BCLR    FRCT                 ; Clear FRCT for C
;----------------------------------------------------------------
;End of file

arct2.asm/      1362765892  0     0     0       6932      `
;/*
; * Copyright (C) 2013 Texas Instruments Incorporated - http://www.ti.com/ 
; * 
; * 
; *  Redistribution and use in source and binary forms, with or without 
; *  modification, are permitted provided that the following conditions 
; *  are met:
; *
; *    Redistributions of source code must retain the above copyright 
; *    notice, this list of conditions and the following disclaimer.
; *
; *    Redistributions in binary form must reproduce the above copyright
; *    notice, this list of conditions and the following disclaimer in the 
; *    documentation and/or other materials provided with the   
; *    distribution.
; *
; *    Neither the name of Texas Instruments Incorporated nor the names of
; *    its contributors may be used to endorse or promote products derived
; *    from this software without specific prior written permission.
; *
; *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
; *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
; *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
; *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
; *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
; *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
; *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
; *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
; *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
; *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
; *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
; *
;*/

;***********************************************************
; Version 3.00.00                                           
;***********************************************************
;****************************************************************
; Function:    atan2_16
; Processor:   C55xx
; Description: arctangent 2 implementation
; Usage:    short atan2( DATA *x2, DATA *x1, DATA *r, int *nx)
;   r[i]=arctangent(x1[i]/x2[i]) Q15 format
;   nx=number of elements in x1,x2,r
;   x1,x2 input
;   r result
;   return 0 if ok; 1 if error
;   
; Benchmarks:
;   Cycles:       (nx * 39) + 21
;   Code Size (in bytes):  168
;
;  History:
;    Craig Leeds 05/25/2012:  Optimized by 40%; removed .data
;****************************************************************
        .mmregs
        .cpl_on
        .arms_on

        .def    _atan2_16


********************************************************************************

;;;        .sect ".const"    
;;;atancoeffs:
;;;        .word 0xfda8 ; C5 -0.009159*2*32767.999*x^5
;;;        .word 0x118b ; C4 +0.068542*2*32767.999*x^4
;;;        .word 0xde7c ; C3 -0.130908*2*32767.999*x^3    
;;;        .word 0x00d9 ; C2 +0.003314*2*32767.999*x^2
;;;        .word 0x5179 ; C1 +0.318253*2*32767.999*x^1
;;;;;;     .word 0x0000 ; C0 0*x^0


; LOCAL VARIABLE
;* AR0   assigned to _x
;* AR1   assigned to _y
;* AR2   assigned to _r
;* T0   assigned to _nx
        
        .text
_atan2_16:
        PSH     T3, T2
     || BSET    FRCT                    ;fractional mode set
        PSH     AR5, AR6                ; Note: doesn't use AR5H and AR6H
     || BSET    SATD                    ;saturation mode on
        SUB     #1, T0                  ;nx - 1
        MOV     T0, BRC0                ;repeat nx times
        MOV     #2-1, BRC1
        MOV     #0xfda8, T3             ; T3  = C5 -0.009159*2*32767.999*x^5
        MOV     #0x118b, AR3            ; AR3 = C4 +0.068542*2*32767.999*x^4
        MOV     #0xde7c, AR4            ; AR4 = C3 -0.130908*2*32767.999*x^3    
        MOV     #0x00d9, AR5            ; AR5 = C2 +0.003314*2*32767.999*x^2
        MOV     #0x5179, AR6            ; AR6 = C1 +0.318253*2*32767.999*x^1

     || RPTBLOCAL OuterLoopEnd-1
                MOV     *AR0 << #16, AC0
             || MOV     *AR1 << #16, AC1
                ABS     AC0
             || BCLR    TC1
                MOV     HI(AC0), T2
             || ABS     AC1
                MAX     AC1, AC0

                XCCPART   CARRY
                      ||BSET    TC1

                XCCPART CARRY
                      ||MOV     HI(AC1), T2

                MANT    AC0, AC1
              ::NEXP    AC0, T1

*****************************************************************************
; INPUT VALUE IN AC1,T1,T2
; RETURN AC1
; USE: AC0,AC1
; FRCT = 1
                SFTS    AC1, #-1, AC2
                XOR     #1FFFh << #16, AC2
              ||MOV     HI(AC1), T0

; COMPUTE 2^28/X
; Calculate Ym = 2*Ym - Ym^2*X
                RPTBLOCAL InnerLoopEnd-1
; Ym: AC2_h ; X: T0
                        MPY     T0, AC2, AC3
                     || SFTS    AC2, #-1, AC0
                        MPY     AC2, AC3
                        SUB     AC3, AC0
                        SFTS    AC0, #2, AC2
InnerLoopEnd:

; LAST ITERATION
                MPY     T0, AC2, AC3
             || SFTS    AC0, #1
                MPY     AC2, AC3
             || NEG     T1
                SUB     AC3, AC0

                MPY     T2, AC0, AC2
                SFTS    AC2, #3, AC2
                SFTL    AC2, T1, AC2

                SFTS    AC2, #1
             || MOV     T3, HI(AC0)        ; C5
                MOV     HI(AC2), T0
             || MOV     AR3, HI(AC1)       ; C4
                MACR    AC0, T0, AC1, AC0
             || MOV     AR4, HI(AC1)       ; C3
                MACR    AC0, T0, AC1, AC0
             || MOV     AR5, HI(AC1)       ; C2
                MACR    AC0, T0, AC1, AC0
             || MOV     AR6, HI(AC1)       ; C1
                MACR    AC0, T0, AC1, AC0
                MPYR    T0, AC0
                SFTS    AC0, #-1

*****************************************************************************
             || BTST    #15, *AR0+, TC2
                XCCPART !TC1
                      ||SUB        #16384 << #16, AC0
                XCCPART !TC1
                      ||NEG        AC0

                BTST    #15, *AR1+, TC1
                XCCPART        TC2
                     || SUB        #32767 << #16, AC0
                XCCPART        TC1 ^ TC2
                     || NEG        AC0
                MOV     HI(AC0), *AR2+        
OuterLoopEnd:

        POP     AR5, AR6
      ||BCLR    FRCT                        ;fractional mode reset
        POP     T3, T2
      || BCLR   SATD                        ;saturation mode off
        MOV     #0, T0                      ;returned value
      ||RET

;*************************************************

;end of file. please do not remove. it is left here to ensure that no lines of code are removed by any editor


        

atan16.asm/     1363895488  0     0     0       3565      `
;/*
; * Copyright (C) 2013 Texas Instruments Incorporated - http://www.ti.com/ 
; * 
; * 
; *  Redistribution and use in source and binary forms, with or without 
; *  modification, are permitted provided that the following conditions 
; *  are met:
; *
; *    Redistributions of source code must retain the above copyright 
; *    notice, this list of conditions and the following disclaimer.
; *
; *    Redistributions in binary form must reproduce the above copyright
; *    notice, this list of conditions and the following disclaimer in the 
; *    documentation and/or other materials provided with the   
; *    distribution.
; *
; *    Neither the name of Texas Instruments Incorporated nor the names of
; *    its contributors may be used to endorse or promote products derived
; *    from this software without specific prior written permission.
; *
; *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
; *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
; *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
; *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
; *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
; *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
; *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
; *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
; *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
; *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
; *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
; *
;*/

;***********************************************************
; Version 3.00.00                                           
;***********************************************************
; Function:    atan16
; Processor:   C55xx
; Description: Arctangent implementation
; Usage:   short atan16( DATA *x, DATA *r, int nx)
;   nx : number of element of x and r
;   r[i]=atan(x[i]) with x and r in Q15 format
;   return 0
;
; Benchmarks:
;   Cycles:   (5 * nx) + 14
;   Code Size (in bytes):  49
;
; History:
;   05/25/2012 Craig Leeds:  .data removed; Optimized by 30%.
;   03/20/2013 Craig Leeds:  Optimized by 17%
;****************************************************************

	.mmregs
	.cpl_on
	.arms_on

	.def	_atan16

        .text
_atan16:
;* AR0   assigned to _x
;* AR1   assigned to _r
;* T0   assigned to _nx
        PSH     T3
     || BSET	FRCT			;fractional mode
	SUB	#1, T0			;nx-1
	MOV	T0, BRC0		;repeat nx times
        MOV     #2596 << #16, AC3       ; AC3.Hi = C5
        MOV	#-9464 << #16, AC1	; AC1.Hi = C3
	MOV	#32617 << #16, AC2	; AC2.Hi = C1
*
* Note: loading T3 on the instruction before a multiply that uses it will
* cause a 1-cycle delay.
*
	MPYMR	T3=*AR0+, AC3, AC0      ; (Prime the Pump)
	
     || RPTBLOCAL	loop1-1
	        MACR	AC0, T3, AC1, AC0
	        MPYR	T3, AC0
	      ||MOV	*AR0+, T1               ; (for next iteration)
	        MACR	AC0, T3, AC2, AC0
	        MPYR	T3, AC0
              ||MOV	T1, T3
	        MOV	HI(AC0), *AR1+		;save result
	      ||MPYR	T1, AC3, AC0            ; (for next iteration)
loop1:

        POP     T3
     || BCLR	FRCT			;return to standard C
	MOV	#0, T0			;return OK value (no possible error)
     || RET

;end of file. please do not remove. it is left here to ensure that no lines of code are removed by any editor

aubias.asm/     1362765892  0     0     0       12695     `
;/*
; * Copyright (C) 2013 Texas Instruments Incorporated - http://www.ti.com/ 
; * 
; * 
; *  Redistribution and use in source and binary forms, with or without 
; *  modification, are permitted provided that the following conditions 
; *  are met:
; *
; *    Redistributions of source code must retain the above copyright 
; *    notice, this list of conditions and the following disclaimer.
; *
; *    Redistributions in binary form must reproduce the above copyright
; *    notice, this list of conditions and the following disclaimer in the 
; *    documentation and/or other materials provided with the   
; *    distribution.
; *
; *    Neither the name of Texas Instruments Incorporated nor the names of
; *    its contributors may be used to endorse or promote products derived
; *    from this software without specific prior written permission.
; *
; *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
; *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
; *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
; *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
; *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
; *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
; *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
; *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
; *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
; *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
; *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
; *
;*/

;***********************************************************
; Version 3.00.00                                           
;***********************************************************
;****************************************************************
; Function:    acorr_unbias
; Processor:   C55xx
; Description: calculates positive unbiased auto-correlation
;
; Usage:    short acorr_unbias(DATA *x, DATA *r, ushort nx, ushort nr)
;
; Notes:
;   This function uses the dual-mac, but since it is doing an autocorrelation, all 3
;   operands are taken from the same page of memory, thus causing 1 cycle of delay for
;   arrays in DARAM, and 2 cycles of delay for arrays in SARAM.  So intuition would say
;   that it would be simpler and faster to skip the dual-mac and just use single macs.
;   That logic would be true for arrays in DARAM.  But for arrays in SARAM, each single-mac
;   instruction would cause a one-cycle delay.  Hence, the use of the dual-mac for arrays
;   in SARAM will cause a performance improvement of 25%.
;   For better performance, it would be much faster to perform the autocorrelation by
;   first temporarily copying the array to a different block of memory.  Copying to SARAM 
;   would be okay.  Then do the dual-mac autocorrelation between the original and its clone.  
;   This should speed up the autocorrelation by up to 50% from its current speed.
;
; Benchmarks:
;   Cycles:
;     nx =  152:  nr = 152:   12148
;     nx =  128:  nr = 128:    11397
;     nx =   81:  nr =  81:    5335
;     nx =   64:  nr =  64:    3653
;     nx =   32:  nr =  32:    1317
;   Code Size (in bytes):  214
;
; History:
;       Li Yuan - 08/14/2001
; - Changed save and restore AR5/AR6/AR7 to XAR5/XAR6/XAR7 registers.
; - Fixed XARx init bug (added Xx_ptr,Xx_save,Xx2_save,Xxb_ptr).
;
;       Zhengting He - 10/25/2006
; - Added overflow checking and overflow is returned in T0 instead of 
;   AC0 register
;
;       Craig Leeds - 05/31/2012
;   Bug fixed where AR4 was used before being set.
;   Fixed bug where AR5 was modified but not correctly restored.
;   Fixed bug where AC0 and AC3 were checked for overflow, but overflow was not first cleared.
;   Fixed bug where T2 and T3 were modified but not restored.
;   Fixed bug where the incorrect number of elements were saved when nr was odd
;   Fixed bug where SXMD was clear instead of set on exit.
;   Fixed bug where compiler was told ARMS was clear, but it was set.
;   Optimized main loop some.
;
;****************************************************************

	.ARMS_off                     ;enable assembler for ARMS=0
	.CPL_on                       ;enable assembler for CPL=1
	.mmregs                       ;enable mem mapped register names
	.global _acorr_unbias

; Stack frame
; -----------
RET_ADDR_SZ       .set 1            ;return address
REG_SAVE_SZ       .set 2            ;save-on-entry registers saved (T2, T3)
FRAME_SZ          .set 5            ;local variables
ARG_BLK_SZ        .set 0            ;argument block

; Register usage
; --------------

PARAM_OFFSET    .set  FRAME_SZ + REG_SAVE_SZ
	.asg    0, temp
	.asg    1, tempb
        .asg    2, rSUBnr           ; original r[nr] value
        .asg    3, r_save           ; original r
        .asg    4, restoreFlag      ; 
	.asg    0 + FRAME_SZ + REG_SAVE_SZ, RETURN_ADDR
	
	.asg	 AR0,  x_ptr
	.asg	XAR0, Xx_ptr
	.asg	 AR1,  r_ptr
	.asg	XAR1, Xr_ptr
	.asg	 AR2,  x_save
	.asg	XAR2, Xx_save
	.asg     AR3,  x2_save
	.asg    XAR3, Xx2_save
	.asg     AR4,  xb_ptr
	.asg    XAR4, Xxb_ptr
        
	.asg	T0,  nx
	.asg	T1,  nr
	.asg    T2,   loop_count
	
    
;
; CSR = counter = nx - 3
; BRC0 = loop_count = MIN(((nr+1)/2), ((nx-1)/2)) - 1;  // number of passes thru RPTBLOCAL block minus 1
; mac2flag = ((nx & 1) == 0) &&((nx - nr) <= 1)         // do 2 macs at the end
; mac1flag = (nx == nr)                                 // do 1 mac  at the end  (note: independent of mac2flag)
; restoreFlag = (nr & 1) && (!(mac2flag | mac1flag))    // restore original r[nr] at end
;

        .text
_acorr_unbias:
;
; Save any save-on-entry registers that are used
; Configure the status registers as needed.
;----------------------------------------------------------------
        PSH     T2, T3
      ||BCLR    ARMS                 ; clear ARMS
        BSET    FRCT                 ; Set FRCT
        ROR     CARRY, nx, TC2, AC3  ; TC2 = 1 if nx is odd (AC3 is irrelevant)
     || BCLR    ACOV0                ; clear overflow bit
        BCLR    ACOV3                ; clear overflow bit
;
; Allocate the local frame and argument block( +1 is for dbl alignment)
;----------------------------------------------------------------
     || AADD    #-(ARG_BLK_SZ + FRAME_SZ), SP
;
; Initialize some of the variables
;----------------------------------------------------------------
        SUB     #1, nr, loop_count
        SUB     #3, nx, T3
        MIN     T3, loop_count
        SFTS    loop_count, #-1
        MOV     loop_count, BRC0       ; loop_count = MIN(((nr+1)/2), ((nx-1)/2)) - 1;  

; mac2flag = ((nx & 1) == 0) &&((nx - nr) <= 1)         // do 2 macs at the end
; mac1flag = (nx == nr)                                 // do 1 mac  at the end  (note: independent of mac2flag)
; restoreFlag = (nr & 1) && (!(mac2flag | mac1flag))    // restore original r[nr] at end

        MOV     nx, AC0
     || MOV     #0, AC1
        SUB     nr, AC0                  ; AC0 = (nx - nr)
        SUB     #1, AC0, AC3             ; AC3 = (nx - nr) - 1 
        CMPAND  AC3 <= AC1, !TC2, TC1    ; TC1 = mac2flag = ((nx & 1) == 0) &&((nx - nr) <= 1) 
        CMP     AC0 == AC1, TC2          ; TC2 = mac1flag = (nx == nr) 

     || AND     #1, nr, T3               ; T3 = (nx - nr)
        XCCPART TC1 | TC2
            ||MOV   #0, T3               ; T3 = restoreFlag = (nr & 1) && (!(mac2flag | mac1flag))    // restore original r[nr] at end
        MOV     T3, *SP(restoreFlag)
        XCCPART T3 != #0
            ||MOV     *r_ptr(nr), AC0
        MOV     AC0, *SP(rSUBnr)         ; save original r[nr] 
        MOV     r_ptr, *SP(r_save)       ; r_save = r_ptr

; Generic pointer and loop setup 
;      Generic will be used by both normal dual mac 

        MOV     Xx_ptr, XCDP          ; Setup CDP         
        MOV     Xx_ptr, Xx_save
        MOV     Xx_ptr, Xx2_save
        AMAR    *x_ptr(#1), Xxb_ptr   ; Setup the secondary pointer

;--------Divisor value setup----------
        MOV     nx, *SP(#temp)        ; This value is used for division
        SUB     #1, nx, AC0
            
        SUB     #3, nx, T3
        MOV     T3, CSR                ; CSR = nx - 3
        MOV     #16-1, BRC1

     || BCC      OuterLoopEnd, loop_count < #0

        MOV     AC0, *SP(#tempb)      ; This value is used for division for the second thing
        
; Perform correlation:                                       
;----------------------------------------------------------------        
     || RPTBLOCAL OuterLoopEnd-1

; ---- Preload ----
                MPY     *x_ptr+, *CDP+, AC0
                ::MPY   *xb_ptr+, *CDP+, AC3

; ---- Main Dual MAC loop  ----
              ||RPTSUB  CSR, #2
                        MAC     *x_ptr+, *CDP+, AC0
                        ::MAC   *xb_ptr+, *CDP+, AC3

; ---- Do one MAC for A, Load T4 with B  ----
                MACM    *x_ptr+, *CDP+, AC0
              ||MOV     HI(AC3), T3

; ---- Scale results ----
; Divide result by number of MACs performed, result is in 
; lower half of accumulator
;
; A and B are only used to give C and D the correct sign

                MOV     HI(AC0), T2

; ---- Get ABS of C and D, update CDP and x2_save ----
              ||ABS     T3, AC3             ; C
                MOV     x_save, CDP
              ||ABS     T2, AC0

                BCLR    SXMD                ; Set SXMD
                ADD     #2, x2_save

; ---- Scale values ----

             || RPTBLOCAL DivideLoopEnd-1
                        NOP_16              ; Remark 5682: CPU_116
                      ||SUBC    *SP(#temp), AC0
                        SUBC    *SP(#tempb), AC3     ; C
DivideLoopEnd:

                BSET    SXMD                ; Set SXMD

; ---- Negate if necessary ----
                XCCPART T2 < #0                ; for the second variable
                    ||NEG   AC0                ; C
                XCCPART T3 < #0
                    ||NEG   AC3

; ---- Store the values, update A pointer ----
                MOV     AC0, *r_ptr+
              ||AMOV    x2_save, x_ptr
                MOV     AC3, *r_ptr+
                AMAR    *x2_save(#1), Xxb_ptr        ; Setup the secondary pointer        
        
; ---- Update scaling values ----
                ADD     #-2, *SP(#temp)
                ADD     #-2, *SP(#tempb)

; ---- B pointer update ----

OuterLoopEnd:

; ---- 2 -----
; Do 2 macs at the end
; ((nx - nr) <= 1)                     
        XCC     TC1
              ||MPYM    *x_ptr+, *CDP+, AC0
        XCC     TC1
              ||MACMR   *x_ptr, *CDP-, AC0 
        XCC     TC1
              ||MOV     HI(AC0 <<#-1), *r_ptr+     ; divide by 2

; ---- 1 -----
        MPYMR   *x_ptr, *CDP, AC0
        XCCPART TC2
              ||MOV     HI(AC0), *r_ptr+           ; divide by 1

        MOV     *SP(r_save), r_ptr     ; r_ptr = r_save
        MOV     *SP(restoreFlag), T2

; Check if overflow occurred, and setup return value
; Do 1 macs at the end
; ((nx - nr) == 0)                     
;----------------------------------------------------------------
        MOV     #0, T0               ;clear oflag
        XCCPART overflow(AC0)        ;clears ACOV0
            ||MOV   #1, T0           ;overflow occurred
        XCCPART overflow(AC3)        ;clears ACOV3
            ||MOV   #1, T0           ;overflow occurred
;
; If there were an odd number of output elements 
; then r[nr] may have been incorrectly overwritten.
; So restore r[nr] to its original value.
;
        MOV    *SP(rSUBnr), AC0
        XCCPART T2 != #0
            ||MOV   AC0, *r_ptr(nr)
;
; Restore status regs to expected C-convention values as needed
; Restore any save-on-entry registers that are used
;----------------------------------------------------------------
;
; Deallocate the local frame and argument block
;----------------------------------------------------------------

        AADD    #(ARG_BLK_SZ + FRAME_SZ), SP
        POP     T2, T3
     || BSET    ARMS                 ; set ARMS for C
;
; Return to calling function
;----------------------------------------------------------------
        RET                        
     || BCLR    FRCT                 ; Clear FRCT for C
;----------------------------------------------------------------
;End of file

bexp.asm/       1364239266  0     0     0       3295      `
;/*
; * Copyright (C) 2013 Texas Instruments Incorporated - http://www.ti.com/ 
; * 
; * 
; *  Redistribution and use in source and binary forms, with or without 
; *  modification, are permitted provided that the following conditions 
; *  are met:
; *
; *    Redistributions of source code must retain the above copyright 
; *    notice, this list of conditions and the following disclaimer.
; *
; *    Redistributions in binary form must reproduce the above copyright
; *    notice, this list of conditions and the following disclaimer in the 
; *    documentation and/or other materials provided with the   
; *    distribution.
; *
; *    Neither the name of Texas Instruments Incorporated nor the names of
; *    its contributors may be used to endorse or promote products derived
; *    from this software without specific prior written permission.
; *
; *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
; *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
; *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
; *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
; *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
; *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
; *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
; *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
; *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
; *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
; *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
; *
;*/

;***********************************************************
; Version 3.00.00                                           
;***********************************************************
; Function:    bexp
; Version:     3.0
; Processor:   C55xx
; Description: block exponent
; Usage: short r_maxexp = bexp (DATA *x, ushort nx)
;  
; Benchmarks:
;   Cycles:       (3 * nx) + 9
;   Code Size (in bytes):  21
;
; History:
;        Craig Leeds  - 05/17/2012
;   Optimized loop from 5 cycles to 3 cycles, and optimized housekeeping.
;-----------------------------------------------------------------------------
; Register usage
; --------------
      .asg     AR0, in_ptr  

      .global _bexp
      .text

_bexp:
      SUB #1,T0                        ;setup loop counter=nx-1
      MOV T0,BRC0
      ||MOV #0x20,T0                   ;init T0 to the max exp
      MOV *in_ptr+ << #16,AC0          ;read in the vector with 16 bits left shift (Prime the Pump)

* Note: there is a 1-cycle pipeline delay in the loop.  So it requires 3 cycles per iteration instead of 2

      ||RPTBLOCAL end_block-1          ;start main loop
              EXP AC0,T1                       ;calculate exp and store the result into T1
              MIN T1,T0                        ;update T0 with min value
              ||MOV *in_ptr+ << #16,AC0        ;read in the vector with 16 bits left shift (for next iteration)
end_block:
      
      RET

;end of file. please do not remove. it is left here to ensure that no lines of code are removed by any editor

cbias.asm/      1362765892  0     0     0       13960     `
;/*
; * Copyright (C) 2013 Texas Instruments Incorporated - http://www.ti.com/ 
; * 
; * 
; *  Redistribution and use in source and binary forms, with or without 
; *  modification, are permitted provided that the following conditions 
; *  are met:
; *
; *    Redistributions of source code must retain the above copyright 
; *    notice, this list of conditions and the following disclaimer.
; *
; *    Redistributions in binary form must reproduce the above copyright
; *    notice, this list of conditions and the following disclaimer in the 
; *    documentation and/or other materials provided with the   
; *    distribution.
; *
; *    Neither the name of Texas Instruments Incorporated nor the names of
; *    its contributors may be used to endorse or promote products derived
; *    from this software without specific prior written permission.
; *
; *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
; *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
; *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
; *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
; *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
; *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
; *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
; *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
; *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
; *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
; *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
; *
;*/

;***********************************************************
; Version 3.00.00                                           
;***********************************************************
; Function:    corr_bias
; Processor:   C55xx
; Description: biased full length correlation of two vectors
;
; Usage: ushort corr_bias  (DATA *x, DATA *y, DATA *r, ushort nx, ushort ny);
;
; Notes:
;   If y[] is in SARAM instead of DARAM, the function will take twice as many cycles.
;
; Limitations:
;   ny >= nx
;   x[] must be on-chip (i.e. DARAM or SARAM)
;
; Benchmarks:
;   Cycles:
;      Cycle computations are very complicated.
;        For nx and ny = 128:     9068
;        For nx and ny = 100:     5708
;        For nx and ny =  64:     2540
;        For nx and ny =  50:     1622x
;        For nx and ny =  32:      812
;        For nx and ny =  24:      540
;        For nx and ny =  16:      332
;        For nx and ny =   8:      188
;   Code Size (in bytes):  338
;
; History:
; - Changed save and restore AR5/AR6/AR7 to XAR5/XAR6/XAR7 registers.
;   Li Yuan - 08/14/01
;
; - Added overflow checking and overflow is returned in T0 instead of 
;   AC0 register
;       Zhengting He - 10/25/2006
;
; - Fixed bug where CDPH never set
; - Fixed bug where AR5 was modified but not correctly restored
; - Fixed bug where T3 was modified but not correctly restored
; - Bug fixed where AC0 and AC1 checked for overflow, but bit not cleared on entry
; - Some optimizations of RPTBLOCAL blocks
;       Craig Leeds - 06/10/2012
;****************************************************************

      .ARMS_off                     ;enable assembler for ARMS=0
      .CPL_on                       ;enable assembler for CPL=1
      .mmregs                       ;enable mem mapped register names
      .global _corr_bias

; Stack frame
; -----------
RET_ADDR_SZ       .set 1            ;return address
REG_SAVE_SZ       .set 5            ;save-on-entry registers saved (T2, T3, AR5, AR6, AR7)
FRAME_SZ          .set 2            ;local variables
ARG_BLK_SZ        .set 0            ;argument block

; Register usage
; --------------
        

PARAM_OFFSET    .set  FRAME_SZ + REG_SAVE_SZ        
        .asg    0, temp
        .asg    1, n_inverse
        .asg    "0 + REG_SAVE_SZ + FRAME_SZ", RETURN_ADDR
        
        .asg    XAR0, Xx_ptr
        .asg     AR0,  x_ptr
        .asg    XAR1, Xy_ptr
        .asg     AR1,  y_ptr
        .asg    XAR2, Xr_ptr
        .asg     AR2,  r_ptr
        .asg     AR3,  region1_and_3_loop_cnt
        .asg    XAR4, Xx_save
        .asg     AR4,  x_save
        .asg    XAR5, Xy_save
        .asg     AR5,  y_save    
        .asg    XAR6, Xx2_save
        .asg     AR6,  x2_save
        .asg    XAR7, Xy_orig
        .asg     AR7,  y_orig    
        
        .asg    T0, nx             ; argument
        .asg    T1, ny             ; argument
        .asg    T2, mac_cnt
    
; bug: original return value in AC0
; fix: put in T0
        .asg    T0, oflag           ;returned value
        
        .text
_corr_bias:
;
; Allocate the local frame and argument block( +1 is for dbl alignment)
;----------------------------------------------------------------
        PSH     T2, T3
     || BCLR    ARMS
        PSHBOTH XAR5
     || BSET    #ST1_FRCT, ST1_55
        PSHBOTH XAR6
        PSHBOTH XAR7
     || BCLR    ACOV1                        ; clear overflow bit
        
        AADD    #-(ARG_BLK_SZ + FRAME_SZ), SP
;
; Save any save-on-entry registers that are used
; Configure the status registers as needed.
;----------------------------------------------------------------

        

;---------- X pointer setup    
; x_ptr                -        X pointer as passed
; x_save        -        X+nx
; x2_save        -        Unchanged original X pointer
        MOV     Xx_ptr, Xx2_save
        MOV     Xx_ptr, AC0
        ADD     nx, AC0
        MOV     AC0, Xx_save
;
; Calculate inverse of number of MACs  = nx                 
; We load Q15 equivalent of 1 into accumulator and use SUBC 
; Thus calculating Q15 equivalent of 1/N                    
;----------------------------------------------------------------
        
        MOV     nx, *SP(#(temp))
        MOV     #32767, AC0
        
        RPT     #16-1
                SUBC    *SP(#(temp)), AC0, AC0
        
        ADD     #1, AC0
     || BCLR    ACOV0                        ; clear overflow bit
        MOV     AC0, *SP(#(n_inverse))
         
;---------- Y pointer setup    
; y_ptr                -        Y pointer as passed
; y_orig                -        Unchainged original Y pointer
        MOV     Xy_ptr, Xy_save
        MOV     Xy_ptr, Xy_orig

; Initialize MAC cnt for regions 1 & 3, these will be          
; calculated in one loop, since the number of elements is the  
; same in each region.                                         
;----------------------------------------------------------------
        MOV     nx, AC1
        SUB     #4, AC1
        MOV     AC1, region1_and_3_loop_cnt
        SUB     #1, x_save

; ---- ODD detection ----
; Due to the Dual MAC, we need to know if the region 1 and region 3
; are odd or even in length. If the number is odd, then we will need
; to do an extra MAC outside of the loop.
        BTST    @#0, region1_and_3_loop_cnt, TC1

;        
; Initial lag is in region 1, load initial MAC count and      
; number of elements to calculate in region 1                 
;----------------------------------------------------------------

REGION1:
; ---- Pointer setup -----
        MOV     y_save, y_ptr
        MOV     x_save, x_ptr
        
; ---- Initialize BRC and mac_cnt -----
        SFTL     region1_and_3_loop_cnt, #-1
        XCCPART !TC1
             || SUB     #1, region1_and_3_loop_cnt
        MOV     region1_and_3_loop_cnt, BRC0
        
        MOV     #0, mac_cnt
                
        MPYM    *x_ptr, *y_ptr+, AC0
        MPYMR   *SP(#(n_inverse)), AC0, AC0
        MOV     HI(AC0), *r_ptr+

; ---- 2 -----        
        MPYM    *x_ptr-, *y_ptr-, AC0  
        MACM    *x_ptr, *y_ptr, AC0
        MPYMR   *SP(#n_inverse), AC0, AC0
        MOV     HI(AC0), *r_ptr+    

; ---- Pointer stuff ----                   
        ADD     #2, y_save
        MOV     Xx_save, XCDP
        MOV     y_save, x_ptr
        ADD     #1, x_ptr, y_ptr
                                                
        BCC REGION1_LOOP, TC1

; ---- 3 -----        
        MPYM    *x_ptr-, *CDP-, AC0
        MACM    *x_ptr-, *CDP-, AC0
        MACM    *x_ptr-, *CDP-, AC0
        
        MPYMR   *SP(#(n_inverse)), AC0, AC0
        
        MOV     HI(AC0), *r_ptr+
        
        ADD     #1, y_save
        MOV     Xx_save, XCDP

        MOV     Xy_save, Xx_ptr
        ADD     #1, x_ptr, y_ptr
        ADD     #2, mac_cnt

REGION1_LOOP:
        MOV     mac_cnt, CSR
        MOV     *SP(#n_inverse), T3

     || RPTBLOCAL endlocal1-1
                ADD     #2, y_save
    
                MPY     *x_ptr-, *CDP-, AC0 
             :: MPY     *y_ptr-, *CDP-, AC1
        
; ---- Main Dual MAC loop  ----   
             || RPTADD  CSR, #2
                        MAC     *x_ptr-, *CDP-, AC0 
                     :: MAC     *y_ptr-, *CDP-, AC1
        
; ---- Cleanup MAC ----
                MACM    *y_ptr-, *CDP, AC1
             || MOV     y_save, x_ptr
                MPYR    T3, AC0, AC0
        
; ---- Reload Pointers ----        
             || MOV     x_save, CDP
                AMAR    *y_save(#1), Xy_ptr

; ---- BIAS AC0 and AC1  ----
                MPYR    T3, AC1, AC1

; ---- Store ----    
             || MOV     HI(AC0), *r_ptr+
                MOV     HI(AC1), *r_ptr+ 
endlocal1:

; ---- Reload Pointers ----        
        MOV     Xy_orig, Xy_save
        MOV     x2_save, x_save

;
; Begin Loop for Region 2:                                      
;----------------------------------------------------------------

REGION2:
        MOV     ny, T3
        SUB     nx, T3
        MOV     T3, BRC0
    
        MOV     x_save, x_ptr
        MOV     y_save, y_ptr

        SUB     #3, nx, mac_cnt
        MOV     mac_cnt, CSR
        MOV     *SP(#n_inverse), T3

     || RPTBLOCAL localend2-1
        
; ---- Setup pointers ----
                ADD     #1, y_save

; ---- Preload AC0 ----
                MPYM    *x_ptr+, *y_ptr+, AC0
        
; ---- Main MAC loop  ---- 
;        MOV mac_cnt, CSR
             || RPT     CSR
                        MACM    *x_ptr+, *y_ptr+, AC0, AC0        
        
; ---- Cleanup ----
                MACM    *x_ptr+, *y_ptr+, AC0, AC0        
             || MOV     x_save, x_ptr
                MPYR    T3, AC0, AC0
        
; ---- Setup for subsequent passes through Region 2 ----     
             || AMOV    y_save, y_ptr

; ---- Store ----      
                MOV     HI(AC0), *r_ptr+
localend2:        

;
; Begin REGION3 loop:                                           
;----------------------------------------------------------------

REGION3:

        MOV     region1_and_3_loop_cnt, BRC0
        MOV     x_save, CDP
        MOV     y_save, x_ptr
        ADD     #1, x_ptr, y_ptr

        MOV     nx, mac_cnt
        SUB     #4, mac_cnt
        MOV     mac_cnt, CSR
        MOV     *SP(#n_inverse), T3

     || RPTBLOCAL localend3-1
                ADD     #2, y_save
; ---- Preload AC0 ----
                MPY     *x_ptr+, *CDP+, AC0 
             :: MPY     *y_ptr+, *CDP+, AC1
; ---- Main Dual MAC loop  ----   
             || RPTSUB  CSR, #2
                        MAC     *x_ptr+, *CDP+, AC0
                     :: MAC     *y_ptr+, *CDP+, AC1
; ---- Cleanup ----     
                MACM    *x_ptr, *CDP, AC0
; ---- Setup Pointers ----    
             || MOV     x_save, CDP
; ---- BIAS AC0 and AC1  ----
                MPYR    T3, AC0, AC0
             || ADD     #1, y_save, y_ptr
                MPYR    T3, AC1, AC1
; ---- Store ----    
             || MOV     HI(AC0), *r_ptr+
                MOV     HI(AC1), *r_ptr+ 
             || AMOV    y_save, x_ptr
localend3:        
;        }

;
; Calculate last correlation elements outside of loop       
;----------------------------------------------------------------
        BCC REGION3_FINAL, TC1

; ---- 3 -----
        MPYM    *x_ptr+, *CDP+, AC0
        MACM    *x_ptr+, *CDP+, AC0
        MACM    *x_ptr+, *CDP+, AC0

        MPYMR   *SP(#(n_inverse)), AC0, AC0
        
        MOV     HI(AC0), *r_ptr+
        
        ADD     #1, y_save
        MOV     x_save, CDP
        MOV     y_save, x_ptr
     
REGION3_FINAL:
; ---- 2 -----
        MPYM    *x_ptr+, *CDP+, AC0
        MACM    *x_ptr, *CDP-, AC0
        MPYMR   *SP(#(n_inverse)), AC0, AC0
        MOV     HI(AC0), *r_ptr+    

; ---- 1 -----
        MPYM    *x_ptr, *CDP, AC0
        MPYMR   *SP(#(n_inverse)), AC0, AC0
        MOV     HI(AC0), *r_ptr+    

; Check if overflow occurred, and setup return value
;----------------------------------------------------------------
; bug: original code put return value in AC0
; fix: put in oflag
        MOV     #0, oflag
        XCCPART overflow(AC0)
             || MOV     #1, oflag
        XCCPART overflow(AC1)
             || MOV     #1, oflag
        
;                
; Restore status regs to expected C-convention values as needed
; Restore any save-on-entry registers that are used
;----------------------------------------------------------------
;
; Deallocate the local frame and argument block
;----------------------------------------------------------------
        AADD    #+(ARG_BLK_SZ + FRAME_SZ), SP
        POPBOTH XAR7
     || BSET    ARMS
        POPBOTH XAR6
     || BCLR    FRCT
        POPBOTH XAR5
        POP     T2, T3
;
; Return to calling function
;----------------------------------------------------------------
        RET
;----------------------------------------------------------------
;End of file


cbrev.asm/      1362765892  0     0     0       9101      `
;/*
; * Copyright (C) 2013 Texas Instruments Incorporated - http://www.ti.com/ 
; * 
; * 
; *  Redistribution and use in source and binary forms, with or without 
; *  modification, are permitted provided that the following conditions 
; *  are met:
; *
; *    Redistributions of source code must retain the above copyright 
; *    notice, this list of conditions and the following disclaimer.
; *
; *    Redistributions in binary form must reproduce the above copyright
; *    notice, this list of conditions and the following disclaimer in the 
; *    documentation and/or other materials provided with the   
; *    distribution.
; *
; *    Neither the name of Texas Instruments Incorporated nor the names of
; *    its contributors may be used to endorse or promote products derived
; *    from this software without specific prior written permission.
; *
; *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
; *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
; *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
; *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
; *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
; *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
; *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
; *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
; *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
; *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
; *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
; *
;*/

;***********************************************************
; Version 3.00.00                                           
;***********************************************************
;*********************************************************************
; Function:    cbrev
; Processor:   C55xx
; Description: This function performs bit-reversal of complex data array x.
;              If x==y, in-place bit reversal is performed.
;
; Usage:    void cbrev (DATA *x, DATA *y, ushort n)
;
; Benchmarks:
;   Cycles:
;      x != y:  (2 * nx) + 33
;     nx =   8:  x=y:   79   x!=y:   49
;     nx =  16:  x=y:   98   x!=y:   65
;     nx =  32:  x=y:  124   x!=y:   97
;     nx =  64:  x=y:  198   x!=y:  161
;     nx = 128:  x=y:  277   x!=y:  289
;     nx = 256:  x=y:  512   x!=y:  545
;     nx = 512:  x=y:  880   x!=y: 1057
;     nx =1024:  x=y: 1739   x!=y: 2080
;   Code Size (in bytes):     214
;
; History:
;   Craig Leeds 05/25/2012: Set BK47 when using AR4 as circular buffer
;****************************************************************

		.mmregs  
		.cpl_on   
                .noremark  5684  ; BRC1 not modified by MMR within Repeat Blocks
        .global _cbrev   
	.text
_cbrev:

;//-----------------------------------------------------------------------------
;// Context Save
;//-----------------------------------------------------------------------------

        PSH     mmap(ST2_55)                ; preserve ST2 register (for ARMS and ARxLC)

;//-----------------------------------------------------------------------------
;// Initialize
;//-----------------------------------------------------------------------------

        BSET    AR1LC                         ; circular addressing for AR1
        .arms_off
        BCLR    ARMS                          ; reset ARMS bit
        
        MOV     T0, T1                        ; n in T1
        SFTL    T1, #1                        ; 2*n
        MOV     T1, mmap(BK03)                ; circular buffer size is 2*n 
        MOV     T1, mmap(BK47)                ; circular buffer size is 2*n 
        MOV     AR1, mmap(BSA01)              ; circular buffer offset 
;
;        Determine if in-place or off-place computation
;
        MOV     XAR1, AC0
        MOV     XAR0, AC1                     
        
        SUB     AC1, AC0                      ; compare input and output pointers 
        MOV     T0, HI(AC2)                   ; used for log2(N) computation
        
        MOV     #0, AR1                       ; output pointer (circular)
     || BCC     off_place, AC0 != #0          ; if x<>y, do off-place bit reversal

;//-----------------------------------------------------------------------------
;// In-place bit reversal
;//-----------------------------------------------------------------------------
in_place: 
        BSET    AR0LC                        ; circular addressing for AR0
        BSET    AR2LC                        ; circular addressing for AR2
        BSET    AR3LC                        ; circular addressing for AR3
        BSET    AR4LC                        ; circular addressing for AR4
        
        MOV     AR0, mmap(BSA23)             ; circular buffer offset 
        MOV     AR0, mmap(BSA45)             ; circular buffer offset
        MOV     AR0, mmap(BSA01)             ; circular buffer offset 

        MOV     #0, AR0                      ; output pointer (circular)
;
;    Initialize extended part of XARn
;
        MOV     XAR0,XAR2
        MOV     XAR0,XAR3
        MOV     XAR0,XAR4
;
;    Compute log2(N)
;
        EXP     AC2, T1                                ; Hi(AC2) = N
     || MOV     #14, AC2
        SUB     T1,AC2                                ; AC2 = log2(N)
;
;        Test if log2(N) is odd
;
        AND     #1, AC2, AC3
        BCC     log2n_odd, AC3 != #0        ; branch to log2(N) odd processing
;
;         process for log2(N) even
;        
;
;   Compute 2^[log2(N)/2]-1           
;                               
        SFTL    AC2, #-1                        ; log2(N)/2
        MOV     AC2, T1
        NEG     T1
     || MOV     T0, AC2
        SFTL    AC2, T1              ; 2^[log2(N)/2]                                
           
        SUB     #2, AC2, AC3
        MOV     AC3, mmap(BRC0)   ; 2^[log2(N)/2]-2 
            
        MOV     AC2, T0
     || SFTL    AC2, #1 
        MOV     AC2, T1             
        MOV     #1-1, AR1          ; inner loop counter

     || RPTBLOCAL evenOuterLoopEnd-1
               MOV     AR1, BRC1
               AMAR    *(AR0+T0B)
               AMAR    *(AR2+T1)
               AMOV    AR0, AR4
            || ADD     #1, AR1
               AMOV    AR2, AR3
            || RPTBLOCAL evenInnerLoopEnd-1
                        NOP_16                    ; avoid CPU_116 
                     || MOV     dbl(*AR4), AC0
                        MOV     dbl(*AR3), dbl(*(AR4+T1))
                        MOV     AC0, dbl(*(AR3+T0B))
evenInnerLoopEnd:
evenOuterLoopEnd:

        B        done  

log2n_odd:
;
;   Compute 2^[(log2(N)-1)/2]           
;    
        SUB     #1, AC2               ;  log2(N)-1          
        SFTL    AC2, #-1                        ; (log2(N)-1)/2
        MOV     AC2, T1
        ADD     #1, T1
        NEG     T1
    ||  MOV     T0, AC2
        SFTL    AC2, T1                                ;2^[(log2(N)-1)/2]
        
        SUB     #2, AC2, AC3
        MOV     AC3, mmap(BRC0) 
        SFTL    AC2, #1   
        MOV     AC2, T0
        SFTL    AC2, #1 
        MOV     AC2, T1             
            
        MOV     #2-1, AR1         ; inner loop counter
    ||  RPTBLOCAL  oddOuterLoopEnd-1
                MOV     AR1, BRC1
                AMAR    *(AR0+T0B)
                AMAR    *(AR0+T0B)
                AMAR    *(AR2+T1)
                AMOV    AR0, AR4
             || ADD     #2, AR1    ; next time, go thru inner loop 2 extra times
                AMOV    AR2, AR3
             || RPTBLOCAL oddInnerLoopEnd-1
                        NOP_16                    ; avoid CPU_116 
                     || MOV     dbl(*AR4),AC0 
                        MOV     dbl(*AR3),dbl(*(AR4+T0))
                        MOV     AC0,dbl(*(AR3+T0B))
oddInnerLoopEnd:
oddOuterLoopEnd:

        B        done  
         
        
;//-----------------------------------------------------------------------------
;// Off-place bit reversal
;//-----------------------------------------------------------------------------
off_place: 
        SUB     #1, T0, T1              ;
        MOV     T1, BRC0                ; BRC0 = n - 1                                                 
 
        RPTBLOCAL   NotOverlaidLoopEnd-1            
                MOV    dbl(*AR0+), AC0
                MOV    AC0, dbl(*(AR1+T0B))  

NotOverlaidLoopEnd:

;//-----------------------------------------------------------------------------
;// Context Restore
;//-----------------------------------------------------------------------------
done:
        POP     mmap(ST2_55)               ; restore ST2_55 register
        BSET    ARMS                       ; restore C environment 
     || RET                                ; return   

        .end     

 
cbrev32.asm/    1362765892  0     0     0       6674      `
;/*
; * Copyright (C) 2013 Texas Instruments Incorporated - http://www.ti.com/ 
; * 
; * 
; *  Redistribution and use in source and binary forms, with or without 
; *  modification, are permitted provided that the following conditions 
; *  are met:
; *
; *    Redistributions of source code must retain the above copyright 
; *    notice, this list of conditions and the following disclaimer.
; *
; *    Redistributions in binary form must reproduce the above copyright
; *    notice, this list of conditions and the following disclaimer in the 
; *    documentation and/or other materials provided with the   
; *    distribution.
; *
; *    Neither the name of Texas Instruments Incorporated nor the names of
; *    its contributors may be used to endorse or promote products derived
; *    from this software without specific prior written permission.
; *
; *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
; *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
; *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
; *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
; *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
; *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
; *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
; *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
; *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
; *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
; *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
; *
;*/

;***********************************************************
; Version 3.00.00                                           
;***********************************************************
;*********************************************************************
; Function:    cbrev32
; Processor:   C55xx
; Description: This function performs 32-bit bit-reversal of complex 
;                           data array x.
;              If x==y, in-place bit reversal is performed.
;
; Usage:    void cbrev32 (LDATA *x, LDATA *y, ushort nx)
;
; Limitations:
;   nx must be a power of 2 
;   nx >= 8
;
; Benchmarks:
;   Cycles:
;        x = y:   (9 * nx) + 43
;        x != y:  (4 * nx) + 30
;     nx =   8:  x=y:  115   x!=y:   62
;     nx =  16:  x=y:  187   x!=y:   94
;     nx =  32:  x=y:  331   x!=y:  158
;     nx =  64:  x=y:  619   x!=y:  286
;     nx = 128:  x=y: 1195   x!=y:  542
;     nx = 256:  x=y: 2347   x!=y: 1054
;     nx = 512:  x=y: 4651   x!=y: 2078
;   Code Size (in bytes):     116
;
; History:
;   Craig Leeds 05/25/2012:  optimized
;****************************************************************

                .mmregs  
                .cpl_on   

        .global _cbrev32   

        .text
_cbrev32:

;//-----------------------------------------------------------------------------
;// Context Save
;//-----------------------------------------------------------------------------
;//-----------------------------------------------------------------------------
;// Initialize
;//-----------------------------------------------------------------------------

        BSET    AR1LC                       ; circular addressing for AR1
        .arms_off
        BCLR    ARMS                        ; reset ARMS bit

        MOV     T0, T1                      ; n in T1
        SFTL    T1, #1                      ; 2*n
        SFTL    T1, #1                      ; 4*n
        MOV     T1, mmap(BK03)              ; circular buffer size is 4*n 
        MOV     AR1, mmap(BSA01)            ; circular buffer offset      
 
        MOV     T0, T1                      ; n in T1
        SUB     #1, T1
        MOV     T1, BRC0                    ; BRC0 = n - 1

        MOV     XAR1, AC0
        MOV     XAR0, AC1                   ; 
        SUB     AC1, AC0                    ; compare input and output pointers 
        MOV     #0, AR1                     ; output pointer (circular)

        BCC     off_place, AC0 != #0        ; if x<>y, do off-place bit reversal
     || SFTL    T0,#1

;//-----------------------------------------------------------------------------
;// In-place bit reversal
;//-----------------------------------------------------------------------------
in_place: 
        BSET    AR0LC                        ; circular addressing for AR0
        AMOV    #0, AR0
        AADD    #2, AR1                      ; Prime the Pump

        RPTBLOCAL OverlaidLoopEnd-1 
                MOV     dbl(*AR0+), AC0
             || ASUB    #2, AR1
                MOV     dbl(*AR0-), AC3      
             || AMOV    AR1, T1                ; should be in parallel but CCS1.00b crashes
                MOV     dbl(*AR1+), AC1
             || ASUB    AR0, T1                ; should be in parallel but CCS1.00b crashes
                MOV     dbl(*AR1-), AC2
                XCCPART T1 >= #0              ; swap only if AR3 < AR2 
                    || MOV   AC1, dbl(*AR0+)  ; otherwise they are swapped already
                XCCPART T1 >= #0
                    || MOV   AC2, dbl(*AR0+)
                XCCPART T1 >= #0
                    || MOV   AC0, dbl(*AR1+)
                XCCPART T1 >= #0
                    || MOV   AC3, dbl(*(AR1+T0B))
OverlaidLoopEnd:

        BCLR     AR0LC                         ; restore linear addressing for AR0
     || B        done  
        
;//-----------------------------------------------------------------------------
;// Off-place bit reversal
;//-----------------------------------------------------------------------------
off_place:                                                  
 
        MOV     dbl(*AR0+), AC0            ; Prime the Pump
     || RPTBLOCAL NotOverlaidLoopEnd-1            
                MOV     dbl(*AR0+), AC1
                MOV     AC0, dbl(*AR1+)
                MOV     AC1, dbl(*(AR1+T0B))  
                ASUB    #2, AR1
             || MOV     dbl(*AR0+), AC0    ; For next iteration
NotOverlaidLoopEnd:

;//-----------------------------------------------------------------------------
;// Context Restore
;//-----------------------------------------------------------------------------
done:
        BCLR    AR1LC                      ; restore linear addressing for AR1
        BSET    ARMS                       ; restore C environment
     || RET                                ; return   

        .end     


/0              1362765892  0     0     0       18271     `
;/*
; * Copyright (C) 2013 Texas Instruments Incorporated - http://www.ti.com/ 
; * 
; * 
; *  Redistribution and use in source and binary forms, with or without 
; *  modification, are permitted provided that the following conditions 
; *  are met:
; *
; *    Redistributions of source code must retain the above copyright 
; *    notice, this list of conditions and the following disclaimer.
; *
; *    Redistributions in binary form must reproduce the above copyright
; *    notice, this list of conditions and the following disclaimer in the 
; *    documentation and/or other materials provided with the   
; *    distribution.
; *
; *    Neither the name of Texas Instruments Incorporated nor the names of
; *    its contributors may be used to endorse or promote products derived
; *    from this software without specific prior written permission.
; *
; *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
; *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
; *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
; *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
; *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
; *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
; *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
; *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
; *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
; *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
; *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
; *
;*/

;***********************************************************
; Version 3.00.00                                           
;***********************************************************
; Processor:   C55xx
; Descripac1on: 32-bit radix-2 DIT complex FFT using normal input data
;    and bit-reversed twiddle table (length N/2, cosine/sine format)
;    First two stages are in radix-4.
;
; Usage:    void cfft32_NOSCALE (LDATA *x, ushort nx);
;
; Limitations:
;   nx must be a power of 2 between 8 and 1024
;
; Benchmarks:
;   Cycles:
;     nx =  8:    190
;     nx = 16:    454
;     nx = 32:   1086
;     nx = 64:   2563
;     nx =128:   5992
;     nx =256:  13786
;     nx =512:  31280
;   Code Size (in bytes):  
;     .text              301
;     .const:twiddle32  4096 (shared by cfft32, cifft32, unpack32, unpacki32)
;
; History:
;	- 07/17/2003	C. Iovescu changed the way the twiddle table is included
;       - 06/19/2012    Craig Leeds: optimized, removed .bss usage
;***********************************************************************

;-----------------------------------------------------------------------
; Arguments passed to _fft
; 	AR0       ->    fftdata pointer
; 	T0        ->    fft size
;-----------------------------------------------------------------------

;-----------------------------------------------------------------------
; Array declaraac1ons
;-----------------------------------------------------------------------

        .ref twiddle32

        .def _cfft32_NOSCALE     	; make funcac1on visible to other fnct
        .cpl_on
        .arms_off     				; enable assembler for arms mode
        .mmregs
        .noremark    5579, 5573, 5684
        
;-----------------------------------------------------------------------  
; Stack frame
;-----------------------------------------------------------------------
RET_ADDR_SZ       .set 1            ;return address
REG_SAVE_SZ       .set 5            ;save-on-entry registers saved (T3, T2, AR5, AR6, AR7)
FRAME_SZ          .set 4            ;local variables
ARG_BLK_SZ        .set 0            ;argument block

PARAM_OFFSET      .set ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ + RET_ADDR_SZ

;-----------------------------------------------------------------------
; Local variables
;-----------------------------------------------------------------------            
       .asg    0, tempmem           ; (long) must be aligned on even
       .asg    2, data_pac0
       .asg    3, data_sz

;-----------------------------------------------------------------------
; Temp data
;-----------------------------------------------------------------------
      
        .text           
_cfft32_NOSCALE:

;-----------------------------------------------------------------------
; Save any save-on-entry registers that are used
;-----------------------------------------------------------------------
        PSH     T3, T2
     || BSET    #FRCT, ST1_55          
        PSHBOTH XAR5
     || BCLR    #ARMS, ST2_55          
        PSHBOTH XAR6
     || BSET    M40
        PSHBOTH XAR7

;-----------------------------------------------------------------------
; Allocate the local frame and argument block
;-----------------------------------------------------------------------
        AADD    #-(ARG_BLK_SZ + FRAME_SZ), SP

;-----------------------------------------------------------------------
; Save entry values for later
;-----------------------------------------------------------------------
        AMAR    *AR0(T0), XAR1                       ; b: AR1 = #(fftdata+4*FFT_SIZE/4)
        AMAR    *AR1(T0) ,XAR2                       ; c: AR2 = #(fftdata+4*FFT_SIZE/2)
        AMAR    *AR2(T0) ,XAR3                       ; d: AR3 = #(fftdata+4*3*FFT_SIZE/4)
                
        MOV     T0, *SP(data_sz)   ;

        SFTS    T0, #-1                              ;T0 = FFT_SIZE/4
        SFTS    T0, #-1        
        SUB     #1, T0
        MOV     T0,BRC0
                
        MOV     XSP, XAR6
 .if tempmem != 0
        ADD     #tempmem, AR6                        ; AR6 = &tempmem (on stack)
 .endif
                
        MOV     AR0, *SP(data_pac0) ; 

;-----------------------------------------------------------------------
; FFT implementaac1on
;
; The FFT is implemented in three different steps:
;
;  1) - a radix-4 stage with twiddle factors only equal to -1, 0 and 1
;  2) - a group of log2(FFT_SIZE)-3 radix-2 stages
;  3) - on out-of-place bit-reversal
;
;  No need to implement the last stage in a different way
;  to the other stages.        
;-----------------------------------------------------------------------
; Modificaac1on of status registers          
                                           
;-----------------------------------------------------------------------
; First two stages computed as one radix-4 stage
;-----------------------------------------------------------------------      
        ; First in-place radix-4 stage
        ;
        ;        ----------
        ; a -----|   R    |----- a'
        ;            A
        ; b -----|   D    |----- b'
        ;            I
        ; c -----|   X    |----- c'
        ;  
        ; d -----|   4    |----- d'
        ;        ---------
        ;
        ; ar' =  (ar + cr) + (br + dr)
        ; ai' =  (ai + ci) + (bi + di) 
        ;
        ; br' =  (ar + cr) - (br + dr)
        ; bi' =  (ai + ci) - (bi + di)
        ;
        ; cr' =  (ar - cr) + (bi - di)
        ; ci' =  (ai - ci) - (br - dr)
        ;
        ; dr' =  (ar - cr) - (bi - di)
        ; di' =  (ai - ci) + (br - dr)
        ;        
        ; AR6  -> tempmem
        ;
        ; AR0-> a
        ; AR1-> b
        ; AR2-> c
        ; AR3-> d
        ;
        ; --------------------------------------------------------------        
       
     || RPTBLOCAL stage12-1
;-----------------------------------------------------------------------
; Benchmark: 20 stages for stage1_2 loop
;-----------------------------------------------------------------------           
                ;Instruction                         AC0        AC1        AC2        AC3        AR0        AR1        AR2        AR3            
                MOV     dbl(*AR0), AC0              ;AR                                ar        br        cr        dr
                SUB     dbl(*AR2),AC0,AC3           ;                        ar-cr                                
                ADD     dbl(*AR2+),AC0,AC1          ;        ar+cr                                ci        
                MOV     dbl(*AR1),AC0               ;br                                                        
                SUB     AC0,dbl(*AR3+),AC2          ;                dr-br                                di
                MOV     AC2,dbl(*AR6)               ;AR6->dr-br                                                                
             || ADD     AC0<<#1,AC2                 ;                dr+br                                        
                ADD     AC2,AC1                     ;ar+cr+dr+br                                                
             || MOV     dbl(*AR3-),AC0              ;di                                                        dr 
                MOV     AC1,dbl(*AR0+)              ;                                ai                        
             || SUB     AC2<<#1,AC1                 ;ar+cr-(dr+br)                                                
                MOV     AC1, dbl(*AR1+)             ;                                        bi                 
                ADD     dbl(*AR1),AC0,AC1           ;        bi+di                                                 
                SUB     AC0, dbl(*AR1), AC2         ;                bi-di                                        
                ADD     AC2, AC3                    ;                        ar-cr+bi-di                                
             || MOV     dbl(*AR2-),AC0              ;ci                                                cr        
                MOV     AC3,dbl(*AR2+)              ;                                                ci        
             || SUB     AC2<<#1,AC3                 ;                        ar-cr-(bi-di)                                
                MOV     AC3, dbl(*AR3+)             ;                                                        di 
             || SUB     AC0, dbl(*AR0), AC3         ;                        ai-ci 
                ADD     dbl(*AR0),AC0               ;ai+ci
                ADD     AC1, AC0                    ;ai+ci+di+bi                                                        
                MOV     dbl(*AR6),AC2               ;                dr-br                                        
                MOV     AC0, dbl(*AR0+)             ;                                arn                        
             || SUB     AC1<<#1,AC0                 ;ai+ci-(di+bi)                                                        
                MOV     AC0, dbl(*AR1+)             ;                                        brn                
             || ADD     AC2,AC3                     ;                        ai-ci+dr-br                                
                MOV     AC3,dbl(*AR2+)              ;                                                crn        
             || SUB     AC2<<#1,AC3                 ;                        ai-ci-(dr-br)                                
                MOV     AC3,dbl(*AR3+)              ;                                                        drn
stage12:
;-----------------------------------------------------------------------
; End of stage 1 and 2
;-----------------------------------------------------------------------            
                
;-----------------------------------------------------------------------
; radix-2 stages (stages 3->log2(FFT_SIZE) )  
; register usage
; ar0->Pr, ar1->Qr, ar3->twiddle
; ar4=Re distance of butterfly
; ar6=group count, t1=butterfly count, ar5= stage count  
;-----------------------------------------------------------------------
        ; main iniac1alizaac1on                 

        ; modify ST2 to select linear or circular addressing modes
        OR      #0x3, mmap(ST2_55)              ; circular AR0LC,AR1LC        
        MOV     *SP(data_pac0), AR1             ; AR1 = #fftdata  

        ; circular buffer starac1ng addresses                            
        MOV     AR1, mmap(BSA01)                ; circular buffer start address
               
        ; circular buffer sizes 
        MPYMK   *SP(data_sz),#2,AC0             ; because FRCT==1, it actually x4
        MOV     AC0, mmap(BK03)                 ; BK03 = (4*FFT_SIZE-4), ar0-ar3
        MOV     *SP(data_sz), T2
        SFTS    T2,#-1                          ; T2 = FFT_SIZE/2
        MOV     T2,AR4                          ; AR4 = FFT_SIZE/2(Re distance between p q)
        SFTS    T2,#-1
     || MOV     #4, AR6                         ; AR6 = group    
        SFTS    T2,#-1                          ; T2 = FFT_SIZE/8
        BCC     end_benchmark, T2==#0

        MOV     T2, T1                          ; T1 = number of butterfly,
        MOV     T2, AR5                         ; AR5 = stage                                                                               
        AMOV    #twiddle32, XAR3                ; AR3->twiddle          

        MOV     #2, T0                  ; moving from real->imag
        MOV     #-2, T2                 ; restoring cdp, and imag->real               
                        
stage:  ; begining of a new stage
        ; stage initialization
        
        ; 1 - loop counter updates     
        SFTS    AR5, #-1                 ; shift right stage count
     || MOV     #0, AR0                
        MOV     XAR3, XCDP
        ADD     #1, AR4, AR1             ;AR1->QR_LOW
        ADD     #2, AR1, AR2             ;AR2->QI_LOW
                   
        ; butterfly counter update                                      
        SUB     #1, T1, T3        
        MOV     T3, BRC1                 ;butterflies loop count

        ; group counter update
        SUB     #1, AR6, T3     
        MOV     T3, BRC0              
               
        RPTBLOCAL group-1
;-----------------------------------------------------------------------
; Benchmark: 12 cycles for the butterfly loop
;-----------------------------------------------------------------------
               RPTBLOCAL BFly-1                                                                 ;             (AR1,CDP)
                        MPY     uns(*AR1), *(CDP+T0), AC0       ; AC0  = yrl*crh (1,0)
                     :: MPY     uns(*AR1(T0)), *(CDP+T0), AC1   ; AC1  = yil*crh (3,0)

                        MAC     uns(*AR1(T0)), *CDP+, AC0       ; AC0 += yil*cih (3,2)
                     :: MAS     uns(*AR1+), *CDP+, AC1          ; AC1 -= yrl*cih (1,2)
                     || SWAP    T0, T2                          ; T0=-2

                        MAC     *AR1, uns(*(CDP+T0)), AC0       ; AC0 += yih*cil (2,3)
                     :: MAS     *AR1(T0), uns(*(CDP+T0)), AC1   ; AC1 -= yrh*cil (0,3)

                        MAC    *AR1(T0), uns(*CDP-), AC0        ; AC0 += yrh*crl (0,1)
                     :: MAC    *(AR1+T0), uns(*CDP-), AC1       ; AC1 += yih*crl (2,1)
                     || SWAP    T0, T2                          ; T0=2

                        MAC     *AR1, *(CDP+T0), AC0>>#16       ; AC0 += yrh*crh (0,0)
                     :: MAC     *AR1(T0), *(CDP+T0), AC1>>#16   ; AC1 += yih*crh (2,0)

                        MAC     *AR1(T0), *(CDP+T0), AC0        ; AC0 += yih*cih (2,2)
                     :: MAS     *AR1, *(CDP+T0), AC1            ; AC1 -= yrh*cih (0,2)

                        ADD     dbl(*AR0), AC0,AC2
                        MAR     *+CDP(-4)
                        MOV     AC2,dbl(*AR0)                   ; new xr=ac0+xr  (0,4)
                     || SUB     AC0,dbl(*AR0+),AC3              ;                (0,4)

                        MOV     AC3, dbl(*AR1+)                 ; new yr=xr-ac0  (2,4)
                     || SUB     AC1,dbl(*AR0), AC2

                        MOV     AC2, dbl(*AR1+)                 ; new yi=xi-ac1  (2,4)
                     || ADD     dbl(*AR0),AC1,AC3               ;                (4,4)

                        MOV     AC3, dbl(*AR0+)                 ; new xi=xi+ac1
                     || AADD    #1, AR1                         ;                (4,4)                             
BFly:
                                                                                                                                                                                                                                                                                                                                                                                                                                                              
                ADD     AR4, AR0                                ;jump to next group
                ADD     AR4, AR1
                AMAR    *+CDP(4)                                ;CDP+4
group:        
                
        SFTS    AR6,#1                                      ;group<<1
        SFTS    T1,#-1                                      ;butterfly>>1
        SFTS    AR4,#-1                                     ;P Q distance>>1
     || BCC     stage,AR5 != #0              
;-----------------------------------------------------------------------
; End of radix-2 stage 
;-----------------------------------------------------------------------
                                
end_benchmark:

;-----------------------------------------------------------------------
; De-allocate the local frame and argument block
;-----------------------------------------------------------------------
        AADD    #+(ARG_BLK_SZ + FRAME_SZ), SP

        ;Context restore 
        POPBOTH XAR7
     || BCLR    AR0LC
        POPBOTH XAR6
     || BCLR    AR1LC
        POPBOTH XAR5
     || BSET    ARMS
        POP     T3, T2
     || BCLR    FRCT
        RET 
     || BCLR    M40
        .end         
        

/20             1362765892  0     0     0       22014     `
;/*
; * Copyright (C) 2013 Texas Instruments Incorporated - http://www.ti.com/ 
; * 
; * 
; *  Redistribution and use in source and binary forms, with or without 
; *  modification, are permitted provided that the following conditions 
; *  are met:
; *
; *    Redistributions of source code must retain the above copyright 
; *    notice, this list of conditions and the following disclaimer.
; *
; *    Redistributions in binary form must reproduce the above copyright
; *    notice, this list of conditions and the following disclaimer in the 
; *    documentation and/or other materials provided with the   
; *    distribution.
; *
; *    Neither the name of Texas Instruments Incorporated nor the names of
; *    its contributors may be used to endorse or promote products derived
; *    from this software without specific prior written permission.
; *
; *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
; *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
; *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
; *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
; *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
; *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
; *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
; *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
; *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
; *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
; *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
; *
;*/

;***********************************************************
; Version 3.00.00                                           
;***********************************************************
; Processor:   C55xx
; Description: 32-bit radix-2 DIT complex FFT using normal input data
;    and bit-reversed twiddle table (length N/2, cosine/sine format)
;    First two stages are separately implmented for MIPS optimization.
;
; Usage:    void cfft32_SCALE (LDATA *x, ushort nx);
;
; Limitations:
;   nx must be a power of 2 between 8 and 1024
;
; Benchmarks:
;   Cycles:
;     nx =  8:    250
;     nx = 16:    575
;     nx = 32:   1349
;     nx = 64:   3111
;     nx =128:   7159
;     nx =256:  16236
;     nx =512:  36396
;   Code Size (in bytes):  
;     .text              496
;     .const:twiddle32  4096 (shared by cfft32, cifft32, unpack32, unpacki32)
;
; History:
;    Original: 08/16/2002 ZhengTing He
;    08/19/2002 Li Yuan
;        - Changed || to :: in several dual MAC instructions
;    06/19/2012 Craig Leeds 
;       - optimized
;****************************************************************

;-----------------------------------------------------------------------
; Arguments passed to _fft
;
; AR0       ->    fftdata pointer
; T0        ->    fft size
;
;-----------------------------------------------------------------------

;//-----------------------------------------------------------------------------
;// Array declarations
;//-----------------------------------------------------------------------------


        
        .ref twiddle32
        .def _cfft32_SCALE     		; make function visible to other fnct
        .cpl_on
        .arms_off     			; enable assembler for arms mode
        .mmregs
        .noremark    5579, 5573, 5684
  
; Stack frame
; -----------
RET_ADDR_SZ       .set 1            ;return address
REG_SAVE_SZ       .set 5            ;save-on-entry registers saved (T3, T2, AR5, AR6, AR7)
FRAME_SZ          .set 2            ;local variables
ARG_BLK_SZ        .set 0            ;argument block

PARAM_OFFSET      .set ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ + RET_ADDR_SZ


; Local variables
; --------------             
       .asg    0, data_ptr
       .asg    1, data_sz
      
;----------------------------------------------------------------
; Conditional compile
;----------------------------------------------------------------
SCALED        .set        1                ; SCALED = 0 - not scaled version
                                           ; SCALED = 1 - scaled version
                                                
        .text           
_cfft32_SCALE:

;----------------------------------------------------------------
; Save any save-on-entry registers that are used
;----------------------------------------------------------------

        PSH     T3, T2
     || BSET    #FRCT, ST1_55          
        PSHBOTH XAR5
     || BCLR    #ARMS, ST2_55          
        PSHBOTH XAR6
     || BSET    M40             
        PSHBOTH XAR7

;----------------------------------------------------------------
; Allocate the local frame and argument block
;----------------------------------------------------------------
        AADD    #-(ARG_BLK_SZ + FRAME_SZ), SP

;----------------------------------------------------------------
; Save entry values for later
;----------------------------------------------------------------

        MOV     AR0, *SP(data_ptr) ; 
        MOV     T0, *SP(data_sz)   ;

;-----------------------------------------------------------------------
; FFT implementation
;
; The FFT is implemented in 5 different steps:
;
;  1) - a radix-2 stage without any multiplications.
;  2) - a radix-2 stage with two groups, only the 2nd group has
;       multiplications with 0x7FFFFFFH and 0x00000000
;  3) - a group of log2(FFT_SIZE)-3 radix-2 stages
;  4) - a radix-2 stage without scaling.
;  5) - on out-of-place bit-reversal
;-----------------------------------------------------------------------
        
;-----------------------------------------------------------------------
; Modification of status registers
;-----------------------------------------------------------------------          
                     
              ; Define CSR for scaling loop
        SUB     #1, T0, T1                          
        MOV     T1, BRC0                               ; BRC0 = fftsize - 1
        AMAR    *AR0,XAR1
        AMAR    *AR0,XAR2

;-----------------------------------------------------------------------
; Scaling loop: Data scaled by 2 before first stage 
;-----------------------------------------------------------------------       
        MOV     dbl(*AR2+), AC0                         ; (Prime the Pump)
     || RPTBLOCAL scaling-1
                MOV     dbl(*AR2+), AC1
             || SFTS    AC0,#-1 
                SFTS    AC1,#-1     
             || MOV     AC0, dbl(*AR1+)
                MOV     AC1, dbl(*AR1+)
             || MOV     dbl(*AR2+), AC0                 ; (for next iteration)
scaling:

;-----------------------------------------------------------------------
; Radix-2 stage 1
;-----------------------------------------------------------------------                
                                                        ; AR0->fft_data       (a)
        AMAR    *AR0(T0),XAR1                           ; AR1->fft_data+1*n2  (b)
        AMAR    *AR1(T0),XAR2                           ; AR2->fft_data+2*n2  (c)
        AMAR    *AR2(T0),XAR3                           ; AR3->fft_data+3*n2  (d)
        MOV     XAR2,XAR7

        SFTS    T0, #-1                                 ; T0=fft-size/2
        SUB     #1, T0, T1                              ; T1=fft_size/2-1
        MOV     T1, BRC0
        AMAR    *AR0, XAR4

;-----------------------------------------------------------------------
; Benchmark: 9 cycles for this loop                
;-----------------------------------------------------------------------
        MOV     dbl(*AR4+),AC0                          ; (Prime the Pump)
     || RPTBLOCAL stage1-1
                ADD     dbl(*AR7),AC0,AC1               ; AC1=AR+CR
                SUB     dbl(*AR7+),AC0                  ; AC0=AR-CR
                MOV     dbl(*AR4+),AC2
            || SFTS     AC1,#-1
                ADD     dbl(*AR7),AC2,AC3               ; AC3=AI+CI        
                SUB     dbl(*AR7-),AC2                  ; AC2=AI-CI        
                SFTS    AC0,#-1
             || MOV     AC1,dbl(*AR0+)                  ;(AR+CR)>>1->AR
                SFTS    AC2,#-1
             || MOV     AC0,dbl(*AR7+)                  ;(AR-CR)>>1->CR
                SFTS    AC3,#-1
             || MOV     AC2,dbl(*AR7+)                  ;(AI-CI)>>1->CI
                MOV     AC3,dbl(*AR0+)                  ;(AI+CI)>>1->AI
             || MOV     dbl(*AR4+),AC0                  ; (for next iteration)
stage1:        
        

;-----------------------------------------------------------------------
; Radix-2 stage2
;-----------------------------------------------------------------------
        MOV     *SP(data_ptr), AR0
     || SFTS    T0, #-1
        SUB     #1, T0, T1                              ;T0=fft_size/4
        MOV     T1, BRC0                                ;T1=fft_size/4-1
        AMAR    *AR0, XAR4

;-----------------------------------------------------------------------
; Benchmark: 10 cycles for group1
;-----------------------------------------------------------------------
        MOV     dbl(*AR4+),AC0                          ; (Prime the Pump)
     || RPTBLOCAL group1-1
                ADD     dbl(*AR1),AC0,AC1               ; AC1=AR+BR
                SUB     dbl(*AR1+),AC0                  ; AC0=AR-BR
             || SFTS    AC1,#-1
                MOV     dbl(*AR4+),AC2
                ADD     dbl(*AR1),AC2,AC3               ; AC3=AI+BI
                SUB     dbl(*AR1-),AC2                  ; AC2=AI-BI
             || SFTS    AC0,#-1
                MOV     AC1,dbl(*AR0+)                  ; AR+BR->AR
             || SFTS    AC2,#-1
                MOV     AC0,dbl(*AR1+)                  ; AR-BR->BR
             || SFTS    AC3,#-1
                MOV     AC2,dbl(*AR1+)                  ; AI-BI->BI
                MOV     AC3,dbl(*AR0+)                  ; AI+BI->AI
             || MOV     dbl(*AR4+),AC0                  ; (for next iteration)
group1: 


;-----------------------------------------------------------------------
; Benchmark: 11 cycles for group2        
;-----------------------------------------------------------------------        
        MOV     T1,BRC0
        AMOV    #twiddle32, XCDP
        AMAR    *AR3(#3), XAR4                         ; AR4->DI_LOW
        MOV     #3, T1
        AMAR    *AR3+                          ;                         AR3->DR_LOW

     || RPTBLOCAL group2-1
                MPY     uns(*AR3-),*CDP+,AC0           ;DR_LOW * 7FFF            AR3->DR_HI    CDP->FFFF
             :: MPY     uns(*AR4-),*CDP+,AC1           ;DI_LOW * 7FFF            AR4->DI_HI  
                MAC     *AR3,uns(*CDP-),AC0            ;DR_HI*FFFF+DR_LOW*7FFF,  AR3->DR_HI    CDP->7FFF
             :: MAC     *AR4,uns(*CDP-),AC1            ;DI_HI*FFFF+DI_LOW*7FFF,  AR4->DI_HI        
                MAC     *AR3,*CDP,AC0>>#16             ;DR_HI*7FFF+AC0>>16       AR3->DR_HI    CDP_>7FFF
             :: MAC     *AR4,*CDP,AC1>>#16             ;DI_HI*7FFF+AC1>>16       AR4->DI_HI    CDP_>7FFF                                
                SUB     AC1,dbl(*AR2),AC2              ;AC2=CR-AC1
             || ADD     #5, AR4                        ;                         AR4->DI(next)
                ADD     dbl(*AR2+),AC1                 ;AC1=CR+AC1               AR2->CI
                SUB     AC0,dbl(*AR2),AC3              ;AC3=CI-AC0                        
             || SFTS    AC1,#-1
                ADD     dbl(*AR2-),AC0                 ;AC0=CI+AC0               AR2->CR
             || SFTS    AC3,#-1
                MOV     AC1,dbl(*AR2+)                 ;AC1->CR                  AR2->CI
             || SFTS    AC2,#-1        
                MOV     AC3,dbl(*AR2+)                 ;AC3->CI                  AR2->CR(next)
             || SFTS    AC0,#-1
                MOV     AC2,dbl(*AR3+)                 ;AC2->DR                  AR3->DI
                MOV     AC0,dbl(*(AR3+T1))             ;AC0->DI                  AR3->DR(next)
group2:        

;-----------------------------------------------------------------------
; End of stage 1 and 2
;-----------------------------------------------------------------------                 
        SFTS    T0, #-1
        BCC     end_benchmark, T0==#0
                                                                                                                                                                                                                                                             
;-----------------------------------------------------------------------
; radix-2 stages (stages 3->log2(FFT_SIZE) )  
;         register usage
;         AR0->Pr, AR1->Qr, AR3->twiddle
;         AR4=Re distance of butterfly
;         AR6=group count, t1=butterfly count, AR5= stage count  
;-----------------------------------------------------------------------
        ; main initialization                
                
        ; modify ST2 to select linear or circular addressing modes
        OR       #0x3 , mmap(ST2_55)                ; circular AR0,AR1   
        MOV      *SP(data_ptr), AR1                ; AR1 = #fftdata  

        ; circular buffer starting addresses                            
        MOV     AR1, mmap(BSA01)                ; circular buffer start address
               
        ; circular buffer sizes 
        MPYMK   *SP(data_sz),#2,AC0        ; because FRCT==1, it actually x4
        MOV     AC0, mmap(BK03)                ; bk03 = (4*FFT_SIZE-4), AR0-AR3
        
        
        MOV     *SP(data_sz), T2
        SFTS    T2, #-1                                        ; T2 = FFT_SIZE/2
     || MOV     #4, AR6                                        ; AR6 = group    
        MOV     T2, AR4                                    ; AR4 = FFT_SIZE/2(Re distance between p q)
        
        MOV     T0, T1                                        ; T1 = FFT_SIZE/8, nbfly
            
        SFTS    T0,#-1                                        ; T0=size/16
     || MOV     #-2, T2
        MOV     T0, AR5                                        ; AR5 is stage count
        MOV     #2, T0
        AMOV    #twiddle32, XAR3
        BCC     last_stage, AR5==#0                                                                                

;-----------------------------------------------------------------------
; Beginning of the stage loop
;         stage initialization
;-----------------------------------------------------------------------
stage:  ; stage loop counter updates     
        SFTS    AR5,#-1                            ; shift right stage count  

        MOV     #0,AR0                
     || MOV     AR3, CDP
        ADD     #1,AR4,AR1                                ;AR1->QR_LOW
                                   
        ; butterfly counter update                                      
        SUB     #1,T1,T3        
        MOV     T3, BRC1        

        ; group counter update
        SUB     #1,AR6,T3     
        MOV     T3, BRC0              
                     
        RPTBLOCAL group-1
;-----------------------------------------------------------------------
; Benchmark: 15 cycles for butterfly loop
;-----------------------------------------------------------------------
                RPTBLOCAL BFly-1                                                                 ;             (AR1,CDP)
                        MPY     uns(*AR1), *(CDP+T0), AC0       ; AC0  = yrl*crh (1,0)
                     :: MPY     uns(*AR1(T0)), *(CDP+T0), AC1   ; AC1  = yil*crh (3,0)

                        MAC     uns(*AR1(T0)), *CDP+, AC0       ; AC0 += yil*cih (3,2)
                     :: MAS     uns(*AR1+), *CDP+, AC1          ; AC1 -= yrl*cih (1,2)
                     || SWAP    T0, T2                          ; T0=-2

                        MAC     *AR1, uns(*(CDP+T0)), AC0       ; AC0 += yih*cil (2,3)
                     :: MAS     *AR1(T0), uns(*(CDP+T0)), AC1   ; AC1 -= yrh*cil (0,3)

                        MAC     *AR1(T0), uns(*CDP-), AC0       ; AC0 += yrh*crl (0,1)
                     :: MAC     *(AR1+T0), uns(*CDP-), AC1      ; AC1 += yih*crl (2,1)
                     || SWAP    T0, T2                          ; T0=2

                        MAC     *AR1, *(CDP+T0), AC0>>#16       ; AC0 += yrh*crh (0,0)
                     :: MAC     *AR1(T0), *(CDP+T0), AC1>>#16   ; AC1 += yih*crh (2,0)

                        MAC     *AR1(T0), *(CDP+T0), AC0        ; AC0 += yih*cih (2,2)
                     :: MAS     *AR1, *(CDP+T0), AC1            ; AC1 -= yrh*cih (0,2)        
                
                        ADD     dbl(*AR0), AC0,AC2        
                        SFTS    AC2, #-1
                     || MAR     *CDP-    
                        MOV     AC2,dbl(*AR0)                   ; new xr=AC0+xr  (0,4)
                     || SUB     AC0,dbl(*AR0+),AC3              ;                (0,4)
                        SFTS    AC3, #-1
                     || MAR     *CDP-
                        MOV     AC3, dbl(*AR1+)                 ; new yr=xr-AC0  (2,4)
                     || SUB     AC1,dbl(*AR0), AC2
                        SFTS    AC2, #-1
                     || MAR     *CDP-   
                        MOV     AC2, dbl(*AR1+)                 ; new yi=xi-AC1  (2,4)
                     || ADD     dbl(*AR0),AC1,AC3               ;                (4,4)
                        SFTS    AC3, #-1
                     || MAR     *CDP-   
                        MOV     AC3, dbl(*AR0+)                 ; new xi=xi+AC1
                     || AADD    #1, AR1                         ;                (4,4) 
BFly:
                ADD     AR4, AR0                                ;jump to next group
                ADD     AR4, AR1
                AMAR    *+CDP(4)                                ;CDP+4
group:
                
        SFTS    AR6, #1                                        ;group<<1
        SFTS    T1, #-1                                        ;butterfly>>1
        SFTS    AR4, #-1                                       ;P Q distance>>1
     || BCC     stage, AR5 != #0
;-----------------------------------------------------------------------
; END radix-2 stages (stages 3->log2(FFT_SIZE) )  
;-----------------------------------------------------------------------

;-----------------------------------------------------------------------
; Last stage
;-----------------------------------------------------------------------                
last_stage:
        ; stage initialization
        MOV     #0, AR0                 
        MOV     AR3, CDP                                  
        MOV     #5, AR1                                 ;AR1->QR_LOW
        
        ; group counter update
        SUB     #1, AR6, T3    
        MOV     T3, BRC0              
        MOV     #6, T1
             
     || RPTBLOCAL lgroup-1                                
                MPY     uns(*AR1), *(CDP+T0), AC0       ; AC0  = yrl*crh (1,0)
             :: MPY     uns(*AR1(T0)), *(CDP+T0), AC1   ; AC1  = yil*crh (3,0)

                MAC     uns(*AR1(T0)), *CDP+, AC0       ; AC0 += yil*cih (3,2)
             :: MAS     uns(*AR1+), *CDP+, AC1          ; AC1 -= yrl*cih (1,2)
             || SWAP    T0, T2                          ; T0=-2

                MAC     *AR1, uns(*(CDP+T0)), AC0       ; AC0 += yih*cil (2,3)
             :: MAS     *AR1(T0), uns(*(CDP+T0)), AC1   ; AC1 -= yrh*cil (0,3)

                MAC    *AR1(T0), uns(*CDP-), AC0        ; AC0 += yrh*crl (0,1)
             :: MAC    *(AR1+T0), uns(*CDP-), AC1       ; AC1 += yih*crl (2,1)
             || SWAP    T0, T2                          ; T0=2

                MAC     *AR1, *(CDP+T0), AC0>>#16       ; AC0 += yrh*crh (0,0)
             :: MAC     *AR1(T0), *(CDP+T0), AC1>>#16   ; AC1 += yih*crh (2,0)

                MAC     *AR1(T0), *(CDP+T0), AC0        ; AC0 += yih*cih (2,2)
             :: MAS     *AR1, *(CDP+T0), AC1            ; AC1 -= yrh*cih (0,2)

                ADD     dbl(*AR0), AC0,AC2
                MOV     AC2,dbl(*AR0)                   ; new xr=AC0+xr  (0,4)
             || SUB     AC0,dbl(*AR0+),AC3              ;                (0,4)

                MOV     AC3, dbl(*AR1+)                 ; new yr=xr-AC0  (2,4)
             || SUB     AC1,dbl(*AR0), AC2

                MOV     AC2, dbl(*AR1+)                 ; new yi=xi-AC1  (2,4)
             || ADD     dbl(*AR0),AC1,AC3               ;                (4,4)

                MOV     AC3, dbl(*(AR0+T1))             ; new xi=xi+AC1 (and jump to next group)
             || AADD    #5, AR1                         ;                (4,4)
lgroup:        
;-----------------------------------------------------------------------
; END last stage
;-----------------------------------------------------------------------
                                                
end_benchmark:
;-----------------------------------------------------------------------
; Allocate the local frame and argument block
;----------------------------------------------------------------
        AADD    #+(ARG_BLK_SZ + FRAME_SZ), SP

;Context restore 
        POPBOTH XAR7
     || BCLR    AR0LC
        POPBOTH XAR6
     || BCLR    AR1LC
        POPBOTH XAR5
     || BSET    #ARMS, ST2_55          
        POP     T3, T2
     || BCLR    #FRCT, ST1_55          
        RET 
     || BCLR    M40             
                .end         
        
/38             1362765892  0     0     0       18128     `
;/*
; * Copyright (C) 2013 Texas Instruments Incorporated - http://www.ti.com/ 
; * 
; * 
; *  Redistribution and use in source and binary forms, with or without 
; *  modification, are permitted provided that the following conditions 
; *  are met:
; *
; *    Redistributions of source code must retain the above copyright 
; *    notice, this list of conditions and the following disclaimer.
; *
; *    Redistributions in binary form must reproduce the above copyright
; *    notice, this list of conditions and the following disclaimer in the 
; *    documentation and/or other materials provided with the   
; *    distribution.
; *
; *    Neither the name of Texas Instruments Incorporated nor the names of
; *    its contributors may be used to endorse or promote products derived
; *    from this software without specific prior written permission.
; *
; *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
; *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
; *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
; *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
; *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
; *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
; *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
; *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
; *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
; *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
; *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
; *
;*/

;***********************************************************
; Version 3.00.00                                           
;***********************************************************
; Processor:   C55xx
; Description: Radix-2 DIT complex FFT using normal input data
;    and bit-reversed twiddle table (length N/2, cosine/sine format)
;    First two stages are in radix-4.
; Usage:    void cfft_NOSCALE (DATA *x, ushort nx);
;
; Limitations:
;   nx must be a power of 2 between 8 and 1024
;
; Benchmarks:
;   Cycles:
;     nx =  16:    234
;     nx =  32:    463
;     nx =  64:    980
;     nx = 128:   2153
;     nx = 256:   4798
;     nx = 512:  10707
;     nx =1024:  23784
;   Code Size (in bytes):  
;     .text            329
;     .const:twiddle  2048 (shared by cfft, cifft, unpack, unpacki)
;
; History:
; 	- 07/18/2002	Sira fixed the bug in the kernal.
;	- 07/17/2003	C. Iovescu changed the way the twiddle table is included
;       - 06/17/2012    Craig Leeds: optimized housekeeping ; removed .bss;
;                                    SATD set
;****************************************************************

;-----------------------------------------------------------------------
; Arguments passed to _fft
;
; AR0       ->    fftdata pointer
; T0        ->    fft size
;
;-----------------------------------------------------------------------

;//-----------------------------------------------------------------------------
;// Array declarations
;//-----------------------------------------------------------------------------

        .ref twiddle		;reference to twiddle table

        .def _cfft_NOSCALE     ; make function visible to other fnct
        .cpl_on
        .arms_off     ; enable assembler for arms mode
        .mmregs
        .noremark    5579, 5573, 5684
  
; Stack frame
; -----------
RET_ADDR_SZ       .set 1            ;return address
REG_SAVE_SZ       .set 5            ;save-on-entry registers saved (T3, T2, AR5, AR6, AR7)
FRAME_SZ          .set 6            ;local variables
ARG_BLK_SZ        .set 0            ;argument block

PARAM_OFFSET      .set ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ + RET_ADDR_SZ


; Local variables on stack
; ------------------------      
       
       .asg    0, tempmem     ; (long) must be aligned on even
       .asg    2, tempmem1    ; (long) must be aligned on even
       .asg    4, data_ptr
       .asg    5, data_sz

;//-----------------------------------------------------------------------------
;// Register aliases
;//-----------------------------------------------------------------------------
		.asg	T3,groups		; number of butterfly groups
		.asg	T1,index		; addess adjustment
		.asg	AR7,bflies		; number of butterflies/group
		.asg	AR4,k			; outer loop counter
		.asg	AR2,a			; top butterfly pointer
		.asg	AR3,b			; bottom butterfly pointer
		.asg	AR5,temp		; temp register	
      
        .text           
_cfft_NOSCALE:

;
; Save any save-on-entry registers that are used
;----------------------------------------------------------------
;
        PSH     T3, T2
     || BCLR    #ARMS, ST2_55          
        PSHBOTH XAR5
     || BSET    #FRCT, ST1_55          
        PSHBOTH XAR6
     || BSET    SATD
        PSHBOTH XAR7
;
; Allocate the local frame and argument block
;----------------------------------------------------------------
        AADD    #-(ARG_BLK_SZ + FRAME_SZ), SP

;-----------------------------------------------------------------------
; FFT implementation
;
; The FFT is implemented in three different steps:
;
;  1) - a radix-4 stage with twiddle factors only equal to -1, 0 and 1
;  2) - a group of log2(FFT_SIZE)-3 radix-2 stages
;  3) - on out-of-place bit-reversal
;
;  No need to implement the last stage in a different way
;  to the other stages.

            ; save all save-on-entry regs that are modified

;-----------------------------------------------------------------------
; Modification of status registers
          

;-----------------------------------------------------------------------
; First two stages computed as one radix-4 stage


    ; --------------------------------------------------------------        
        ; First in-place radix-4 stage
        ;
        ;        ----------
        ; a -----|   R    |----- a'
        ;            A
        ; b -----|   D    |----- b'
        ;            I
        ; c -----|   X    |----- c'
        ;  
        ; d -----|   4    |----- d'
        ;        ---------
        ;
        ; ar' =  (ar + cr) + (br + dr)
        ; ai' =  (ai + ci) + (bi + di) 
        ;
        ; br' =  (ar + cr) - (br + dr)
        ; bi' =  (ai + ci) - (bi + di)
        ;
        ; cr' =  (ar - cr) + (bi - di)
        ; ci' =  (ai - ci) - (br - dr)
        ;
        ; dr' =  (ar - cr) - (bi - di)
        ; di' =  (ai - ci) + (br - dr)
        ;        
        ; AR7, -> temp
        ; AR6  -> temp1
        ;
        ; AR0-> a
        ; AR1-> b
        ; AR2-> c
        ; AR3-> d
        ;
        ; AR5 = AR2
        ;
        ; T0 = 1
        ; T1 = 2
        ;       
        ;
        ; AC0-AC3 modified
        ; T1-T2 modified
        ;
        ; --------------------------------------------------------------        


;
; Save entry values for later
;----------------------------------------------------------------

    ; AR0 contains    #(fftdata)                 ; a
        MOV     XAR0, XAR2

        MOV     T0, *SP(data_sz)   ;
        MOV     AR0, *SP(data_ptr) ; 
       
        ADD     *SP(data_sz), AR2                ; c: AR2 = #(fftdata + 2*2*FFT_SIZE/4)
     
        SFTS    T0, #-1                          ; T0 = FFT_SIZE/2
        MOV     XAR2, XAR3    
        MOV     XAR0, XAR1
        ADD     *SP(data_ptr), T0, AR1           ; b: AR1 = #(fftdata + 1*2*FFT_SIZE/4)

        ADD     T0, AR3                          ; d: AR3 = #(fftdata + 3*2*FFT_SIZE/4)
        SFTS    T0, #-1                          ;T0 = FFT_SIZE/4
        
        SUB     #2, T0
        
        MOV     XSP, XAR7
        MOV     XSP, XAR6
 .if tempmem1 != 0
        ADD     #tempmem1, AR7
 .endif
 .if tempmem != 0
        ADD     #tempmem, AR6
 .endif
       
        MOV     #2, T1                                                         ; 
      ||MOV     dbl(*AR0), AC0                   ; in (ar,ai)
       
        MOV     T0, BRC0
      ||ADD     dual(*AR2), AC0, AC2             ; (ar+cr)/ ; (ai+ci) 
    
        MOV     XAR2, XAR5 
        MOV     #1, T0 
       
        MOV     dbl(*AR1) ,AC1                   ; in (br,bi)
     || MOV     AC2, dbl(*AR6)                   ; temp (ar+cr),(ai+ci)   
    
        SUB     dual(*AR3), AC1, AC2             ; (br-dr)/(bi-di)
        
        SUB     dual(*AR2+), AC0                 ; (ar-cr)/(ai-ci) 
     || MOV     HI(AC2),T3                       ; move (br-dr)
    
        ADD     dual(*AR3), AC1, AC3             ; (br+dr)/ (bi+di)
     || MOV     AC2, T2                          ; move (bi-di)        
                    
        ADD     dual(*AR6), AC3, AC0             ; (ar+cr) + (dr+br) = ar'
                                                 ; (ai+ci) + (di+bi)        = ai'
     || MOV     AC0, dbl(*AR7(T0))               ; (ar-cr),(ai-ci) unaligned
          
        SUB     AC3, dual(*AR6), AC3             ; (ar+cr) - (dr+br) = br'
                                                 ; (ai+ci) - (di+bi)        = bi'
     || MOV     AC0, dbl(*AR0+)                  ; out (ar';ai')
         
        SUBADD  T2, *AR7(T0), AC0                ; (ar-cr) - (bi-di)        = dr'
                                                 ; (ar-cr) + (bi-di)        = cr'

        ADDSUB  T3, *AR7, AC1                    ; (ai-ci) + (br-dr)        = di'
                                                 ; (ai-ci) - (br-dr)        = ci'
        RPTBLOCAL r4_loop-1
    
                MOV     AC3, dbl(*AR1+)             ; out(br', bi')                                                                ; 
             || MOV     dbl(*AR0), AC3              ; in (ar,ai)
       
                MOV     pair(HI(AC0)),dbl(*AR3+)    ; out(dr',di')
             || ADD     dual(*AR2), AC3, AC2        ; (ar+cr) 
                                                    ; (ai+ci)   
                MOV     dbl(*AR1), AC1              ; in (br,bi)
             || MOV     pair(LO(AC0)), dbl(*AR5+)   ; out (cr', ci')
    
                SUB     dual(*AR3), AC1, AC2        ; (br-dr)/(bi-di) 
             || MOV     AC2, dbl(*AR6)              ; temp (ar+cr),(ai+ci)
    
                SUB     dual(*AR2+), AC3, AC0       ; (ar-cr)/(ai-ci) 
             || MOV     HI(AC2), T3                 ; move(br-dr)
    
                ADD     dual(*AR3), AC1, AC3        ; (br+dr)/(bi+di) 
             || MOV     AC2, T2                     ; move (bi-di)        
        
                ADD     dual(*AR6), AC3, AC0        ; (ar+cr) + (dr+br) = ar'
                                                    ; (ai+ci) + (di+bi)        = ai' 
             || MOV     AC0, dbl(*AR7(T0))          ; (ar-cr),(ai-ci) unaligned
           
                SUB     AC3, dual(*AR6), AC3        ; (ar+cr) - (dr+br) = br'
                                                    ; (ai+ci) - (di+bi)        = bi'
             || MOV     AC0, dbl(*AR0+) 
         
                SUBADD  T2, *AR7(T0), AC0           ; (ar-cr) - (bi-di)        = dr'
                                                    ; (ar-cr) + (bi-di)        = cr'

                ADDSUB  T3, *AR7, AC1               ; (ai-ci) + (br-dr)        = di'
                                                    ; (ai-ci) - (br-dr)        = ci'
r4_loop:    

        MOV     AC3, dbl(*AR1+)                     ; out(br', bi')           
        MOV     pair(HI(AC0)), dbl(*AR3+)           ; out(dr',di')       
        MOV     pair(LO(AC0)), dbl(*AR5+)           ; out (cr', ci')      

;-----------------------------------------------------------------------
; radix-2 stages (stages 3->log2(FFT_SIZE) )

        ; main initialization
        ; --------------------
        
        MOV     *SP(data_ptr), AR0    ; AR0 = #fftdata
       
            ; 1 - circular buffer initializations
        
            ; modify ST2 to select linear or circular addressing modes
        OR      #0x57 , mmap(ST2_55)  ; circular AR0, AR1, AR2, AR4 and AR6

            ; circular buffer starting addresses
        ADD     #2, AR0,AR1
        MOV     AR0, mmap(BSA23)      ; P  leg
        MOV     AR0, mmap(BSA45)      ; P' leg    (in-place butterflies)
        MOV     AR1, mmap(BSA01)      ; Q  leg
        MOV     AR1, mmap(BSA67)      ; Q' leg    (in-place butterflies)
                            
            ; circular buffer sizes 
        MOV     *SP(data_sz), T0
        MOV     T0, T1                ; T1 =  #FFT_SIZE
        SFTS    T0, #1        
        SUB     #2, T0
    
        MOV     T0, mmap(BK03)        ; BK03 = (2*FFT_SIZE-2), 
        MOV     T0, mmap(BK47)        ; BK47 = (2*FFT_SIZE-2), 

            ; 2 - register initializations
        
        MOV     *SP(data_sz), T0
        SFTS    T0, #-1
        SFTS    T0, #-1
        
        MOV     T0, AR5               ; 2*number of groups for stage 3    
        MOV     #2, AR7               ; 1/2 * number of butterflies per group for stage 3
       
        AMOV    #twiddle, XAR3        ; not modified during iteration of the stages
        ADD     #2, AR3
        MOV     XAR0,XAR1             ; data page = data page of indata
        MOV     XAR0,XAR2             ; data page = data page of indata
        MOV     XAR0,XAR4             ; data page = data page of indata (in-place butterflies)
        MOV     XAR0,XAR6             ; data page = data page of indata (in-place butterflies)
        MOV     XAR3,XCDP             ; data page = data page of twiddles
        
stage:    ; begining of a new stage

        ; stage initialization
        ; --------------------

            ; 1 - loop counter updates
        
            ; butterfly counter update
        SFTS    AR7, #1
     || MOV     #0, AR4 
        SUB     #2, AR7, AR0
        MOV     AR0, BRC1        ;1 butterflies executed out of the loop

            ; group counter update
        SFTS    AR5, #-1
        SUB     #1, AR5, AR0     
        MOV     AR0, BRC0         

            ; stage "counter" update (T0=0 <=> last stage)
        MOV     AR0, T0

            ; 2 - pointer modifier update
                            
            ; T1 is the pointer modifier                    
        SFTS    T1,#-1        

            ; 3 - index updates                  
            ; AR0 -> Qr[0]
            ; AR1 -> Qi[0]
            ; AR2 -> Pr[0]
            ; AR4 -> Pr'[0]  (performed above to use parallelism)
            ; AR6 -> Qr'[0]

        SFTS    AR0, #1
        ADD     #1, AR0,AR1
        MOV     #0, AR2
     || MOV     AR0, AR6 
        
;;;group:  ; begining of a new group
        
        ; note:
        ; - circular buffers are used for data pointers so that no
        ;   initialization of data pointers is required before a new
        ;   iteration of a group
        ; - twiddle pointer (CDP) is updated inside the loop
        
        RPTBLOCAL r2_loop1-1
        
                ; AC2=Qr[0]:Qi[0] 
                MOV     dbl(*(AR0+T1)), AC2
             || ADD     T1,AR1       
                
                ; AC0 = Pr[0]+Qr[0]:Pi[0]+Qi[0]
                ;     = Pr'[0]:Pr'[0]
                ; CDP = #twiddle
                ADD     dual(*AR2), AC2, AC0 
             || MOV     AR3, CDP

                ; AC1 = Pr[0]-Qr[0]:Pi[0]-Qi[0]
                ;     = Qr'[0]:Qi'[0]
                ; store P'[0]

                SUB     AC2, dual(*(AR2+T1)), AC1    
             || MOV     AC0, dbl(*(AR4+T1))   
      
                RPTBLOCAL r2_loop2-1

                                  ; AC2=Qr[n]*Wr                                    
                                  ; AC3=Qi[n]*Wr
                        MPY     *AR0, *CDP+, AC2               
                      ::MPY     *AR1, *CDP+, AC3                           
        
                                  ; AC3=Qi[n]*Wr+Qr[n]*Wi
                                  ; AC2=Qr[n]*Wr-Qi[n]*Wi

                        MASR    *(AR0+T1), *CDP+, AC3  
                      ::MACR    *(AR1+T1), *CDP+, AC2   
            
                                  ; AC2=(Qr[n]*Wr-Qi[n]*Wi):(Qi[n]*Wr+Qr[n]*Wi)

                        OR      AC3 << #-16, AC2
                
                                  ; hi(AC0)=Pr[n]+(Qr[n]*Wr-Qi[n]*Wi)=Pr'[n]
                                  ; lo(AC0)=Pi[n]+(Qr[n]*Wi+Qi[n]*Wr)=Pi'[n]
                                  ; store Qr'[n-1]:Qi'[n-1]

                         ADD    dual(*AR2), AC2, AC0
                      || MOV    AC1, dbl(*(AR6+T1)) 
    
                                  ; hi(AC1)=Pr[n]-(Qr[n]*Wr-Qi[n]*Wi)=Qr'[n] 
                                  ; lo(AC1)=Pi[n]-(Qr[n]*Wi+Qi[n]*Wr)=Qi'[n]
                                  ; store Pr'[n]:Pi'[n]

                        SUB     AC2, dual(*(AR2+T1)), AC1
                     || MOV     AC0, dbl(*(AR4+T1)) 
r2_loop2:                                    ; end of butterfly loop
        
                MOV     AC1,    dbl(*(AR6+T1))      ; store last Qr':Qi'
r2_loop1:                                    ; end of group loop
    
        BCC     stage, T0!=#0                    ; end of stage loop               
              
end_benchmark:

        AND     #0xF000 , mmap(ST2_55) ; restore linear AR0, AR1, AR2, AR4 and AR6
;
; Allocate the local frame and argument block
;----------------------------------------------------------------
        AADD    #(ARG_BLK_SZ + FRAME_SZ), SP

;Context restore 
        POPBOTH XAR7
     || BSET    #ARMS, ST2_55          
        POPBOTH XAR6
     || BCLR    #FRCT, ST1_55          
        POPBOTH XAR5
        POP     T3,T2 
     || BCLR    SATD
        RET 

        .end         
        






cfft_scale.asm/ 1362765892  0     0     0       23318     `
;/*
; * Copyright (C) 2013 Texas Instruments Incorporated - http://www.ti.com/ 
; * 
; * 
; *  Redistribution and use in source and binary forms, with or without 
; *  modification, are permitted provided that the following conditions 
; *  are met:
; *
; *    Redistributions of source code must retain the above copyright 
; *    notice, this list of conditions and the following disclaimer.
; *
; *    Redistributions in binary form must reproduce the above copyright
; *    notice, this list of conditions and the following disclaimer in the 
; *    documentation and/or other materials provided with the   
; *    distribution.
; *
; *    Neither the name of Texas Instruments Incorporated nor the names of
; *    its contributors may be used to endorse or promote products derived
; *    from this software without specific prior written permission.
; *
; *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
; *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
; *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
; *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
; *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
; *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
; *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
; *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
; *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
; *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
; *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
; *
;*/

;***********************************************************
; Version 3.00.00                                           
;***********************************************************
; Processor:   C55xx
; Description: Radix-2 DIT complex FFT using normal input data
;    and bit-reversed twiddle table (length N/2, cosine/sine format)
;    All stages are in radix-2.
;
; Usage:    void cfft_SCALE (DATA *x, ushort nx);
;
; Limitations:
;   nx must be a power of 2 between 8 and 1024
;
; Benchmarks:
;   Cycles:
;     nx =   8:    162
;     nx =  16:    307
;     nx =  32:    571
;     nx =  64:   1155
;     nx = 128:   2459
;     nx = 256:   5363
;     nx = 512:  11787
;     nx =1024:  25891
;   Code Size (in bytes):  
;     .text            467
;     .const:twiddle  2048 (shared by cfft, cifft, unpack, unpacki)
;
; History:
; 	- 07/18/2002	Sira fixed the bug in the kernal.
;	- 07/02/2003	D. Elam added support for 8 point
;	- 07/17/2003	C. Iovescu changed the way the twiddle table is included
;       - 06/17/2012    Craig Leeds: optimized housekeeping ; removed .bss
;****************************************************************

;-----------------------------------------------------------------------
; Arguments passed to _fft
;
; AR0       ->    fftdata pointer
; T0        ->    fft size
;
;-------------------------------------------------------------------------



;//-----------------------------------------------------------------------------
;// Array declarations
;//-----------------------------------------------------------------------------

	.ref	twiddle  ; include twiddle table	
	         
        .def _cfft_SCALE     ; make function visible to other fnct
        .cpl_on
        .arms_off     ; enable assembler for arms mode
        .mmregs
        .noremark    5579, 5573, 5549, 5684
  
; Stack frame
; -----------
RET_ADDR_SZ       .set 1            ;return address
REG_SAVE_SZ       .set 5            ;save-on-entry registers saved
FRAME_SZ          .set 2            ;local variables
ARG_BLK_SZ        .set 0            ;argument block

PARAM_OFFSET      .set ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ + RET_ADDR_SZ


; Local variables
; --------------      
       
       .asg    0, data_ptr
       .asg    1, data_sz

;//-----------------------------------------------------------------------------
;// Register aliases
;//-----------------------------------------------------------------------------
		.asg	T3,groups		; number of butterfly groups
		.asg	T1,index		; addess adjustment
		.asg	AR7,bflies		; number of butterflies/group
		.asg	AR4,k			; outer loop counter
		.asg	AR2,a			; top butterfly pointer
		.asg	AR3,b			; bottom butterfly pointer
		.asg	AR5,temp		; temp register	

        .text           

_cfft_SCALE:

;
; Save any save-on-entry registers that are used
; Modification of status registers
;----------------------------------------------------------------
;
        PSH     T3, T2
     || BCLR    #ARMS, ST2_55          
        PSHBOTH XAR5
     || BSET    FRCT
        PSHBOTH XAR6
     || BSET    SATD
        PSHBOTH XAR7
;
; Allocate the local frame and argument block
;----------------------------------------------------------------
        AADD    #-(ARG_BLK_SZ + FRAME_SZ), SP
; save all save-on-entry regs that are modified

;-----------------------------------------------------------------------

; Define CSR for scaling loop

        SUB      #2, T0, T1                          
        MOV      T1, CSR                               ; CSR = fftsize - 2
 
;
; Save entry values for later
;----------------------------------------------------------------

        MOV     AR0, *SP(data_ptr) ; 
        MOV     T0, *SP(data_sz)   ;
        
;*******************************************************************************
; SCALING LOOP: Data scaled by 2 before first stage 
;*******************************************************************************
        
        AMAR    *AR0, XAR1                             ; AR0 = #fftdata
        MOV     dbl(*AR0+), AC0                        ; scale by 2 - prime the pipe
        RPT     CSR
                MOV      AC0 >> #1, dual(*AR1+)
              ||MOV      dbl(*AR0+), AC0
        MOV     AC0 >> #1, dual(*AR1+)

;*******************************************************************************
; END SCALING LOOP
;*******************************************************************************

; radix-2 stage 1
; 
        MOV     #2, T1
        MOV     XAR0, XAR2
        MOV     XAR0, XAR4
        MOV     *SP(data_ptr), AR2    ; AR2 = #fftdata  
        MOV     AR2, AR4               ; AR4 = #fftdata  
        MOV     AR2, AR0
        ADD     T0, AR0               ; AR0 = fftdata + fft_size
        MOV     XAR0, XAR5            ; AR5 = fftdata + fft_size
        MOV     T0, T2
        SFTS    T2, #-1               ; T2 = fft_size/2 
        MOV     T2, AR7
        SUB     #2, AR7
        MOV     AR7, BRC0
        
                 ; AC2=Qr[0]:Qi[0] 
        MOV     dbl(*(AR0+T1)), AC2      
                
                ; ac0 = Pr[0]+Qr[0]:Pi[0]+Qi[0]
                ;     = Pr'[0]:Pr'[0]
           
        ADD     dual(*AR2), AC2, AC0 
   
                ; AC1 = Pr[0]-Qr[0]:Pi[0]-Qi[0]
                ;     = Qr'[0]:Qi'[0]
                ; store P'[0]
        SUB     AC2, dual(*(AR2+T1)), AC1    
     || MOV     AC0>>#1, dual(*(AR4+T1))               
                                       
                 
        RPTBLOCAL r2_loop00-1          
                MOV     dbl(*(AR0+T1)), AC2         ; load Q            
             || MOV     AC1>>#1, dual(*(AR5+T1))    ; store new Q   
                ADD     dual(*AR2), AC2, AC0        ; new P   
                SUB     AC2, dual(*(AR2+T1)), AC1   ; new Q 
             || MOV     AC0>>#1, dual(*(AR4+T1))    ; store new P  
r2_loop00:      
             
        MOV     AC1>>#1, dual(*(AR5+T1))            ; store new Q   

; radix-2 stage 2
;
; groupe #1 twiddle = #1  

        MOV     *SP(data_ptr), AR2     ; AR2 = #fftdata  
        MOV     AR2, AR4               ; AR4 = #fftdata  
        MOV     AR2, AR0
        ADD     T2, AR0                ; AR0 = fftdata + fft_size/2
        MOV     AR0, AR5               ; AR5 = fftdata + fft_size/2  
        MOV     T2, T3                 ; T3= fft_size/2
        SFTS    T2, #-1                ; T2 = fft_size/4 
        SUB     #2, T2
        MOV     T2, BRC0               ; BRC0 = fft_size/4 - 2
 
                   ; AC2=Qr[0]:Qi[0] 
        MOV     dbl(*(AR0+T1)), AC2       
                
                ; ac0 = Pr[0]+Qr[0]:Pi[0]+Qi[0]
                ;     = Pr'[0]:Pr'[0]
                ; CDP = #twiddle
        ADD     dual(*AR2), AC2, AC0 
        
                ; AC1 = Pr[0]-Qr[0]:Pi[0]-Qi[0]
                ;     = Qr'[0]:Qi'[0]
                ; store P'[0]
        SUB     AC2, dual(*(AR2+T1)), AC1    
     || MOV     AC0>>#1, dual(*(AR4+T1))               
                 
        RPTBLOCAL r2_loop01-1          
                MOV     dbl(*(AR0+T1)), AC2         ; load Q            
             || MOV     AC1>>#1, dual(*(AR5+T1))    ; store new Q   
                ADD     dual(*AR2), AC2, AC0        ; new P   
                SUB     AC2, dual(*(AR2+T1)), AC1   ; new Q 
             || MOV     AC0>>#1, dual(*(AR4+T1))    ; store new P  
r2_loop01:      

        MOV    AC1>>#1, dual(*(AR5+T1))     ; store new Q    
 
; radix-2 stage 2
;
; groupe #2 twiddle = #-1    

        MOV     *SP(data_ptr), AR2     ; AR2 = #fftdata  
        ADD     T0, AR2                ; AR2 = #fftdata + fft_size
        MOV     AR2, AR4               ; AR4 = #fftdata + fft_size  
        MOV     AR2, AR0
        ADD     T3,  AR0               ; AR0 = #fftdata + 3/2*fft_size 
        MOV     AR0, AR1
        ADD     #1, AR1
        MOV     AR0, AR5               ; AR5 = #fftdata + 3/2*fft_size
        MOV     T2, BRC0               ; BRC0 = fft_size/4 - 2                                 
        AMOV    #twiddle, XAR3         
        ADD     #2, AR3                
        MOV     XAR3, XCDP            
                      
                    ; AC2=Qr[n]*Wr                                    
                    ; AC3=Qi[n]*Wr
        MPY     *AR0, *CDP+, AC2               
      ::MPY     *AR1, *CDP+, AC3  
       
                   ; AC3=Qi[n]*Wr+Qr[n]*Wi
                    ; AC2=Qr[n]*Wr-Qi[n]*Wi

        MASR    *(AR0+T1), *CDP-, AC3
      ::MACR    *(AR1+T1), *CDP-, AC2 
        
                    ; AC2=(Qr[n]*Wr-Qi[n]*Wi):(Qi[n]*Wr+Qr[n]*Wi)

        OR      AC3 << #-16, AC2
         
                    ; hi(AC0)=Pr[n]+(Qr[n]*Wr-Qi[n]*Wi)=Pr'[n]
                    ; lo(AC0)=Pi[n]+(Qr[n]*Wi+Qi[n]*Wr)=Pi'[n]
                             
        ADD     dual(*AR2), AC2, AC0            
   
                       ; hi(AC1)=Pr[n]-(Qr[n]*Wr-Qi[n]*Wi)=Qr'[n] 
                    ; lo(AC1)=Pi[n]-(Qr[n]*Wi+Qi[n]*Wr)=Qi'[n]
                    ; store Pr'[n]:Pi'[n]

        SUB     AC2, dual(*(AR2+T1)), AC1
     || MOV     AC0>>#1, dual(*(AR4+T1)) 
        
        RPTBLOCAL r2_loop02-1

                          ; AC2=Qr[n]*Wr                                    
                          ; AC3=Qi[n]*Wr
                MPY     *AR0, *CDP+, AC2               
              ::MPY     *AR1, *CDP+, AC3                           
        
                          ; AC3=Qi[n]*Wr+Qr[n]*Wi
                          ; AC2=Qr[n]*Wr-Qi[n]*Wi  --correct commenting!
          
                MASR    *(AR0+T1), *CDP-, AC3   
             :: MACR    *(AR1+T1), *CDP-, AC2  
            
                          ; AC2=(Qr[n]*Wr-Qi[n]*Wi):(Qi[n]*Wr+Qr[n]*Wi)
         
                OR      AC3 << #-16, AC2      
                          ; hi(AC0)=Pr[n]+(Qr[n]*Wr-Qi[n]*Wi)=Pr'[n]
                          ; lo(AC0)=Pi[n]+(Qr[n]*Wi+Qi[n]*Wr)=Pi'[n]
                          ; store Qr'[n-1]:Qi'[n-1]

                ADD     dual(*AR2), AC2, AC0
             || MOV     AC1>>#1, dual(*(AR5+T1)) 
    
                          ; hi(AC1)=Pr[n]-(Qr[n]*Wr-Qi[n]*Wi)=Qr'[n] 
                          ; lo(AC1)=Pi[n]-(Qr[n]*Wi+Qi[n]*Wr)=Qi'[n]
                          ; store Pr'[n]:Pi'[n]

                SUB     AC2, dual(*(AR2+T1)), AC1
             || MOV     AC0>>#1, dual(*(AR4+T1)) 
r2_loop02:                                 ; end of butterfly loop
                              
        MOV     *SP(data_sz), T0              
        SUB     #8, T0              
        MOV     AC1>>#1, dual(*(AR5+T1))  
        BCC     final_stage, T0==#0        ; branch to final stage for 8-point fft

;-----------------------------------------------------------------------
; radix-2 stages (stages 3->log2(FFT_SIZE) )
        
        ; main initialization
        ; --------------------
        
        MOV     *SP(data_ptr), AR0  ; AR0 = #fftdata
            ; 1 - circular buffer initializations

        
            ; modify ST2 to select linear or circular addressing modes
        OR      #0x57 , mmap(ST2_55)  ; circular AR0, AR1, AR2, AR4 and AR6
         
            ; circular buffer starting addresses
        ADD     #2, AR0,AR1
        MOV     AR0, mmap(BSA23)    ; P  leg
        MOV     AR0, mmap(BSA45)    ; P' leg    (in-place butterflies)
        MOV     AR1, mmap(BSA01)    ; Q  leg
        MOV     AR1, mmap(BSA67)    ; Q' leg    (in-place butterflies)
                            
            ; circular buffer sizes 
        MOV     *SP(data_sz), T0
        MOV     T0, T1              ; T1 =  #FFT_SIZE
        SFTS    T0, #1        
        SUB     #2, T0
    
        MOV     T0, mmap(BK03)      ; BK03 = (2*FFT_SIZE-2), 
        MOV     T0, mmap(BK47)      ; BK47 = (2*FFT_SIZE-2), 

            ; 2 - register initializations
        
        MOV     *SP(data_sz), T0
        SFTS    T0, #-1
        SFTS    T0, #-1
        
        MOV     T0, AR5             ; 2*number of groups for stage 3    
        MOV     #2, AR7             ; 1/2 * number of butterflies per group for stage 3
       
        ;AMOV #twiddle, XAR3        ; not modified during iteration of the stages
        MOV     XAR0,XAR1           ; data page = data page of indata
        MOV     XAR0,XAR2           ; data page = data page of indata
        MOV     XAR0,XAR4           ; data page = data page of indata (in-place butterflies)
        MOV     XAR0,XAR6           ; data page = data page of indata (in-place butterflies)
        MOV     XAR3,XCDP           ; data page = data page of twiddles
        
stage:    ; begining of a new stage

        ; stage initialization
        ; --------------------

            ; 1 - loop counter updates
        
            ; butterfly counter update
        SFTS    AR7, #1
     || MOV     #0, AR4 
        SUB     #2, AR7, AR0
        MOV     AR0, BRC1        ; butterflies executed out of the loop

            ; group counter update
        SFTS    AR5, #-1
        SUB     #1, AR5, AR0     
        MOV     AR0, BRC0         

            ; stage "counter" update (T0=0 <=> last stage)
        MOV     AR0, T0

            ; 2 - pointer modifier update
                            
            ; T1 is the pointer modifier                    
        SFTS    T1, #-1        

            ; 3 - index updates                  
            ; AR0 -> Qr[0]
            ; AR1 -> Qi[0]
            ; AR2 -> Pr[0]
            ; AR4 -> Pr'[0]  (performed above to use parallelism)
            ; AR6 -> Qr'[0]
 
        SFTS    AR0, #1
        ADD     #1, AR0, AR1
        MOV     #0, AR2
    ||  MOV     AR0, AR6 
        
; begining of a new group

        ; note:
        ; - circular buffers are used for data pointers so that no
        ;   initialization of data pointers is required before a new
        ;   iteration of a group
        ; - twiddle pointer (CDP) is updated inside the loop
                
        RPTBLOCAL r2_loop1-1
        
                ; AC2=Qr[0]:Qi[0] 
                MOV     dbl(*(AR0+T1)), AC2
            ||  ADD     T1, AR1       

                ; CDP = #twiddle
                MOV     AR3, CDP
                
                ; AC0 = Pr[0]+Qr[0]:Pi[0]+Qi[0]
                ;     = Pr'[0]:Pr'[0]
                ADD     dual(*AR2), AC2, AC0 
        
                ; AC1 = Pr[0]-Qr[0]:Pi[0]-Qi[0]
                ;     = Qr'[0]:Qi'[0]
                ; store P'[0]
                SUB     AC2, dual(*(AR2+T1)), AC1    
             || MOV     AC0 >> #1, dual(*(AR4+T1))               
                                                          
        ; --------------------------------------------------------------        
        ; DIT radix-2 butterfly
        ;
        ; Register usage:
        ; 
        ;     address registers
        ; AR0 = Qr
        ; AR1 = Qi
        ; AR2 = Pr:Pi
        ; AR4 = Pr':Pi'
        ; AR6 = Qr':Qi'
        ; CDP = Wr:Wi
        ;
        ;     temporary registers
        ; T1 pointer modifier (jump between two consecutive legs)
        ; T2, T3 - both modified
        ;
        ;     accu registers
        ; AC0, AC1, AC2, AC3 are all modified
        ; 
        ;
        ; Comments:
        ;
        ; This butterfly supports both in-place and out-if-place
        ; implementations.
        ;
        ; input data assumed to be in order (bit-reversion after fft)
        ;
        ; twiddle table
        ;   - assumed to be in bit-reversed order
        ;     - the twiddle factors stored in the tables are the pairs
        ;      {cos(2*pi*k/N) , sin(2*pi*k/N)} = {Wr[k] , -Wi[k]}
        ;   - first twiddle pair {1,0} is suppressed (since the first
        ;       butterfly is computed out of the inner loop)
        ;   - second twiddle pair {0,1} replaced by {0,-1} (-1 can be
        ;     represented with full precision but not 1)
        ;   - when inner loop starts, CDP should point to the
        ;     third twiddle pair {1/sqrt(2),1/sqrt(2)}
        ;
        ; pointer registers
        ;   AR0 -> Qr[]
        ;   AR1 -> Qi[]
        ;   AR2 -> Pr[]
        ;   AR4 -> Pr'[]
        ;   AR6 -> Qr'[]
        ;   CDP -> W[] (bit-reversed twiddle table)
        ;
        ; --------------------------------------------------------------        
        
                RPTBLOCAL r2_loop2-1

                                    ; AC2=Qr[n]*Wr                                    
                                    ; AC3=Qi[n]*Wr
                        MPY     *AR0, *CDP+, AC2               
                      ::MPY     *AR1, *CDP+, AC3                           
                
                                  ; AC3=Qi[n]*Wr+Qr[n]*Wi
                                  ; AC2=Qr[n]*Wr-Qi[n]*Wi

                        MASR    *(AR0+T1), *CDP+, AC3   
                      ::MACR    *(AR1+T1), *CDP+, AC2   
            
                                  ; AC2=(Qr[n]*Wr-Qi[n]*Wi):(Qi[n]*Wr+Qr[n]*Wi)

                        OR      AC3 << #-16, AC2      
                                  ; hi(AC0)=Pr[n]+(Qr[n]*Wr-Qi[n]*Wi)=Pr'[n]
                                  ; lo(AC0)=Pi[n]+(Qr[n]*Wi+Qi[n]*Wr)=Pi'[n]
                                  ; store Qr'[n-1]:Qi'[n-1]

                        ADD     dual(*AR2), AC2, AC0
                     || MOV     AC1>>#1, dual(*(AR6+T1)) 
    
                                  ; hi(AC1)=Pr[n]-(Qr[n]*Wr-Qi[n]*Wi)=Qr'[n] 
                                  ; lo(AC1)=Pi[n]-(Qr[n]*Wi+Qi[n]*Wr)=Qi'[n]
                                  ; store Pr'[n]:Pi'[n]

                        SUB     AC2, dual(*(AR2+T1)), AC1
                     || MOV     AC0>>#1, dual(*(AR4+T1)) 
r2_loop2:                                         ; end of butterfly loop
        
                MOV     AC1>>#1, dual(*(AR6+T1))  ; store last Qr':Qi'
r2_loop1:                                         ; end of group loop

        SUB     #1, T0
        BCC     stage, T0 != #0       ; end of stage loop             
            
; last r2 stage
; no scaling performed
;
; modify ST2 to select linear or circular addressing modes
final_stage:       
        AND     #0xF000 , mmap(ST2_55) ; restore linear AR0, AR1, AR2, AR4 and AR6
        MOV     #2, T1  
        MOV     *SP(data_sz), T0       ; T0 = #fftsize
        MOV     *SP(data_ptr), AR2     ; AR2 = #fftdata  
        MOV     AR2, AR4               ; AR4 = #fftdata  
        MOV     AR2, AR0
        AADD    T1, AR0                ; AR0 = fftdata + 2 
        MOV     #7, AR1
        ADD     AR2, AR1               ; 
        MOV     AR0, AR5               ; AR5 = fftdata + 2 
        SFTS    T0, #-1  
        SUB     #2, T0
        MOV     T0, BRC0               ; BRC0 = fftsize/2-2 
        MOV     #4, T1
        MOV     AR3, CDP             
                      
              ; AC2=Qr[0]:Qi[0] 
        MOV     dbl(*(AR0+T1)), AC2
                
                ; AC0 = Pr[0]+Qr[0]:Pi[0]+Qi[0]
                ;     = Pr'[0]:Pr'[0]
                ; CDP = #twiddle
        ADD     dual(*AR2), AC2, AC0 
        
                ; AC1 = Pr[0]-Qr[0]:Pi[0]-Qi[0]
                ;     = Qr'[0]:Qi'[0]
                ; store P'[0]
        SUB     AC2, dual(*(AR2+T1)), AC1    
     || MOV     AC0, dbl(*(AR4+T1))               
                                                          
        RPTBLOCAL r2_loop3-1

                          ; AC2=Qr[n]*Wr                                    
                          ; AC3=Qi[n]*Wr
                MPY     *AR0, *CDP+, AC2               
              ::MPY     *AR1, *CDP+, AC3                           
        
                          ; AC3=Qi[n]*Wr+Qr[n]*Wi
                          ; AC2=Qr[n]*Wr-Qi[n]*Wi

                MASR    *(AR0+T1), *CDP+, AC3  
              ::MACR    *(AR1+T1), *CDP+, AC2   
            
                          ; AC2=(Qr[n]*Wr-Qi[n]*Wi):(Qi[n]*Wr+Qr[n]*Wi)
        
                OR      AC3 << #-16, AC2      
                          ; hi(AC0)=Pr[n]+(Qr[n]*Wr-Qi[n]*Wi)=Pr'[n]
                          ; lo(AC0)=Pi[n]+(Qr[n]*Wi+Qi[n]*Wr)=Pi'[n]
                          ; store Qr'[n-1]:Qi'[n-1]

                ADD     dual(*AR2), AC2, AC0
             || MOV     AC1, dbl(*(AR5+T1)) 
    
                          ; hi(AC1)=Pr[n]-(Qr[n]*Wr-Qi[n]*Wi)=Qr'[n] 
                          ; lo(AC1)=Pi[n]-(Qr[n]*Wi+Qi[n]*Wr)=Qi'[n]
                          ; store Pr'[n]:Pi'[n]

                SUB     AC2, dual(*(AR2+T1)), AC1
             || MOV     AC0, dbl(*(AR4+T1)) 
r2_loop3:                             ; end of butterfly loop
                      
        MOV     AC1, dbl(*(AR5+T1))
              
end_benchmark:

;
; Deallocate the local frame and argument block
;----------------------------------------------------------------
        AADD    #(ARG_BLK_SZ + FRAME_SZ), SP

;Context restore 

        POPBOTH XAR7
     || BSET    #ARMS, ST2_55          
        POPBOTH XAR6
     || BCLR    FRCT
        POPBOTH XAR5
     || BCLR    SATD
        POP     T3, T2
        RET 

      .end         
        






cfir.asm/       1362765892  0     0     0       9961      `
;/*
; * Copyright (C) 2013 Texas Instruments Incorporated - http://www.ti.com/ 
; * 
; * 
; *  Redistribution and use in source and binary forms, with or without 
; *  modification, are permitted provided that the following conditions 
; *  are met:
; *
; *    Redistributions of source code must retain the above copyright 
; *    notice, this list of conditions and the following disclaimer.
; *
; *    Redistributions in binary form must reproduce the above copyright
; *    notice, this list of conditions and the following disclaimer in the 
; *    documentation and/or other materials provided with the   
; *    distribution.
; *
; *    Neither the name of Texas Instruments Incorporated nor the names of
; *    its contributors may be used to endorse or promote products derived
; *    from this software without specific prior written permission.
; *
; *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
; *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
; *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
; *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
; *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
; *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
; *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
; *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
; *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
; *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
; *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
; *
;*/

;***********************************************************
; Version 3.00.00                                           
;***********************************************************
; Function:     Complex block fir
; Processor:   C55xx
; Description: Implements complex finite impulse response filter using
;              dual-MAC approach.  C-callable.
;
; Usage: ushort oflag = cfir(DATA *x,
;                            DATA *h,
;                            DATA *r,
;                            DATA *dbuffer,
;                            ushort nx,
;                            ushort nh)
;
;                
;     State of the registers upon entry:
;
;        XAR0 contains *x
;        XAR1 contains *h
;        XAR2 contains *r
;        XAR3 contains *dbuffer
;        T0   contains nx
;        T1   contains nh
;
; Notes:
;   x[] array is nx*2 words
;   h[] array is nx*2 words
;   r[] array is nx*2 words
;   dbuffer[] array is (nh*2 + 2) words
;
; Limitations:
;   nh >= 3
;   x[] array must be aligned on 32-bit boundary
;   r[] array must be aligned on 32-bit boundary
;   dbuffer[] array must be aligned on 32-bit boundary
;
; Benchmarks:
;   Cycles:       (nx * ((nh * 2)  + 4)) + 46
;   Code Size (in bytes):  120
;
;----------------------------------------------------------------
; Revision History:
; 1.00  C. Iovescu  01/05/00 - Original release.
; 2.10       Rishi  08/03/2001 - optimized the code for benchmark.
; 3.00  Craig Leeds 05/27/2012 - optimized the code
;
;****************************************************************
        .ARMS_off                     ;enable assembler for ARMS=0
        .CPL_on                       ;enable assembler for CPL=1
        .mmregs                       ;enable mem mapped register names

; Stack frame
; -----------
RET_ADDR_SZ       .set 1            ;return address
REG_SAVE_SZ       .set 0            ;save-on-entry registers saved
FRAME_SZ          .set 0            ;local variables
ARG_BLK_SZ        .set 0            ;argument block

PARAM_OFFSET      .set ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ + RET_ADDR_SZ


;----------------------------------------------------------------
; Assign auxiliary registers for temporaries and address
; calculations.
;----------------------------------------------------------------
        .asg     AR0, x_ptr           ;linear pointer
        .asg     CDP, h_ptr           ;circular pointer
        .asg     AR2, r_ptr           ;linear pointer
        .asg     AR4, db_ptr          ;circular pointer

        .asg     BSAC, h_base         ;base addr for h_ptr
        .asg     BKC, h_sz            ;circ buffer size for h_sz

        .asg     BSA45, db_base       ;base addr for db_ptr
        .asg     XAR4, xdb_base       ;extended base addr for db_ptr
        .asg     BK47, db_sz          ;circ buffer size for db_ptr

        .asg     T0, oflag

        .def    _cfir

        .text
_cfir:
;
; Allocate the local frame and argument block
;----------------------------------------------------------------
;      SP = SP - #(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ)
; - not necessary for this function (the above is zero)

;
; Save any save-on-entry registers that are used
;----------------------------------------------------------------
; - nothing to save for this function

;
; Configure the status registers as needed.
;----------------------------------------------------------------
        BCLR    ACOV0
        BCLR    ACOV1
        BSET    FRCT
        BCLR    ARMS
        BCLR    SMUL
;-----------------------------------------------------------------------
; Copy arguments to local locations and set registers
;
;-----------------------------------------------------------------------
; x pointer - passed in its destination register, need do nothing

; h pointer
        MOV     AR1, mmap(h_base)       ;base address of coefficients
        MOV     XAR1, XCDP

        MOV     #0, h_ptr               ;point to first coefficient
      ||SFTL    T1, #1                  ;multiply by 2 because complex numbers

        MOV     T1, mmap(h_sz)          ;coefficient array size

; r pointer - passed in its destination register, need do nothing

; db pointer
        MOV     XAR3, xdb_base          ;db array address
        AMAR    *AR3+                   ;align pointer to index location
        MOV     *AR3+, db_ptr           ;index of oldest db entry
        MOV     AR3, mmap(db_base)      ;base address for db_ptr
        MOV     T1, mmap(db_sz)         ;db_sz = 2*nh

; Set circular/linear ARx behavior
        BSET    AR4LC
        BSET    CDPLC
;
; Setup loop counts
;----------------------------------------------------------------
        SUB     #1, T0                  ;T0 = nx-1
        MOV     T0, BRC0                ;outer loop executes nx times
        SFTL    T1, #-1                 ;restore original value
        SUB     #3, T1                  ;T1 = nh-3
        MOV     T1, BRC1                ;inner loop executes nh-2 times
;
; Setup index registers
;--------------------------------------------------------------------
     || AMOV    #1, T0
        AMOV    #2, T1
; copy the first value from the input buffer to the delay buffer
        MOV     dbl(*x_ptr+), dbl(*db_ptr)
        
     || RPTBLOCAL  OuterLoopEnd-1       ;start the outer loop
                ;First tap
                MPY     *db_ptr, *h_ptr+, AC0        
                ::MPY   *db_ptr(T0), *h_ptr+, AC1        

                MAS     *db_ptr(T0), *h_ptr+, AC0
                ::MAC   *(db_ptr+T1), *h_ptr+, AC1

                ;Taps 2 through N_TAP
              ||RPTBLOCAL  InnerLoopEnd-1
                        MAC     *db_ptr, *h_ptr+, AC0        ;part 1 of dual MAC, real
                        ::MAC   *db_ptr(T0), *h_ptr+, AC1    ;part 1 of dual MAC, imag
                        MAS     *db_ptr(T0), *h_ptr+, AC0                
                        ::MAC   *(db_ptr+T1), *h_ptr+, AC1
InnerLoopEnd:

                MAC     *db_ptr, *h_ptr+, AC0                ;part 1 of dual MAC, real
                ::MAC   *db_ptr(T0), *h_ptr+, AC1            ;part 1 of dual MAC, imag
                MASR    *db_ptr(T0), *h_ptr+, AC0                
                ::MACR  *db_ptr, *h_ptr+, AC1
; copy the next value from the input buffer to the delay buffer
                MOV     dbl(*x_ptr+), dbl(*db_ptr)
                MOV     pair(HI(AC0)), dbl(*r_ptr+)        ;store result real & imag part (Note: requires alignment of AR2 input array)
OuterLoopEnd:                           ;end of outer loop

;
; Update the db entry point
;----------------------------------------------------------------
        MOV        db_ptr, *-AR3        ;update 1st element of db array
;
; Check if overflow occurred, and setup return value
;----------------------------------------------------------------
        ||MOV   #0, oflag               ;clear oflag
        XCCPART overflow(AC0)
            ||MOV     #1, oflag         ;overflow occurred
        XCCPART overflow(AC1)
            ||MOV     #1, oflag         ;overflow occurred
; Restore status regs to expected C-convention values as needed
;----------------------------------------------------------------
        BCLR    AR4LC
        BCLR    CDPLC
        BSET    ARMS                    ;set ARMS for C
        BCLR    FRCT                    ;clear FRCT for C
        BSET    SMUL                    ;set SMUL for C
;
; Restore any save-on-entry registers that are used
;----------------------------------------------------------------
; - nothing to restore for this function
;
; Deallocate the local frame and argument block
;----------------------------------------------------------------
;      SP = SP + #(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ)
; - not necessary for this function (the above is zero)
;
; Return to calling function
;----------------------------------------------------------------
     || RET                             ;return to calling function
;----------------------------------------------------------------
;End of file


/56             1362765892  0     0     0       19197     `
;/*
; * Copyright (C) 2013 Texas Instruments Incorporated - http://www.ti.com/ 
; * 
; * 
; *  Redistribution and use in source and binary forms, with or without 
; *  modification, are permitted provided that the following conditions 
; *  are met:
; *
; *    Redistributions of source code must retain the above copyright 
; *    notice, this list of conditions and the following disclaimer.
; *
; *    Redistributions in binary form must reproduce the above copyright
; *    notice, this list of conditions and the following disclaimer in the 
; *    documentation and/or other materials provided with the   
; *    distribution.
; *
; *    Neither the name of Texas Instruments Incorporated nor the names of
; *    its contributors may be used to endorse or promote products derived
; *    from this software without specific prior written permission.
; *
; *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
; *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
; *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
; *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
; *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
; *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
; *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
; *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
; *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
; *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
; *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
; *
;*/

;***********************************************************
; Version 3.00.00                                           
;***********************************************************
; Processor:   C55xx
; DescripAC1on: 32-bit radix-2 DIT complex iFFT using normal input data
;    and bit-reversed twiddle table (length N/2, cosine/sine format)
;    First two stages are in radix-4.
;
; Usage:    void cifft32_NOSCALE (LDATA *x, ushort nx);
;
; Limitations:
;   nx must be a power of 2 between 8 and 1024
;
; Benchmarks:
;   Cycles:
;     nx =  16:    441
;     nx =  32:   1040
;     nx =  64:   2455
;     nx = 128:   5742
;     nx = 256:  13253
;     nx = 512:  30172
;     nx =1024:  67132
;   Code Size (in bytes):  
;     .text              307
;     .const:twiddle32  4096 (shared by cfft32, cifft32, unpack32, unpacki32)
;
; History:
;	- 07/17/2003	C. Iovescu changed the way the twiddle table is included
;       - 06/17/2012    Craig Leeds: optimized; removed .bss
;***********************************************************************

;-----------------------------------------------------------------------
; Arguments passed to _ifft
; 	AR0       ->    ifftdata pointer
; 	T0        ->    ifft size
;-----------------------------------------------------------------------

;-----------------------------------------------------------------------
; Array declaraAC1ons
;-----------------------------------------------------------------------

        .ref twiddle32

        .def _cifft32_NOSCALE     	; make funcAC1on visible to other fnct
        .cpl_on
        .arms_off     				; enable assembler for arms mode
        .mmregs
        .noremark    5579, 5573, 5684
        
;-----------------------------------------------------------------------  
; Stack frame
;-----------------------------------------------------------------------
RET_ADDR_SZ       .set 1            ;return address
REG_SAVE_SZ       .set 5            ;save-on-enAC0y registers saved (T3, T2, AR5, AR6, AR7)
FRAME_SZ          .set 4            ;local variables
ARG_BLK_SZ        .set 0            ;argument block

PARAM_OFFSET      .set ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ + RET_ADDR_SZ

;-----------------------------------------------------------------------
; Local variables
;-----------------------------------------------------------------------            
       .asg    0, tempmem            ; (long) must be aligned on even
       .asg    2, data_pac0
       .asg    3, data_sz

;-----------------------------------------------------------------------
; Conditional compile
;-----------------------------------------------------------------------

        .text           
_cifft32_NOSCALE:

;-----------------------------------------------------------------------
; Save any save-on-entry registers that are used
;-----------------------------------------------------------------------
        PSH     T3, T2
     || BCLR    #ARMS, ST2_55          
        PSHBOTH XAR5
     || BSET    #FRCT, ST1_55          
        PSHBOTH XAR6
     || BSET    M40
        PSHBOTH XAR7

;-----------------------------------------------------------------------
; Allocate the local frame and argument block
;-----------------------------------------------------------------------
        AADD    #-(ARG_BLK_SZ + FRAME_SZ), SP

;-----------------------------------------------------------------------
; Save entry values for later
;-----------------------------------------------------------------------
        MOV     AR0, *SP(data_pac0) ; 
        MOV     T0, *SP(data_sz)   ;

;-----------------------------------------------------------------------
; iFFT implementation
;
; The iFFT is implemented in three different steps:
;
;  1) - a radix-4 stage with twiddle factors only equal to -1, 0 and 1
;  2) - a group of log2(iFFT_SIZE)-3 radix-2 stages
;  3) - on out-of-place bit-reversal
;
;  No need to implement the last stage in a different way
;  to the other stages.        
;-----------------------------------------------------------------------
; ModificaAC1on of status registers          
                                           
;-----------------------------------------------------------------------
; First two stages computed as one radix-4 stage
;-----------------------------------------------------------------------      
        ; First in-place radix-4 stage
        ;
        ;        ----------
        ; a -----|   R    |----- a'
        ;            A
        ; b -----|   D    |----- b'
        ;            I
        ; c -----|   X    |----- c'
        ;  
        ; d -----|   4    |----- d'
        ;        ---------
        ;
        ; ar' =  (ar + cr) + (br + dr)
        ; ai' =  (ai + ci) + (bi + di) 
        ;
        ; br' =  (ar + cr) - (br + dr)
        ; bi' =  (ai + ci) - (bi + di)
        ;
        ; cr' =  (ar - cr) - (bi - di)
        ; ci' =  (ai - ci) - (br - dr)
        ;
        ; dr' =  (ar - cr) + (bi - di)
        ; di' =  (ai - ci) + (br - dr)
        ;        
        ; AR6  -> tempmem
        ;
        ; AR0-> a
        ; AR1-> b
        ; AR2-> c
        ; AR3-> d
        ;
        ; --------------------------------------------------------------        
       
        MOV     XAR0, XAR1                                        ; AR0 contains    #(ifftdata) a
        ADD     *SP(data_pac0),T0, AR1                ; b: ar1 = #(ifftdata+4*iFFT_SIZE/4)
        
        MOV     XAR1, XAR2 
        ADD     T0,AR2                                                ; c: ar2 = #(ifftdata+4*iFFT_SIZE/2)
                 
        MOV     XAR2, XAR3    
        ADD     T0, AR3                                                ; d: ar3 = #(ifftdata+4*3*iFFT_SIZE/4)
                
        SFTS    T0, #-1                                        ;T0 = iFFT_SIZE/4
        SFTS    T0, #-1        
        SUB     #1, T0
                
        MOV     XSP, XAR6
 .if (tempmem != 0)
        ADD     #tempmem, XAR6                                  ; AR6 => &tempmem (on stack)`
 .endif
        MOV     T0,BRC0
                
        RPTBLOCAL stage12-1
;-----------------------------------------------------------------------
; Benchmark: 21 stages for stage1_2 loop
;-----------------------------------------------------------------------           
                ;Instruction                                        AC0        AC1        AC2        AC3        AR0        AR1        AR2        AR3            
                MOV     dbl(*AR0), AC0                             ;ar                                ar        br        cr        dr
                SUB     dbl(*AR2),AC0,AC3                          ;                        ar-cr                                
                ADD     dbl(*AR2+),AC0,AC1                         ;        ar+cr                                ci        
                MOV     dbl(*AR1),AC0                              ;br                                                        
                SUB     AC0,dbl(*AR3+),AC2                         ;                dr-br                                di
                MOV     AC2,dbl(*AR6)                              ;AR6->dr-br                                                                
        ||      ADD     AC0<<#1,AC2                                ;                dr+br                                        
                ADD     AC2,AC1                                    ;ar+cr+dr+br                                                
        ||      MOV     dbl(*AR3-),AC0                             ;di                                                        dr 
                MOV     AC1,dbl(*AR0+)                             ;                                ai                        
        ||      SUB     AC2<<#1,AC1                                ;ar+cr-(dr+br)                                                
                MOV     AC1, dbl(*AR1+)                            ;                                        bi                 
                SUB     AC0, dbl(*AR1), AC2                        ;                bi-di                                        
                ADD     dbl(*AR1),AC0,AC1                          ;        bi+di                                                 
                SUB     AC2, AC3                                   ;                        ar-cr-(bi-di)                                
        ||      MOV     dbl(*AR2-),AC0                             ;ci                                                cr        
                MOV     AC3,dbl(*AR2+)                             ;                                                ci        
        ||      ADD     AC2<<#1,AC3                                ;                        ar-cr+(bi-di)                                
                MOV     AC3, dbl(*AR3+)                            ;                                                        di 
        ||      SUB     AC0, dbl(*AR0), AC3                        ;                        ai-ci
                ADD     dbl(*AR0),AC0                              ;ai+ci                                                        
                ADD     AC1,AC0                                    ;ai+ci+di+bi                                                        
        ||      MOV     dbl(*AR6),AC2                              ;                dr-br                                        
                MOV     AC0, dbl(*AR0+)                            ;                                arn                        
        ||      SUB     AC1<<#1,AC0                                ;ai+ci-(di+bi)                                                        
                MOV     AC0, dbl(*AR1+)                            ;                                        brn                
        ||      SUB     AC2,AC3                                    ;                        ai-ci-(dr-br)                                
                MOV     AC3,dbl(*AR2+)                             ;                                                crn        
        ||      ADD     AC2<<#1,AC3                                ;                        ai-ci+(dr-br)                                
                MOV     AC3,dbl(*AR3+)                             ;                                                        drn
stage12:
;-----------------------------------------------------------------------
; End of stage 1 and 2
;-----------------------------------------------------------------------            
                
;-----------------------------------------------------------------------
; radix-2 stages (stages 3->log2(iFFT_SIZE) )  
; register usage
; AR0->Pr, ar1->Qr, ar3->twiddle
; AR4=Re distance of butterfly
; AR6=group count, T1=butterfly count, AR5= stage count  
;-----------------------------------------------------------------------
        ; main iniAC1alizaAC1on                 

        ; modify ST2 to select linear or circular addressing modes
        OR      #0x3, mmap(ST2_55)                ; circular AR0,AR1        
        MOV     *SP(data_pac0), AR1                ; ar1 = #ifftdata  

        ; circular buffer starAC1ng addresses                            
        MOV     AR1, mmap(BSA01)                ; circular buffer start address
               
        ; circular buffer sizes 
        MPYMK   *SP(data_sz),#2,AC0        ; because FRCT==1, it actually x4
        MOV     AC0, mmap(BK03)                ; BK03 = (4*iFFT_SIZE-4), AR0-AR3
        MOV     *SP(data_sz), T2
        SFTS    T2,#-1                                        ; T2 = iFFT_SIZE/2
        MOV     T2,AR4                                    ; AR4 = iFFT_SIZE/2(Re distance between p q)
        SFTS    T2,#-1
     || MOV     #4, AR6                                        ; AR6 = group    
        SFTS    T2,#-1                                        ; T2 = iFFT_SIZE/8
        BCC     end_benchmark, T2==#0

        MOV     T2, T1                                        ; T1 = number of butterfly,
        MOV     T2, AR5                                        ; AR5 = stage                                                                               
        AMOV    #twiddle32, XAR3        ; AR3->twiddle32          

        MOV     #2, T0                  ; moving from real->imag
        MOV     #-2, T2                 ; restoring cdp, and imag->real               
                        
stage:  ; begining of a new stage
        ; stage initialization
        
        ; 1 - loop counter updates     
        SFTS    AR5,#-1                                ; shift right stage count
     || MOV     #0,AR0                
        MOV     XAR3, XCDP
        ADD     #1,AR4,AR1                                ;AR1->QR_LOW
        ADD     #2,AR1,AR2                                ;AR2->QI_LOW
                   
        ; butterfly counter update                                      
        SUB     #1,T1,T3        
        MOV     T3, BRC1                        ;butterflies loop count

        ; group counter update
        SUB     #1,AR6,T3     
        MOV     T3, BRC0              
               
        RPTBLOCAL group-1
;-----------------------------------------------------------------------
; Benchmark: 12 cycles for the butterfly loop
;-----------------------------------------------------------------------
                RPTBLOCAL BFly-1                                ;             (AR1,CDP)
                        MPY     uns(*AR1), *(CDP+T0), AC0       ; AC0  = yrl*crh (1,0)
                ::      MPY     uns(*AR1(T0)), *(CDP+T0), AC1   ; AC1  = yil*crh (3,0)

                        MAS     uns(*AR1(T0)), *CDP+, AC0       ; AC0 -= yil*cih (3,2)
                ::      MAC     uns(*AR1+), *CDP+, AC1          ; AC1 += yrl*cih (1,2)
                ||      SWAP    T0, T2                          ; T0=-2

                        MAS     *AR1, uns(*(CDP+T0)), AC0       ; AC0 -= yih*cil (2,3)
                ::      MAC     *AR1(T0), uns(*(CDP+T0)), AC1   ; AC1 += yrh*cil (0,3)

                        MAC    *AR1(T0), uns(*CDP-), AC0        ; AC0 += yrh*crl (0,1)
                ::      MAC    *(AR1+T0), uns(*CDP-), AC1       ; AC1 += yih*crl (2,1)
                ||      SWAP    T0, T2                          ; T0=2

                        MAC     *AR1, *(CDP+T0), AC0>>#16       ; AC0 += yrh*crh (0,0)
                ::      MAC     *AR1(T0), *(CDP+T0), AC1>>#16   ; AC1 += yih*crh (2,0)

                        MAS     *AR1(T0), *(CDP+T0), AC0        ; AC0 -= yih*cih (2,2)
                ::      MAC     *AR1, *(CDP+T0), AC1            ; AC1 += yrh*cih (0,2)

                        ADD     dbl(*AR0), AC0,AC2
                        MAR     *+CDP(#-4)
                        MOV     AC2,dbl(*AR0)                   ; new xr=AC0+xr  (0,4)
                ||      SUB     AC0,dbl(*AR0+),AC3              ;                (0,4)

                        MOV     AC3, dbl(*AR1+)                 ; new yr=xr-AC0  (2,4)
                ||      SUB     AC1,dbl(*AR0), AC2

                        MOV     AC2, dbl(*AR1+)                 ; new yi=xi-AC1  (2,4) 
                ||      ADD     dbl(*AR0),AC1,AC3               ;                (4,4)
                
                        MOV     AC3, dbl(*AR0+)                 ; new xi=xi+AC1
                ||      AADD    #1, AR1                         ;                (4,4)  
BFly:
                                                                                                                                                                                                                                                                                                                                                                                                                                                              
                AADD    AR4, AR0                                ;jump to next group
                AADD    AR4, AR1                    
                AMAR    *+CDP(4)                                ;CDP+4
group:
                
        SFTS    AR6,#1                                        ;group<<1
        SFTS    T1,#-1                                        ;butterfly>>1
        SFTS    AR4,#-1                                 ;P Q distance>>1
        BCC     stage, AR5!=#0

;-----------------------------------------------------------------------
; End of radix-2 stage 
;-----------------------------------------------------------------------
                                
end_benchmark:

;-----------------------------------------------------------------------
; De-allocate the local frame and argument block
;-----------------------------------------------------------------------
        AADD    #+(ARG_BLK_SZ + FRAME_SZ), SP

        ;Context restore 
        POPBOTH XAR7
     || BCLR    AR1LC
        POPBOTH XAR6
     || BCLR    AR0LC
        POPBOTH XAR5
     || BSET    #ARMS, ST2_55          
        POP     T3, T2
     || BCLR    #FRCT, ST1_55          
        RET 
     || BCLR    M40
                .end         
        

/77             1362765892  0     0     0       21774     `
;/*
; * Copyright (C) 2013 Texas Instruments Incorporated - http://www.ti.com/ 
; * 
; * 
; *  Redistribution and use in source and binary forms, with or without 
; *  modification, are permitted provided that the following conditions 
; *  are met:
; *
; *    Redistributions of source code must retain the above copyright 
; *    notice, this list of conditions and the following disclaimer.
; *
; *    Redistributions in binary form must reproduce the above copyright
; *    notice, this list of conditions and the following disclaimer in the 
; *    documentation and/or other materials provided with the   
; *    distribution.
; *
; *    Neither the name of Texas Instruments Incorporated nor the names of
; *    its contributors may be used to endorse or promote products derived
; *    from this software without specific prior written permission.
; *
; *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
; *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
; *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
; *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
; *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
; *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
; *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
; *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
; *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
; *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
; *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
; *
;*/

;***********************************************************
; Version 3.00.00                                           
;***********************************************************
; Processor:   C55xx
; Description: 32-bit radix-2 DIT complex iFFT using normal input data
;    and bit-reversed twiddle table (length N/2, cosine/sine format)
;    First two stages are separately implmented for MIPS optimization.
; Usage:    void cifft32_SCALE (LDATA *x, ushort nx);
;
; Limitations:
;   nx must be a power of 2 between 8 and 1024
;
; Benchmarks:
;   Cycles:
;     nx =   8:    245
;     nx =  16:    561
;     nx =  32:   1315
;     nx =  64:   3056
;     nx = 128:   7031
;     nx = 256:  15973
;     nx = 512:  35907
;     nx =1024:  81587
;   Code Size (in bytes):  
;     .text              482
;     .const:twiddle32  4096 (shared by cfft32, cifft32, unpack32, unpacki32)
;
; History:
;    08/19/2002 Li Yuan
;        - Changed || to :: in several dual MAC instructions
;    06/19/2012 Craig Leeds
;        - optimized
;****************************************************************

;-----------------------------------------------------------------------
; Arguments passed to _ifft
;
; AR0       ->    ifftdata pointer
; T0        ->    ifft size
;
;-----------------------------------------------------------------------

;//-----------------------------------------------------------------------------
;// Array declarations
;//-----------------------------------------------------------------------------

;        .include "twiddle32.inc"
        .ref twiddle32
        .def _cifft32_SCALE     	; make function visible to other fnct
        .cpl_on
        .arms_off     				; disable assembler for arms mode
        .mmregs
        .noremark    5579, 5573, 5684
  
; Stack frame
; -----------
RET_ADDR_SZ       .set 1            ;return address
REG_SAVE_SZ       .set 5            ;save-on-entry registers saved (T3, T2, AR5, AR6, AR7)
FRAME_SZ          .set 2            ;local variables
ARG_BLK_SZ        .set 0            ;argument block

PARAM_OFFSET      .set ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ + RET_ADDR_SZ


; Local variables
; --------------             
       .asg    0, data_ptr
       .asg    1, data_sz

;----------------------------------------------------------------
; Conditional compile
;----------------------------------------------------------------
SCALED        .set        1                ; SCALED = 0 - not scaled version
                                           ; SCALED = 1 - scaled version
                                                
        .text           
_cifft32_SCALE:

;----------------------------------------------------------------
; Save any save-on-entry registers that are used
;----------------------------------------------------------------

        PSH     T3, T2
        PSHBOTH XAR5
     || BCLR    #ARMS, ST2_55          
        PSHBOTH XAR6
     || BSET    #FRCT, ST1_55          
        PSHBOTH XAR7
     || BSET    M40             

;----------------------------------------------------------------
; Allocate the local frame and argument block
;----------------------------------------------------------------
        AADD    #-(ARG_BLK_SZ + FRAME_SZ), SP

;----------------------------------------------------------------
; Save entry values for later
;----------------------------------------------------------------

;-----------------------------------------------------------------------
; iFFT implementation
;
; The iFFT is implemented in 5 different steps:
;
;  1) - a radix-2 stage without any multiplications.
;  2) - a radix-2 stage with two groups, only the 2nd group has
;       multiplications with 0x7FFFFFFH and 0x00000000
;  3) - a group of log2(iFFT_SIZE)-3 radix-2 stages
;  4) - a radix-2 stage without scaling.
;  5) - on out-of-place bit-reversal
;-----------------------------------------------------------------------
        
;-----------------------------------------------------------------------
; Modification of status registers
;-----------------------------------------------------------------------          
                     
        ; Define CSR for scaling loop
        SUB     #1, T0, T1                          
        MOV     T1, BRC0                            ; BRC0 = ifftsize - 1

        MOV AR0, *SP(data_ptr) ; 
        MOV T0, *SP(data_sz)   ;
        
        AMAR    *AR0,XAR1
        AMAR    *AR0,XAR2

;-----------------------------------------------------------------------
; Scaling loop: Data scaled by 2 before first stage 
;-----------------------------------------------------------------------       
        MOV     dbl(*AR2+), AC0                     ; (Prime the Pump)
     || RPTBLOCAL scaling-1
                MOV     dbl(*AR2+), AC1
             || SFTS    AC0, #-1 
                SFTS    AC1, #-1     
             || MOV     AC0, dbl(*AR1+)
                MOV     AC1, dbl(*AR1+)
             || MOV     dbl(*AR2+), AC0             ; (for next iteration)
scaling:

;-----------------------------------------------------------------------
; Radix-2 stage 1
;-----------------------------------------------------------------------                
        AMAR   *AR0(T0),XAR1                        ; AR1->ifft_data+n2  (b)
        AMAR   *AR1(T0),XAR2                        ; AR2->ifft_data+2*n2(c)
        AMAR   *AR2(T0),XAR3                        ; AR3->ifft_data+3*n2(d)
        MOV    XAR2,XAR7
        SFTS   T0,#-1                               ; T0=ifft-size/2
        SUB    #1,T0,T1                             ; T1=ifft_size/2-1
        MOV    T1,BRC0

;-----------------------------------------------------------------------
; Benchmark: 10 cycles for this loop                
;-----------------------------------------------------------------------
        RPTBLOCAL stage1-1
                MOV     dbl(*AR0+),AC0
                ADD     dbl(*AR7),AC0,AC1           ; AC1=AR+CR
                SUB     dbl(*AR7+),AC0              ; AC0=AR-CR
             || SFTS    AC1,#-1
                MOV     dbl(*AR0-),AC2
             || SFTS    AC0,#-1
                ADD     dbl(*AR7),AC2,AC3           ; AC3=AI+CI        
                SUB     dbl(*AR7-),AC2              ; AC2=AI-CI        
             || MOV     AC1,dbl(*AR0+)              ;(AR+CR)>>1->AR
                SFTS    AC2,#-1
             || MOV     AC0,dbl(*AR7+)              ;(AR-CR)>>1->CR
                SFTS    AC3,#-1
             || MOV     AC2,dbl(*AR7+)              ;(AI-CI)>>1->CI
                MOV     AC3,dbl(*AR0+)              ;(AI+CI)>>1->AI
stage1:

;-----------------------------------------------------------------------
; Radix-2 stage2
;-----------------------------------------------------------------------
        MOV     *SP(data_ptr), AR0
     || SFTS    T0,#-1
        SUB     #1,T0,T1                            ;T0=ifft_size/4
        MOV     T1,BRC0                             ;T1=ifft_size/4-1

;-----------------------------------------------------------------------
; Benchmark: 10 cycles for group1
;-----------------------------------------------------------------------
        RPTBLOCAL group1-1
                MOV     dbl(*AR0+),AC0
                ADD     dbl(*AR1),AC0,AC1           ; AC1=AR+BR
                SUB     dbl(*AR1+),AC0              ; AC0=AR-BR
             || SFTS    AC1,#-1
                MOV     dbl(*AR0-),AC2
             || SFTS    AC0,#-1
                ADD     dbl(*AR1),AC2,AC3           ; AC3=AI+BI
                SUB     dbl(*AR1-),AC2              ; AC2=AI-BI
             || MOV     AC1,dbl(*AR0+)              ; AR+BR->AR
                SFTS    AC2,#-1
             || MOV     AC0,dbl(*AR1+)              ; AR-BR->BR
                SFTS    AC3,#-1
             || MOV     AC2,dbl(*AR1+)              ; AI-BI->BI
                MOV     AC3,dbl(*AR0+)              ; AI+BI->AI
group1:


;-----------------------------------------------------------------------
; Benchmark: 13 cycles for group2        
;-----------------------------------------------------------------------        
        AMOV    #twiddle32, XCDP
        MOV     T1,BRC0
        AMAR    *AR3(#3), XAR4                       ; AR4->DI_LOW
        AMAR   *AR3+                                 ; AR3->DR_LOW

     || RPTBLOCAL group2-1
                MPY     uns(*AR3-),*CDP+,AC0    ;DR_LOW * 7FFF             AR3->DR_HI        CDP->FFFF
             :: MPY     uns(*AR4-),*CDP+,AC1    ;DI_LOW * 7FFF             AR4->DI_HI  
                MAC     *AR3,uns(*CDP-),AC0     ;DR_HI*FFFF+DR_LOW*7FFF,   AR3->DR_HI        CDP->7FFF
             :: MAC     *AR4,uns(*CDP-),AC1     ;DI_HI*FFFF+DI_LOW*7FFF,   AR4->DI_HI        
                MAC     *AR3,*CDP,AC0>>#16      ;DR_HI*7FFF+AC0>>16        AR3->DR_HI        CDP_>7FFF
             :: MAC     *AR4,*CDP,AC1>>#16      ;DI_HI*7FFF+AC1>>16        AR4->DI_HI        CDP_>7FFF                                
                SUB     AC1,dbl(*AR2),AC2       ;AC2=CR-AC1
                ADD     dbl(*AR2+),AC1          ;AC1=CR+AC1                AR2->CI
             || ADD     #5, AR4                 ;                          AR4->DI(next)
                SUB     AC0,dbl(*AR2),AC3       ;AC3=CI-AC0                        
             || SFTS    AC1,#-1
                ADD     dbl(*AR2-),AC0          ;AC0=CI+AC0                AR2->CR
             || SFTS    AC3,#-1
                MOV     AC1,dbl(*AR3+)          ;AC1->DR                   AR3->DI
             || SFTS    AC2,#-1        
                MOV     AC3,dbl(*AR3+)          ;AC3->DI                   AR3->DR(next)
             || SFTS    AC0,#-1
                MOV     AC2,dbl(*AR2+)          ;AC2->CR                   AR2->CI
                MOV     AC0,dbl(*AR2+)          ;AC0->CI                   AR2->CR(next)
             || AMAR   *AR3+                    ;                          AR3->DR_LOW
group2:        

;-----------------------------------------------------------------------
; End of stage 1 and 2
;-----------------------------------------------------------------------                 
        SFTS    T0, #-1
        BCC     end_benchmark, T0==#0
                                                                                                                                                                                                                                                             
;-----------------------------------------------------------------------
; radix-2 stages (stages 3->log2(iFFT_SIZE) )  
;         register usage
;         ar0->Pr, ar1->Qr, ar3->twiddle32
;         ar4=Re distance of butterfly
;         ar6=group count, t1=butterfly count, ar5= stage count  
;-----------------------------------------------------------------------
        ; main initialization                
                
        ; modify ST2 to select linear or circular addressing modes
        OR      #0x3, mmap(ST2_55)             ; circular AR0LC,AR1LC
        MOV     *SP(data_ptr), AR1             ; AR1 = #ifftdata  

        ; circular buffer starting addresses                            
        MOV     AR1, mmap(BSA01)               ; circular buffer start address
               
        ; circular buffer sizes 
        MOV     *SP(data_sz) << #2,AC0 
        MOV     AC0, mmap(BK03)                ; BK03 = (4*iFFT_SIZE-4), AR0-AR3
        
        MOV     *SP(data_sz), AR4
        SFTS    AR4,#-1                        ; AR4 = iFFT_SIZE/2(Re distance between p q)
     || MOV     #4, AR6                        ; AR6 = group    
        MOV     T0, AR5        
     || MOV     #-2, T2
        SFTS    AR5, #-1                        ; AR5=size/16;  AR5 is stage count
        MOV     T0, T1                         ; T1 = iFFT_SIZE/8, nbfly
        AMOV    #twiddle32, XAR3
        MOV     #2, T0
     || BCC     last_stage, AR5 == #0                                                                                

;-----------------------------------------------------------------------
; Beginning of the stage loop
;         stage iniac1alizaac1on
;-----------------------------------------------------------------------
stage:  ; stage loop counter updates     
        SFTS    AR5, #-1                       ; shift right stage count  
        MOV     #0,AR0                
     || MOV     AR3, CDP
        ADD     #1,AR4,AR1                     ;AR1->QR_LOW
                                   
        ; butterfly counter update                                      
        SUB     #1,T1,T3        
        MOV     T3, BRC1        

        ; group counter update
        SUB     #1,AR6,T3     
        MOV     T3, BRC0              
                     
        RPTBLOCAL group-1           
;-----------------------------------------------------------------------
; Benchmark: 15 cycles for butterfly loop
;-----------------------------------------------------------------------
                RPTBLOCAL BFly-1                                                                 ;             (AR1,CDP)
                        MPY     uns(*AR1), *(CDP+T0), AC0       ; AC0  = yrl*crh (1,0)
                     :: MPY     uns(*AR1(T0)), *(CDP+T0), AC1   ; AC1  = yil*crh (3,0)

                        MAS     uns(*AR1(T0)), *CDP+, AC0       ; AC0 -= yil*cih (3,2)
                     :: MAC     uns(*AR1+), *CDP+, AC1          ; AC1 += yrl*cih (1,2)
                     || SWAP    T0, T2                          ; T0=-2

                        MAS     *AR1, uns(*(CDP+T0)), AC0       ; AC0 -= yih*cil (2,3)
                     :: MAC     *AR1(T0), uns(*(CDP+T0)), AC1   ; AC1 += yrh*cil (0,3)

                        MAC     *AR1(T0), uns(*CDP-), AC0       ; AC0 += yrh*crl (0,1)
                     :: MAC     *(AR1+T0), uns(*CDP-), AC1      ; AC1 += yih*crl (2,1)
                     || SWAP    T0, T2                          ; T0=2

                        MAC     *AR1, *(CDP+T0), AC0>>#16       ; AC0 += yrh*crh (0,0)
                     :: MAC     *AR1(T0), *(CDP+T0), AC1>>#16   ; AC1 += yih*crh (2,0)

                        MAS     *AR1(T0), *(CDP+T0), AC0        ; AC0 -= yih*cih (2,2)
                     :: MAC     *AR1, *(CDP+T0), AC1            ; AC1 += yrh*cih (0,2)        
                
                        ADD     dbl(*AR0), AC0,AC2        
                        SFTS    AC2, #-1
                     || MAR     *CDP-    
                        MOV     AC2,dbl(*AR0)                   ; new xr=ac0+xr  (0,4)
                     || SUB     AC0,dbl(*AR0+),AC3              ;                (0,4)
                        SFTS    AC3, #-1
                     || MAR     *CDP-
                        MOV     AC3, dbl(*AR1+)                 ; new yr=xr-ac0  (2,4)
                     || SUB     AC1,dbl(*AR0), AC2
                        SFTS    AC2, #-1
                     || MAR     *CDP-   
                        MOV     AC2, dbl(*AR1+)                 ; new yi=xi-ac1  (2,4) 
                     || ADD     dbl(*AR0),AC1,AC3               ;                (4,4)
                        SFTS    AC3, #-1
                     || MAR     *CDP-   
                        MOV     AC3, dbl(*AR0+)                 ; new xi=xi+ac1
                     || AADD    #1, AR1                         ;                (4,4) 
BFly:
                                                                                                                                                                                                                                                                                                                                                                                                                                                              
                AADD    AR4, AR0                                ;jump to next group
                AADD    AR4, AR1 
                AMAR    *+CDP(4)                                ;CDP+4
group:
                
        SFTS    AR6, #1                                         ;group<<1
        SFTS    T1, #-1                                         ;butterfly>>1
        SFTS    AR4, #-1                                        ;P Q distance>>1
     || BCC     stage, AR5 != #0               
;-----------------------------------------------------------------------
; END radix-2 stages (stages 3->log2(iFFT_SIZE) )  
;-----------------------------------------------------------------------

;-----------------------------------------------------------------------
; Last stage
;-----------------------------------------------------------------------                
last_stage:
        ; stage initialization
        MOV     AR3, CDP                                  
        MOV     #5, AR1                                  ;AR1->QR_LOW
        MOV     #0, AR0                 
        
        ; group counter update
     || SUB     #1, AR6
        MOV     AR6, BRC0              
        MOV     #6, T1
             
     || RPTBLOCAL lgroup-1
                MPY     uns(*AR1), *(CDP+T0), AC0       ; AC0  = yrl*crh (1,0)
             :: MPY     uns(*AR1(T0)), *(CDP+T0), AC1   ; AC1  = yil*crh (3,0)

                MAS     uns(*AR1(T0)), *CDP+, AC0       ; AC0 -= yil*cih (3,2)
             :: MAC     uns(*AR1+), *CDP+, AC1          ; AC1 += yrl*cih (1,2)
             || SWAP    T0, T2                          ; T0=-2

                MAS     *AR1, uns(*(CDP+T0)), AC0       ; AC0 -= yih*cil (2,3)
             :: MAC     *AR1(T0), uns(*(CDP+T0)), AC1   ; AC1 += yrh*cil (0,3)

                MAC     *AR1(T0), uns(*CDP-), AC0       ; AC0 += yrh*crl (0,1)
             :: MAC     *(AR1+T0), uns(*CDP-), AC1      ; AC1 += yih*crl (2,1)
             || SWAP    T0, T2                          ; T0=2

                MAC     *AR1, *(CDP+T0), AC0>>#16       ; AC0 += yrh*crh (0,0)
             :: MAC     *AR1(T0), *(CDP+T0), AC1>>#16   ; AC1 += yih*crh (2,0)

                MAS     *AR1(T0), *(CDP+T0), AC0        ; AC0 -= yih*cih (2,2)
             :: MAC     *AR1, *(CDP+T0), AC1            ; AC1 += yrh*cih (0,2)

                ADD     dbl(*AR0), AC0,AC2
                MOV     AC2,dbl(*AR0)                   ; new xr=ac0+xr  (0,4)
             || SUB     AC0,dbl(*AR0+),AC3              ;                (0,4)

                MOV     AC3, dbl(*AR1+)                 ; new yr=xr-ac0  (2,4)
             || SUB     AC1,dbl(*AR0), AC2

                MOV     AC2, dbl(*(AR1+T1))             ; new yi=xi-ac1  (2,4)
             || ADD     dbl(*AR0),AC1,AC3               ;                (4,4)

                MOV     AC3, dbl(*(AR0+T1))             ; new xi=xi+ac1:  jump to next group                                                         
             || AADD    #1, AR1                         ;                (4,4) 
lgroup:
;-----------------------------------------------------------------------
; END last stage
;-----------------------------------------------------------------------
                                                
end_benchmark:
;-----------------------------------------------------------------------
; Deallocate the local frame and argument block
;----------------------------------------------------------------
        AADD    #+(ARG_BLK_SZ + FRAME_SZ), SP

;Context restore 
        POPBOTH XAR7
     || BCLR    #AR0LC, ST2_55          
        POPBOTH XAR6
     || BCLR    #AR1LC, ST2_55          
        POPBOTH XAR5
     || BSET    #ARMS, ST2_55          
        POP     T3, T2
     || BCLR    #FRCT, ST1_55          
        RET 
     || BCLR    M40             
                .end         
        
/96             1362765892  0     0     0       19131     `
;/*
; * Copyright (C) 2013 Texas Instruments Incorporated - http://www.ti.com/ 
; * 
; * 
; *  Redistribution and use in source and binary forms, with or without 
; *  modification, are permitted provided that the following conditions 
; *  are met:
; *
; *    Redistributions of source code must retain the above copyright 
; *    notice, this list of conditions and the following disclaimer.
; *
; *    Redistributions in binary form must reproduce the above copyright
; *    notice, this list of conditions and the following disclaimer in the 
; *    documentation and/or other materials provided with the   
; *    distribution.
; *
; *    Neither the name of Texas Instruments Incorporated nor the names of
; *    its contributors may be used to endorse or promote products derived
; *    from this software without specific prior written permission.
; *
; *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
; *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
; *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
; *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
; *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
; *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
; *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
; *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
; *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
; *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
; *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
; *
;*/

;***********************************************************
; Version 3.00.00                                           
;***********************************************************
; Processor:   C55xx
; Description: Radix-4/Radix-2 DIT no scale complex IFFT using normal input data
;    and bit-reversed twiddle table (length N/2, cosine/sine format)
;    
; Usage:    void cifft (DATA *x, ushort nx, NOSCALE);
;
; Benchmarks:
;   Cycles:
;     nx =  16:    231
;     nx =  32:    460
;     nx =  64:    977
;     nx = 128:   2153
;     nx = 256:   4798
;     nx = 512:  10707
;     nx =1024:  23748
;   Code Size (in bytes):  
;     .text            323
;     .const:twiddle  2048 (shared by cfft, cifft, unpack, unpacki)
;
; History:
; 	- 07/17/2003	C. Iovescu fixed the bug in the kernal.
;	- 07/17/2003	C. Iovescu changed the way the twiddle table is included
;       - 06/20/2012    Craig Leeds: removed .bss usage and general cleanup
;****************************************************************

;-----------------------------------------------------------------------
; Arguments passed to _fft
;
; AR0       ->    fftdata pointer
; T0        ->    fft size
;
;-----------------------------------------------------------------------



;//-----------------------------------------------------------------------------
;// Array declarations
;//-----------------------------------------------------------------------------

            .ref twiddle

                 
        .def _cifft_NOSCALE     ; make function visible to other fnct
        .cpl_on
        .arms_off               ; enable assembler for arms mode
        .mmregs
        .noremark    5579, 5573, 5684
  
; Stack frame
; -----------
RET_ADDR_SZ       .set 1            ;return address
REG_SAVE_SZ       .set 5            ;save-on-entry registers saved (T3, T2, AR5, AR6, AR7)
FRAME_SZ          .set 6            ;local variables
ARG_BLK_SZ        .set 0            ;argument block

PARAM_OFFSET      .set ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ + RET_ADDR_SZ


; Local variables
; --------------      
       
       .asg    0, tempmem     ; (long) must be aligned on even
       .asg    2, tempmem1    ; (long) must be aligned on even
       .asg    4, data_ptr
       .asg    5, data_sz

;//-----------------------------------------------------------------------------
;// Register aliases
;//-----------------------------------------------------------------------------
                .asg        T3,groups            ; number of butterfly groups
                .asg        T1,index             ; addess adjustment
                .asg        AR7,bflies           ; number of butterflies/group
                .asg        AR4,k                ; outer loop counter
                .asg        AR2,a                ; top butterfly pointer
                .asg        AR3,b                ; bottom butterfly pointer
                .asg        AR5,temp             ; temp register        

        .text           
_cifft_NOSCALE:

;//-----------------------------------------------------------------------------
;// Conditional compile
;//-----------------------------------------------------------------------------
SCALED        .set        0                     ; SCALED = 0 - not scaled version
                                                ; SCALED = 1 - scaled version



;
; Save any save-on-entry registers that are used
;----------------------------------------------------------------
;
        PSH     T3, T2
     || BCLR    #ARMS, ST2_55          
        PSHBOTH XAR5
     || BSET    #FRCT, ST1_55          
        PSHBOTH XAR6
     || BSET    SATD
        PSHBOTH XAR7
;
; Allocate the local frame and argument block
;----------------------------------------------------------------
        AADD    #-(ARG_BLK_SZ + FRAME_SZ), SP
;
; Save entry values for later
;----------------------------------------------------------------

;-----------------------------------------------------------------------
; FFT implementation
;
; The FFT is implemented in three different steps:
;
;  1) - a radix-4 stage with twiddle factors only equal to -1, 0 and 1
;  2) - a group of log2(FFT_SIZE)-3 radix-2 stages
;  3) - on out-of-place bit-reversal
;
;  No need to implement the last stage in a different way
;  to the other stages.
        
;-----------------------------------------------------------------------
              
;-----------------------------------------------------------------------
; First two stages computed as one radix-4 stage


    ; --------------------------------------------------------------        
        ; First in-place radix-4 stage for CIFFT
        ;
        ;        ----------
        ; a -----|   R    |----- a'
        ;            A
        ; b -----|   D    |----- b'
        ;            I
        ; c -----|   X    |----- c'
        ;  
        ; d -----|   4    |----- d'
        ;        ---------
        ;
        ; ar' =  (ar + cr) + (br + dr)
        ; ai' =  (ai + ci) + (bi + di) 
        ;
        ; br' =  (ar + cr) - (br + dr)
        ; bi' =  (ai + ci) - (bi + di)
        ;
        ; cr' =  (ar - cr) - (bi - di)
        ; ci' =  (ai - ci) + (br - dr)
        ;
        ; dr' =  (ar - cr) + (bi - di)
        ; di' =  (ai - ci) - (br - dr)
        ;        
        ; AR7, -> temp
        ; AR6  -> temp1
        ;
        ; AR0-> a
        ; AR1-> b
        ; AR2-> c
        ; AR3-> d
        ;
        ; AR5 = ar2
        ;
        ; T0 = 1
        ; T1 = 2
        ;       
        ;
        ; AC0-AC3 modified
        ; T1-T2 modified
        ;
        ; --------------------------------------------------------------        
                
    ; AR0 contains    #(fftdata)                    ; a

        AMAR    *AR0(T0), XAR2                      ; c: AR2 = #(fftdata + 2*2*FFT_SIZE/4)
        MOV     T0, *SP(data_sz)   ;
     || SFTS    T0, #-1                             ; T0 = FFT_SIZE/2
        MOV     AR0, *SP(data_ptr) ; 
     
        MOV     XSP, XAR7
        MOV     XSP, XAR6
 .if (tempmem1 != 0)
        ADD     #tempmem1, AR7                      ; AR7 = &tempmem1 (on stack)
 .endif
 .if (tempmem != 0)
        ADD     #tempmem, AR6                       ; AR6 = &tempmem (on stack)
 .endif
 
        AMAR    *AR0(T0), XAR1                      ; b: AR1 = #(fftdata + 1*2*FFT_SIZE/4)
        AMAR    *AR2(T0), XAR3                      ; d: AR3 = #(fftdata + 3*2*FFT_SIZE/4)

        SFTS    T0, #-1                             ; T0 = FFT_SIZE/4
        SUB     #2, T0                              ; T0 = FFT_SIZE/4 - 2
        
        MOV     #2, T1                                                         ; 
     || MOV     dbl(*AR0), AC0                      ; in (ar,ai)
       
        MOV     T0, BRC0
     || ADD     dual(*AR2), AC0, AC2                ; (ar+cr)/ ; (ai+ci) 
                            
    
        MOV     XAR2, XAR5 
        MOV     #1, T0
     
        MOV     dbl(*AR1) ,AC1                      ; in (br,bi)
     || MOV     AC2, dbl(*AR6)                      ; temp (ar+cr),(ai+ci)   
    
        SUB     dual(*AR3), AC1, AC2                ; (br-dr)/(bi-di)
        
        SUB     dual(*AR2+), AC0                    ; (ar-cr)/(ai-ci) 
     || MOV     HI(AC2),T3                          ; move (br-dr)
    
        ADD     dual(*AR3), AC1, AC3                ; (br+dr)/ (bi+di)
     || MOV     AC2, T2                             ; move (bi-di)        
                    
        ADD     dual(*AR6), AC3, AC0                ; (ar+cr) + (dr+br) = ar'
                                                    ; (ai+ci) + (di+bi)        = ai'
     || MOV     AC0, dbl(*AR7(T0))                  ; (ar-cr),(ai-ci) unaligned

          
        SUB     AC3, dual(*AR6), AC3                ; (ar+cr) - (dr+br) = br'
                                                    ; (ai+ci) - (di+bi)        = bi'
     || MOV     AC0, dbl(*AR0+)                     ; out (ar';ai')
         
        ADDSUB  T2, *AR7(T0), AC0                   ; (ar-cr) - (bi-di)        = cr' (low part)
                                                    ; (ar-cr) + (bi-di)        = dr' (high part)
        SUBADD  T3, *AR7, AC1                       ; (ai-ci) + (br-dr)        = ci' (low part)
                                                    ; (ai-ci) - (br-dr)        = di' (high part)
     || RPTBLOCAL r4_loop-1
                MOV     AC3, dbl(*AR1+)             ; out(br', bi')                                                                ; 
             || MOV     dbl(*AR0), AC3              ; in (ar,ai)
       
                MOV     pair(LO(AC0)), dbl(*AR5+)   ; out(cr',ci')
             || ADD     dual(*AR2), AC3, AC2        ; (ar+cr) 
                                                    ; (ai+ci)   
                MOV     dbl(*AR1), AC1              ; in (br,bi)
             || MOV     pair(HI(AC0)), dbl(*AR3+)   ; out (dr', di')
    
                SUB     dual(*AR3), AC1, AC2        ; (br-dr)/(bi-di) 
             || MOV     AC2, dbl(*AR6)              ; temp (ar+cr),(ai+ci)
    
        
                SUB     dual(*AR2+), AC3, AC0       ; (ar-cr)/(ai-ci) 
             || MOV     HI(AC2), T3                 ; move(br-dr)
    
                ADD     dual(*AR3), AC1, AC3        ; (br+dr)/(bi+di) 
             || MOV     AC2, T2                     ; move (bi-di)        
                    
        
                ADD     dual(*AR6), AC3, AC0        ; (ar+cr) + (dr+br) = ar'
                                                    ; (ai+ci) + (di+bi)        = ai' 
             || MOV     AC0, dbl(*AR7(T0))          ; (ar-cr),(ai-ci) unaligned
          
           
                SUB     AC3, dual(*AR6), AC3        ; (ar+cr) - (dr+br) = br'
                                                    ; (ai+ci) - (di+bi)        = bi'
             || MOV     AC0, dbl(*AR0+)             ; out (ar';ai')
         
                ADDSUB  T2, *AR7(T0), AC0           ; (ar-cr) - (bi-di)        = cr'
                                                    ; (ar-cr) + (bi-di)        = dr'
                SUBADD  T3, *AR7, AC1               ; (ai-ci) + (br-dr)        = ci'
                                                    ; (ai-ci) - (br-dr)        = di'
r4_loop:
     
    MOV     AC3, dbl(*AR1+)                         ; out(br', bi')          
    MOV     pair(LO(AC0)), dbl(*AR5+)               ; out(cr',ci')       
    MOV     pair(HI(AC0)), dbl(*AR3+)               ; out (dr', di')      

;-----------------------------------------------------------------------
; radix-2 stages (stages 3->log2(FFT_SIZE) )

        ; main initialization
        ; --------------------
        
       MOV     *SP(data_ptr), AR0                   ; AR0 = #fftdata
       
            ; 1 - circular buffer initializations
        
            ; modify ST2 to select linear or circular addressing modes
       OR       #0x57 , mmap(ST2_55)  ; circular AR0, AR1, AR2, AR4 and AR6

            ; circular buffer starting addresses
        ADD     #2, AR0, AR1
        MOV     AR0, mmap(BSA23)       ; P  leg
        MOV     AR0, mmap(BSA45)       ; P' leg    (in-place butterflies)
        MOV     AR1, mmap(BSA01)       ; Q  leg
        MOV     AR1, mmap(BSA67)       ; Q' leg    (in-place butterflies)
                            
            ; circular buffer sizes 
        MOV     *SP(data_sz), T1       ; T1 =  #FFT_SIZE
        SUB     #1, T1, T0
        SFTS    T0, #1        
        MOV     T0, mmap(BK03)        ; BK03 = (2*FFT_SIZE-2), 
        MOV     T0, mmap(BK47)        ; BK47 = (2*FFT_SIZE-2), 

            ; 2 - register initializations
        
        MOV     T1, T0
        SFTS    T0, #-1
        SFTS    T0, #-1          ; 2*number of groups for stage 3    
        MOV     T0, AR5          ; 2*number of groups for stage 3    
        MOV     #2, AR7          ; 1/2 * number of butterflies per group for stage 3
       
        AMOV    #twiddle+2, XAR3 ; not modified during iteration of the stages
                                 ; n=0 processed outside inner loop
        MOV     XAR0, XAR1       ; data page = data page of indata
        MOV     XAR0, XAR2       ; data page = data page of indata
        MOV     XAR0, XAR4       ; data page = data page of indata (in-place butterflies)
        MOV     XAR0, XAR6       ; data page = data page of indata (in-place butterflies)
        MOV     XAR3, XCDP       ; data page = data page of twiddles
        
stage:    ; begining of a new stage

        ; stage initialization
        ; --------------------

        ; 1 - loop counter updates
        
        ; butterfly counter update
        SFTS    AR7, #1
     || MOV     #0, AR4 
        SUB     #2, AR7, AR0
        MOV     AR0, BRC1        ;1 butterflies executed out of the loop

            ; group counter update
        SFTS    AR5, #-1
        SUB     #1, AR5, AR0     
        MOV     AR0, BRC0         

            ; stage "counter" update (T0=0 <=> last stage)
        MOV     AR0, T0

            ; 2 - pointer modifier update
                            
            ; T1 is the pointer modifier                    
        SFTS    T1, #-1        

            ; 3 - index updates                  
            ; AR0 -> Qr[0]
            ; AR1 -> Qi[0]
            ; AR2 -> Pr[0]
            ; AR4 -> Pr'[0]  (performed above to use parallelism)
            ; AR6 -> Qr'[0]
 
        SFTS    AR0, #1
        ADD     #1, AR0, AR1
        AMOV    #0, AR2
     || MOV     AR0, AR6 
        
group:  ; begining of a new group

        ; note:
        ; - circular buffers are used for data pointers so that no
        ;   initialization of data pointers is required before a new
        ;   iteration of a group
        ; - twiddle pointer (CDP) is updated inside the loop
        ; - same twiddle table as for FFT: (wr, wi) = (cos, -sin)
        
        RPTBLOCAL r2_loop1-1        
                ; AC2=Qr[0]:Qi[0] 
                MOV     dbl(*(AR0+T1)), AC2
             || ADD     T1, AR1       
        
                ; AC0 = Pr[0]+Qr[0]:Pi[0]+Qi[0]
                ;     = Pr'[0]:Pi'[0]
                ; CDP = #twiddle
                ADD     dual(*AR2), AC2, AC0 
             || MOV     AR3, CDP             ; #(twiddle+1) has to be loaded in CDP because
                                             ; n=0 is processed outside inner loop 

                ; AC1 = Pr[0]-Qr[0]:Pi[0]-Qi[0]
                ;     = Qr'[0]:Qi'[0]
                ; store P'[0]

                SUB     AC2, dual(*(AR2+T1)), AC1    
             || MOV     AC0, dbl(*(AR4+T1))               
                                                                                                                                                                                        
                RPTBLOCAL r2_loop2 -1

                        ; AC2=Qr[n]*cos                                    
                        ; AC3=Qi[n]*cos
                        MPY     *AR0, *CDP+, AC2               
                     :: MPY     *AR1, *CDP+, AC3                           
        
                        ; AC3=Qi[n]*cos+Qr[n]*sin   
                        ; AC2=Qr[n]*cos-Qi[n]*sin                                           

                        MACR    *(AR0+T1), *CDP+, AC3           ; 
                     :: MASR    *(AR1+T1), *CDP+, AC2   ; 
            
                        ; AC2=(Qr[n]*cos-Qi[n]*sin):(Qi[n]*cos+Qr[n]*sin)

                        OR      AC3 << #-16, AC2    
                        ; hi(AC0)=Pr[n]+(Qr[n]*cos-Qi[n]*sin)=Pr'[n]
                        ; lo(AC0)=Pi[n]+(Qi[n]*cos+Qr[n]*sin)=Pi'[n]
                        ; store Qr'[n-1]:Qi'[n-1]

                        ADD     dual(*AR2), AC2, AC0
                     || MOV     AC1, dbl(*(AR6+T1)) 
    
                        ; hi(AC1)=Pr[n]-(Qr[n]*cos-Qi[n]*sin)=Qr'[n] 
                        ; lo(AC1)=Pi[n]-(Qi[n]*cos+Qr[n]*sin)=Qi'[n]
                        ; store Pr'[n]:Pi'[n]

                        SUB     AC2, dual(*(AR2+T1)), AC1
                     || MOV     AC0, dbl(*(AR4+T1)) 
r2_loop2:                                       ; end of butterfly loop
        
                MOV     AC1, dbl(*(AR6+T1))     ; store last Qr':Qi'
r2_loop1:                                       ; end of group loop
        
        BCC     stage, T0 != #0                 ; end of stage loop               
                       
end_benchmark:

;Context restore 
;
; Deallocate the local frame and argument block
;----------------------------------------------------------------
        AADD    #+(ARG_BLK_SZ + FRAME_SZ), SP
        AND     #~0x01ff, mmap(ST2_55)  ; restore linear AR0, AR1, AR2, AR4 and AR6
        POPBOTH XAR7
     || BSET    #ARMS, ST2_55          
        POPBOTH XAR6
     || BCLR    #FRCT, ST1_55          
        POPBOTH XAR5
     || BCLR    SATD
        POP     T3, T2
        RET 

        .end         
        







cifft_scale.asm/1362765892  0     0     0       24353     `
;/*
; * Copyright (C) 2013 Texas Instruments Incorporated - http://www.ti.com/ 
; * 
; * 
; *  Redistribution and use in source and binary forms, with or without 
; *  modification, are permitted provided that the following conditions 
; *  are met:
; *
; *    Redistributions of source code must retain the above copyright 
; *    notice, this list of conditions and the following disclaimer.
; *
; *    Redistributions in binary form must reproduce the above copyright
; *    notice, this list of conditions and the following disclaimer in the 
; *    documentation and/or other materials provided with the   
; *    distribution.
; *
; *    Neither the name of Texas Instruments Incorporated nor the names of
; *    its contributors may be used to endorse or promote products derived
; *    from this software without specific prior written permission.
; *
; *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
; *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
; *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
; *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
; *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
; *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
; *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
; *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
; *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
; *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
; *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
; *
;*/

;***********************************************************
; Version 3.00.00                                           
;***********************************************************
; Processor:   C55xx
; Description: Radix-2 DIT complex IFFT using normal input data
;    and bit-reversed twiddle table (length N/2, cosine/sine format)
;    All stages are in radix-2.
;
; Usage:    void cifft_SCALE (DATA *x, ushort nx);
;
; Limitations:
;   nx must be a power of 2 between 8 and 1024
;
; Benchmarks:
;   Cycles:
;     nx =   8:    154
;     nx =  16:    299
;     nx =  32:    564
;     nx =  64:   1149
;     nx = 128:   2454
;     nx = 256:   5359
;     nx = 512:  11784
;     nx =1024:  25889
;   Code Size (in bytes):  
;     .text            459
;     .const:twiddle  2048 (shared by cfft, cifft, unpack, unpacki)
;
; History:
;	- 07/02/2003	D. Elam added support for 8 point
;	- 07/17/2003	C. Iovescu changed the way the twiddle table is included
;       - 06/20/2012    Craig Leeds: removed .bss usage and general cleanup
;****************************************************************

;-----------------------------------------------------------------------
; Arguments passed to _fft
;
; AR0       ->    fftdata pointer
; T0        ->    fft size
;
;-------------------------------------------------------------------------

;//-----------------------------------------------------------------------------
;// Array declarations
;//-----------------------------------------------------------------------------

        .ref twiddle

        .def _cifft_SCALE     ; make function visible to other fnct
        .cpl_on
        .arms_off     ; enable assembler for arms mode
        .mmregs
        .noremark    5579, 5573, 5549, 5684
  
; Stack frame
; -----------
RET_ADDR_SZ       .set 1            ;return address
REG_SAVE_SZ       .set 5            ;save-on-entry registers saved (T3, T2, AR5, AR6, AR7)
FRAME_SZ          .set 2            ;local variables
ARG_BLK_SZ        .set 0            ;argument block

PARAM_OFFSET      .set ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ + RET_ADDR_SZ


; Local variables
; --------------      
       
       .asg    0, data_ptr
       .asg    1, data_sz

;//-----------------------------------------------------------------------------
;// Register aliases
;//-----------------------------------------------------------------------------
                .asg        T3,groups          ; number of butterfly groups
                .asg        T1,index           ; addess adjustment
                .asg        AR7,bflies         ; number of butterflies/group
                .asg        AR2,a              ; top butterfly pointer
                .asg        AR3,b              ; bottom butterfly pointer
                .asg        AR5,temp           ; temp register        

        .text           
_cifft_SCALE:

;
; Save any save-on-entry registers that are used
; Modification of status registers
;----------------------------------------------------------------
;
        PSH     T3, T2
     || BCLR    ARMS
        PSHBOTH XAR5
     || BSET    FRCT
        PSHBOTH XAR6
     || BSET    SATD
        PSHBOTH XAR7
;
; Allocate the local frame and argument block
;----------------------------------------------------------------
        AADD    #-(ARG_BLK_SZ + FRAME_SZ), SP
;
; Save entry values for later
;----------------------------------------------------------------

;-----------------------------------------------------------------------
; IFFT implementation
;
; The IFFT is implemented in log2(FFT_SIZE)-1 radix-2 stages:
;
;-----------------------------------------------------------------------

; Define CSR for scaling loop

        SUB     #2, T0, T1                          
        MOV     T1, CSR                               ; CSR = fftsize - 2
 
;*******************************************************************************
; SCALING LOOP: Data scaled by 2 before first stage 
;*******************************************************************************
        
        MOV     XAR0, XAR1                                 ; AR0 = #fftdata

        MOV     AR0, *SP(data_ptr) ; 
        MOV     T0, *SP(data_sz)   ;

        MOV     dbl(*AR0+), AC0                        ; scale by 2 - prime the pipe
        RPT     CSR
                MOV     AC0 >> #1, dual(*AR1+)
             || MOV     dbl(*AR0+), AC0
        MOV     AC0 >> #1, dual(*AR1+)

;*******************************************************************************
; END SCALING LOOP
;*******************************************************************************

; radix-2 stage 1
;
        MOV     #2, T1
        MOV     *SP(data_ptr), AR0     ; AR0 = #fftdata  
        MOV     XAR0, XAR2             ; AR2 = #fftdata  
        MOV     XAR0, XAR4             ; AR4 = #fftdata  
        ADD     T0, AR0                ; AR0 = fftdata + fft_size
        MOV     XAR0, XAR5             ; AR5 = fftdata + fft_size
        MOV     T0, T2
        SFTS    T2, #-1                ; T2 = fft_size/2 
        SUB     #2, T2, AR7
        MOV     AR7, BRC0
                                       ; AC2=Qr[0]:Qi[0] 
        MOV     dbl(*(AR0+T1)), AC2      
                                       ; AC0 = Pr[0]+Qr[0]:Pi[0]+Qi[0]
                                       ;     = Pr'[0]:Pr'[0]
        ADD     dual(*AR2), AC2, AC0 
                                       ; AC1 = Pr[0]-Qr[0]:Pi[0]-Qi[0]
                                       ;     = Qr'[0]:Qi'[0]
                                       ; store P'[0]
        SUB     AC2, dual(*(AR2+T1)), AC1    
     || MOV     AC0>>#1, dual(*(AR4+T1))               
                 
        RPTBLOCAL r2_loop00-1          
                MOV     dbl(*(AR0+T1)), AC2         ; load Q            
             || MOV     AC1>>#1, dual(*(AR5+T1))    ; store new Q   
           
                ADD     dual(*AR2), AC2, AC0        ; new P   
            
                SUB     AC2, dual(*(AR2+T1)), AC1   ; new Q 
             || MOV     AC0>>#1, dual(*(AR4+T1))    ; store new P  
r2_loop00:        
                    
        MOV     AC1>>#1, dual(*(AR5+T1))     ; store new Q   

; radix-2 stage 2
;
; groupe #1 twiddle = #1  

        MOV     *SP(data_ptr), AR2     ; AR2 = #fftdata  
        MOV     AR2, AR4               ; AR4 = #fftdata  
        MOV     AR2, AR0
        ADD     T2, AR0                ; AR0 = fftdata + fft_size/2
        MOV     AR0, AR5               ; AR5 = fftdata + fft_size/2  
        MOV     T2, T3                 ; T3= fft_size/2
        SFTS    T2, #-1                ; T2 = fft_size/4 
        SUB     #2, T2
        MOV     T2, BRC0               ; BRC0 = fft_size/4 - 2
                                       ; AC2=Qr[0]:Qi[0] 
        MOV     dbl(*(AR0+T1)), AC2       
                                       ; AC0 = Pr[0]+Qr[0]:Pi[0]+Qi[0]
                                       ;     = Pr'[0]:Pr'[0]
                                       ; CDP = #twiddle
        ADD     dual(*AR2), AC2, AC0  
                                       ; AC1 = Pr[0]-Qr[0]:Pi[0]-Qi[0]
                                       ;     = Qr'[0]:Qi'[0]
                                       ; store P'[0]
        SUB     AC2, dual(*(AR2+T1)), AC1    
     || MOV     AC0>>#1, dual(*(AR4+T1))               
                 
        RPTBLOCAL r2_loop01-1          
                MOV     dbl(*(AR0+T1)), AC2        ; load Q            
             || MOV     AC1>>#1, dual(*(AR5+T1))   ; store new Q   
        
                ADD     dual(*AR2), AC2, AC0       ; new P   
 
                SUB     AC2, dual(*(AR2+T1)), AC1  ; new Q 
             || MOV     AC0>>#1, dual(*(AR4+T1))   ; store new P  
r2_loop01:        
                    
         MOV    AC1>>#1, dual(*(AR5+T1))     ; store new Q    
 
; radix-2 stage 2
;
; groupe #2 twiddle = #-1    

        ADD     *SP(data_ptr), T0, AR2 ; AR2 = #fftdata + fft_size
        MOV     AR2, AR4               ; AR4 = #fftdata + fft_size  
        MOV     AR2, AR0
        ADD     T3,  AR0               ; AR0 = #fftdata + 3/2*fft_size 
        AMOV    #twiddle+2, XAR3       ; 
        MOV     XAR3, XCDP             ; 
        ADD     #1, AR0, AR1
        MOV     AR0, AR5               ; AR5 = #fftdata + 3/2*fft_size
        MOV     T2, BRC0               ; BRC0 = fft_size/4 - 2                                   
                                       ; AC2=Qr[n]*Wr                                    
                                       ; AC3=Qi[n]*Wr
        MPY     *AR0, *CDP+, AC2               
     :: MPY     *AR1, *CDP+, AC3  
                                       ; AC3=Qi[n]*Wr+Qr[n]*Wi
                                       ; AC2=Qr[n]*Wr-Qi[n]*Wi
        MACR    *(AR0+T1), *CDP-, AC3
     :: MASR    *(AR1+T1), *CDP-, AC2 
                                       ; AC2=(Qr[n]*Wr-Qi[n]*Wi):(Qi[n]*Wr+Qr[n]*Wi)
        OR      AC3 << #-16, AC2
                                       ; hi(AC0)=Pr[n]+(Qr[n]*Wr-Qi[n]*Wi)=Pr'[n]
                                       ; lo(AC0)=Pi[n]+(Qr[n]*Wi+Qi[n]*Wr)=Pi'[n]
        ADD     dual(*AR2), AC2, AC0            
                                       ; hi(AC1)=Pr[n]-(Qr[n]*Wr-Qi[n]*Wi)=Qr'[n] 
                                       ; lo(AC1)=Pi[n]-(Qr[n]*Wi+Qi[n]*Wr)=Qi'[n]
                                       ; store Pr'[n]:Pi'[n]
        SUB     AC2, dual(*(AR2+T1)), AC1
     || MOV     AC0>>#1, dual(*(AR4+T1)) 
        
        RPTBLOCAL r2_loop02-1
                                             ; AC2=Qr[n]*Wr                                    
                                             ; AC3=Qi[n]*Wr
                MPY     *AR0, *CDP+, AC2               
             :: MPY     *AR1, *CDP+, AC3                           
                                             ; AC3=Qi[n]*Wr+Qr[n]*Wi
                                             ; AC2=Qr[n]*Wr-Qi[n]*Wi  --correct commenting!
                MACR    *(AR0+T1), *CDP-, AC3   
             :: MASR    *(AR1+T1), *CDP-, AC2  
                                             ; AC2=(Qr[n]*Wr-Qi[n]*Wi):(Qi[n]*Wr+Qr[n]*Wi)
                OR      AC3 << #-16, AC2     
                                             ; hi(AC0)=Pr[n]+(Qr[n]*Wr-Qi[n]*Wi)=Pr'[n]
                                             ; lo(AC0)=Pi[n]+(Qr[n]*Wi+Qi[n]*Wr)=Pi'[n]
                                             ; store Qr'[n-1]:Qi'[n-1]
                ADD     dual(*AR2), AC2, AC0
             || MOV     AC1>>#1, dual(*(AR5+T1)) 
                                             ; hi(AC1)=Pr[n]-(Qr[n]*Wr-Qi[n]*Wi)=Qr'[n] 
                                             ; lo(AC1)=Pi[n]-(Qr[n]*Wi+Qi[n]*Wr)=Qi'[n]
                                             ; store Pr'[n]:Pi'[n]
                SUB     AC2, dual(*(AR2+T1)), AC1
             || MOV     AC0>>#1, dual(*(AR4+T1)) 
r2_loop02:                                   ; end of butterfly loop

        MOV     *SP(data_sz), T0                  
        SUB     #8, T0 
        MOV     AC1>>#1, dual(*(AR5+T1))  
        BCC     final_stage, T0 == #0          ; branch to final stage if 8-point fft
 
;-----------------------------------------------------------------------
; radix-2 stages (stages 3->log2(FFT_SIZE) )

        ; main initialization
        ; --------------------
        
        MOV     *SP(data_ptr), AR0                ; AR0 = #fftdata
       ;MOV  #twiddle, AR3 
            ; 1 - circular buffer initializations
        
            ; modify ST2 to select linear or circular addressing modes
        OR      #0x57 , mmap(ST2_55)  ; circular AR0, AR1, AR2, AR4 and AR6

            ; circular buffer starting addresses
        ADD     #2, AR0, AR1
        MOV     AR0, mmap(BSA23)       ; P  leg
        MOV     AR0, mmap(BSA45)       ; P' leg    (in-place butterflies)
        MOV     AR1, mmap(BSA01)       ; Q  leg
        MOV     AR1, mmap(BSA67)       ; Q' leg    (in-place butterflies)
                            
            ; circular buffer sizes 
        MOV     *SP(data_sz), T0
        MOV     T0, T1                ; T1 =  #FFT_SIZE
        SFTS    T0, #1        
        SUB     #2, T0
        MOV     T0, mmap(BK03)        ; BK03 = (2*FFT_SIZE-2), 
        MOV     T0, mmap(BK47)        ; BK47 = (2*FFT_SIZE-2), 

            ; 2 - register initializations
        
        MOV     *SP(data_sz), T0
        SFTS    T0, #-1
        SFTS    T0, #-1
        
        MOV     T0, AR5               ; 2*number of groups for stage 3    
        MOV     #2, AR7               ; 1/2 * number of butterflies per group for stage 3

        ;AMOV     #twiddle, XAR3      ; not modified during iteration of the stages
        MOV     XAR0, XAR1            ; data page = data page of indata
        MOV     XAR0, XAR2            ; data page = data page of indata
        MOV     XAR0, XAR4            ; data page = data page of indata (in-place butterflies)
        MOV     XAR0, XAR6            ; data page = data page of indata (in-place butterflies)
        MOV     XAR3, XCDP            ; data page = data page of twiddles
        
stage:    ; begining of a new stage

        ; stage initialization
        ; --------------------

            ; 1 - loop counter updates
        
            ; butterfly counter update
        SFTS    AR7, #1
     || MOV     #0, AR4 
        SUB     #2, AR7, AR0
        MOV     AR0, BRC1        ;1 butterflies executed out of the loop

            ; group counter update
        SFTS    AR5, #-1
        SUB     #1, AR5, AR0     
        MOV     AR0, BRC0         

            ; stage "counter" update (T0=0 <=> last stage)
        AMOV    AR0, T0
            ; 2 - pointer modifier update
            ; T1 is the pointer modifier                    
     || SFTS    T1, #-1        

            ; 3 - index updates                  
            ; AR0 -> Qr[0]
            ; AR1 -> Qi[0]
            ; AR2 -> Pr[0]
            ; AR4 -> Pr'[0]  (performed above to use parallelism)
            ; AR6 -> Qr'[0]
 
        SFTS    AR0, #1
        ADD     #1, AR0, AR1
        MOV     #0, AR2
    ||  MOV     AR0, AR6 
        
group:  ; begining of a new group

        ; note:
        ; - circular buffers are used for data pointers so that no
        ;   initialization of data pointers is required before a new
        ;   iteration of a group
        ; - twiddle pointer (CDP) is updated inside the loop
                
        RPTBLOCAL r2_loop1-1
                                             ; AC2=Qr[0]:Qi[0] 
                MOV     dbl(*(AR0+T1)), AC2
            ||  ADD     T1,AR1       
                                             ; AC0 = Pr[0]+Qr[0]:Pi[0]+Qi[0]
                                             ;     = Pr'[0]:Pr'[0]
                                             ; CDP = #twiddle
                ADD     dual(*AR2), AC2, AC0 
             || MOV     AR3, CDP
                                             ; AC1 = Pr[0]-Qr[0]:Pi[0]-Qi[0]
                                             ;     = Qr'[0]:Qi'[0]
                                             ; store P'[0]
                SUB     AC2, dual(*(AR2+T1)), AC1    
             || MOV     AC0>>#1, dual(*(AR4+T1))               
                                                          
        ; --------------------------------------------------------------        
        ; DIT radix-2 butterfly
        ;
        ; Register usage:
        ; 
        ;     address registers
        ; AR0 = Qr
        ; AR1 = Qi
        ; AR2 = Pr:Pi
        ; AR4 = Pr':Pi'
        ; AR6 = Qr':Qi'
        ; CDP = Wr:Wi
        ;
        ;     temporary registers
        ; T1 pointer modifier (jump between two consecutive legs)
        ; t2, t3 - both modified
        ;
        ;     accu registers
        ; AC0, AC1, AC2, AC3 are all modified
        ; 
        ;
        ; Comments:
        ;
        ; This butterfly supports both in-place and out-if-place
        ; implementations.
        ;
        ; input data assumed to be in order (bit-reversion after fft)
        ;
        ; twiddle table
        ;   - assumed to be in bit-reversed order
        ;     - the twiddle factors stored in the tables are the pairs
        ;      {cos(2*pi*k/N) , sin(2*pi*k/N)} = {Wr[k] , -Wi[k]}
        ;   - first twiddle pair {1,0} is suppressed (since the first
        ;       butterfly is computed out of the inner loop)
        ;   - second twiddle pair {0,1} replaced by {0,-1} (-1 can be
        ;     represented with full precision but not 1)
        ;   - when inner loop starts, CDP should point to the
        ;     third twiddle pair {1/sqrt(2),1/sqrt(2)}
        ;
        ; pointer registers
        ;   AR0 -> Qr[]
        ;   AR1 -> Qi[]
        ;   AR2 -> Pr[]
        ;   AR4 -> Pr'[]
        ;   AR6 -> Qr'[]
        ;   CDP -> W[] (bit-reversed twiddle table)
        ;
        ; --------------------------------------------------------------        
        
                RPTBLOCAL r2_loop2-1
                                                  ; AC2=Qr[n]*Wr                                    
                                                  ; AC3=Qi[n]*Wr
                        MPY     *AR0, *CDP+, AC2               
                      ::MPY     *AR1, *CDP+, AC3                           
                                                  ; AC3=Qi[n]*Wr+Qr[n]*Wi
                                                  ; AC2=Qr[n]*Wr-Qi[n]*Wi
                        MACR    *(AR0+T1), *CDP+, AC3   
                     :: MASR    *(AR1+T1), *CDP+, AC2   
                                                  ; AC2=(Qr[n]*Wr-Qi[n]*Wi):(Qi[n]*Wr+Qr[n]*Wi)
                        OR      AC3 << #-16, AC2      
                                                  ; hi(AC0)=Pr[n]+(Qr[n]*Wr-Qi[n]*Wi)=Pr'[n]
                                                  ; lo(AC0)=Pi[n]+(Qr[n]*Wi+Qi[n]*Wr)=Pi'[n]
                                                  ; store Qr'[n-1]:Qi'[n-1]
                        ADD     dual(*AR2), AC2, AC0
                     || MOV     AC1>>#1, dual(*(AR6+T1)) 
                                                  ; hi(AC1)=Pr[n]-(Qr[n]*Wr-Qi[n]*Wi)=Qr'[n] 
                                                  ; lo(AC1)=Pi[n]-(Qr[n]*Wi+Qi[n]*Wr)=Qi'[n]
                                                  ; store Pr'[n]:Pi'[n]
                        SUB     AC2, dual(*(AR2+T1)), AC1
                     || MOV     AC0>>#1, dual(*(AR4+T1)) 
r2_loop2:                                         ; end of butterfly loop
        
                MOV     AC1>>#1, dual(*(AR6+T1))  ; store last Qr':Qi'
r2_loop1:                                         ; end of group loop

        SUB     #1, T0
        BCC     stage, T0!=#0       ; end of stage loop               
              
; last r2 stage
; no scaling performed
;
; modify ST2 to select linear addressing modes
final_stage:      
        AND     #0xF000 , mmap(ST2_55)  ; restore linear addressing in AR0, AR1, AR2, AR4 and AR6
        MOV     #2, T1  
        MOV     *SP(data_sz), T0        ; T0 = #fftsize
        MOV     *SP(data_ptr), AR2      ; AR2 = #fftdata  
        MOV     AR2, AR4                ; AR4 = #fftdata  
        MOV     AR2, AR0
        ADD     T1, AR0                 ; AR0 = fftdata + 2 
        ADD     #7, AR2, AR1                ; 
        MOV     AR0, AR5                ; AR5 = fftdata + 2 
        SFTS    T0, #-1  
        SUB     #2, T0
        MOV     T0, BRC0                ; BRC0 = fftsize/2-2 
        MOV     #4, T1
        MOV     AR3, CDP                ; (note: CDPH is already correct for twiddle)
                                        ; AC2=Qr[0]:Qi[0] 
        MOV     dbl(*(AR0+T1)), AC2
                                        ; AC0 = Pr[0]+Qr[0]:Pi[0]+Qi[0]
                                        ;     = Pr'[0]:Pr'[0]
                                        ; CDP = #twiddle
        ADD     dual(*AR2), AC2, AC0 
                                        ; AC1 = Pr[0]-Qr[0]:Pi[0]-Qi[0]
                                        ;     = Qr'[0]:Qi'[0]
                                        ; store P'[0]
        SUB     AC2, dual(*(AR2+T1)), AC1    
     || MOV     AC0, dbl(*(AR4+T1))               
        
        RPTBLOCAL r2_loop3-1
                                              ; AC2=Qr[n]*Wr                                    
                                              ; AC3=Qi[n]*Wr
                MPY     *AR0, *CDP+, AC2               
              ::MPY     *AR1, *CDP+, AC3                           
                                              ; AC3=Qi[n]*Wr+Qr[n]*Wi
                                              ; AC2=Qr[n]*Wr-Qi[n]*Wi
                MASR    *(AR1+T1), *CDP+, AC2  
              ::MACR    *(AR0+T1), *CDP+, AC3   
                                              ; AC2=(Qr[n]*Wr-Qi[n]*Wi):(Qi[n]*Wr+Qr[n]*Wi)
                OR      AC3 << #-16, AC2      
                                              ; hi(AC0)=Pr[n]+(Qr[n]*Wr-Qi[n]*Wi)=Pr'[n]
                                              ; lo(AC0)=Pi[n]+(Qr[n]*Wi+Qi[n]*Wr)=Pi'[n]
                                              ; store Qr'[n-1]:Qi'[n-1]
                ADD     dual(*AR2), AC2, AC0
             || MOV     AC1, dbl(*(AR5+T1)) 
                                              ; hi(AC1)=Pr[n]-(Qr[n]*Wr-Qi[n]*Wi)=Qr'[n] 
                                              ; lo(AC1)=Pi[n]-(Qr[n]*Wi+Qi[n]*Wr)=Qi'[n]
                                              ; store Pr'[n]:Pi'[n]
                SUB     AC2, dual(*(AR2+T1)), AC1
             || MOV     AC0, dbl(*(AR4+T1)) 
r2_loop3:                                     ; end of butterfly loop
                              
        MOV     AC1, dbl(*(AR5+T1))
              
end_benchmark:

;
; Deallocate the local frame and argument block
; Context restore 
;----------------------------------------------------------------
        AADD    #+(ARG_BLK_SZ + FRAME_SZ), SP
        POPBOTH XAR7
     || BSET    ARMS
        POPBOTH XAR6
     || BCLR    FRCT
        POPBOTH XAR5
     || BCLR    SATD
        POP     T3, T2
        RET 
        .end         


convol.asm/     1362765892  0     0     0       7276      `
;/*
; * Copyright (C) 2013 Texas Instruments Incorporated - http://www.ti.com/ 
; * 
; * 
; *  Redistribution and use in source and binary forms, with or without 
; *  modification, are permitted provided that the following conditions 
; *  are met:
; *
; *    Redistributions of source code must retain the above copyright 
; *    notice, this list of conditions and the following disclaimer.
; *
; *    Redistributions in binary form must reproduce the above copyright
; *    notice, this list of conditions and the following disclaimer in the 
; *    documentation and/or other materials provided with the   
; *    distribution.
; *
; *    Neither the name of Texas Instruments Incorporated nor the names of
; *    its contributors may be used to endorse or promote products derived
; *    from this software without specific prior written permission.
; *
; *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
; *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
; *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
; *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
; *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
; *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
; *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
; *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
; *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
; *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
; *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
; *
;*/

;***********************************************************
; Version 3.00.00                                           
;***********************************************************
; Function:    convol
; Processor:   C55xx
; Description: Implements real convolution algorithm using
;              single-MAC approach.  C-callable.
;
; Usage: ushort oflag = convol(DATA *x,
;                              DATA *h,
;                              DATA *r,
;                              ushort nr,
;                              ushort nh)
; Limitations:
;   nh >= 3
;
; Benchmarks:
;   Cycles:       (nr * (nh + 1)) + 24
;   Code Size (in bytes):  68
;
; History:
;   Craig Leeds 05/24/2012:  Set SMUL on exit; optimized housekeeping
;****************************************************************

      .ARMS_off                     ;enable assembler for ARMS=0
      .CPL_on                       ;enable assembler for CPL=1
      .mmregs                       ;enable mem mapped register names

; Stack frame
; -----------
RET_ADDR_SZ       .set 1            ;return address
REG_SAVE_SZ       .set 0            ;save-on-entry registers saved
FRAME_SZ          .set 0            ;local variables
ARG_BLK_SZ        .set 0            ;argument block

PARAM_OFFSET      .set ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ + RET_ADDR_SZ


; Register usage
; --------------
      .asg     AR0, x_ptr           ;linear pointer
      .asg     AR1, h_ptr           ;circular pointer
      .asg     AR2, r_ptr           ;linear pointer

      .asg     BSA01, h_base        ;base addr for h_ptr
      .asg     BK03, h_sz           ;circ buffer size for h_sz

      .asg     CSR, inner_cnt       ;inner loop count
      .asg     BRC0, outer_cnt      ;outer loop count

      .asg     T0, oflag            ;returned value

      .global _convol

      .text
_convol:

;
; Allocate the local frame and argument block
;----------------------------------------------------------------
;      SP = SP - #(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ)
; - not necessary for this function (the above is zero)
;
; Save any save-on-entry registers that are used
;----------------------------------------------------------------
; - nothing to save for this function
;
; Configure the status registers as needed.
;----------------------------------------------------------------
        BCLR    ARMS
        BSET    FRCT
        BCLR    SMUL
        BCLR    ACOV0
;
; Setup passed parameters in their destination registers
; Setup circular/linear CDP/ARx behavior
;----------------------------------------------------------------

; x pointer - passed in its destination register, need do nothing

; h pointer - setup

        MOV     AR1, mmap(h_base)        ;base address of h[]
        SUB     #1, T1, h_ptr            ;h_ptr = nh-1 (end of h[])
        MOV     T1, mmap(h_sz)           ;coefficient array size

; r pointer - passed in its destination register, need do nothing

; Set circular/linear ARx behavior

        BSET    AR1LC
;
; Setup loop counts
;----------------------------------------------------------------
        SUB     #1, T0                   ;T0 = nr - 1
        MOV     T0, outer_cnt            ;outer loop executes nr times
        SUB     #3, T1, T0               ;T0 = nh - 3
        MOV     T0, inner_cnt            ;inner loop executes nh-2 times
;
; Compute last iteration input pointer offsets
;----------------------------------------------------------------
        SUB     #2, T1                   ;T1 = nh-2, adjustment for x_ptr

; Start of outer loop
;----------------------------------------------------------------
     || RPTBLOCAL EndLoop-1              ;start the outer loop

;1st iteration
                MPYM    *x_ptr+, *h_ptr-, AC0

;inner loop
             || RPT     inner_cnt
                        MACM    *x_ptr+, *h_ptr-, AC0

;last iteration has different pointer adjustment and rounding
                MACMR   *(x_ptr-T1), *h_ptr-, AC0

;store result to memory
                MOV     HI(AC0), *r_ptr+    ;store Q15 result to memory
EndLoop:                                    ;end of outer loop

;
; Check if overflow occurred, and setup return value
;----------------------------------------------------------------
        MOV     #0, oflag                   ;clear oflag T0
     || BCLR    AR1LC                       ; restore AR1 to linear for C
        XCCPART overflow(AC0)               ;clears ACOV0
              ||MOV     #1, oflag           ;T0=1 overflow occurred

;
; Restore status regs to expected C-convention values as needed
;----------------------------------------------------------------
        BCLR    FRCT                        ;clear FRCT
        BSET    ARMS                        ;set ARMS
        BSET    SMUL
;
; Restore any save-on-entry registers that are used
;----------------------------------------------------------------
; - nothing to restore for this function
;
; Deallocate the local frame and argument block
;----------------------------------------------------------------
;      SP = SP + #(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ)
; - not necessary for this function (the above is zero)
;
; Return to calling function
;----------------------------------------------------------------
     || RET                                ;return to calling function

;----------------------------------------------------------------
;End of file
convol1.asm/    1362765892  0     0     0       8325      `
;/*
; * Copyright (C) 2013 Texas Instruments Incorporated - http://www.ti.com/ 
; * 
; * 
; *  Redistribution and use in source and binary forms, with or without 
; *  modification, are permitted provided that the following conditions 
; *  are met:
; *
; *    Redistributions of source code must retain the above copyright 
; *    notice, this list of conditions and the following disclaimer.
; *
; *    Redistributions in binary form must reproduce the above copyright
; *    notice, this list of conditions and the following disclaimer in the 
; *    documentation and/or other materials provided with the   
; *    distribution.
; *
; *    Neither the name of Texas Instruments Incorporated nor the names of
; *    its contributors may be used to endorse or promote products derived
; *    from this software without specific prior written permission.
; *
; *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
; *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
; *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
; *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
; *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
; *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
; *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
; *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
; *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
; *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
; *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
; *
;*/

;***********************************************************
; Version 3.00.00                                           
;***********************************************************
; Function:    convol1
; Processor:   C55xx
; Description: Implements real convolution algorithm using
;              dual-MAC approach.  C-callable.
;
; Usage: ushort oflag = convol1(DATA *x,
;                               DATA *h,
;                               DATA *r,
;                               ushort nr,
;                               ushort nh)
;
; Limitations:
;   nr is even
;   nh >= 3
;
; Notes:
;   The algorithm will take twice as many cycles if x[] and h[]
;   are in the same block of on-chip memory.
;
; Benchmarks:
;   Cycles:       ((nr / 2) * (nh + 2)) + 28
;   Code Size (in bytes):  82
;
; History:
;   Craig Leeds 05/24/2012:  Set SMUL on exit
;                            Test ACOV1 on exit 
;****************************************************************

      .ARMS_off                     ;enable assembler for ARMS=0
      .CPL_on                       ;enable assembler for CPL=1
      .mmregs                       ;enable mem mapped register names

; Stack frame
; -----------
RET_ADDR_SZ    .set 1               ;return address
REG_SAVE_SZ    .set 0               ;save-on-entry registers saved
FRAME_SZ       .set 0               ;local variables
ARG_BLK_SZ     .set 0               ;argument block

PARAM_OFFSET   .set ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ + RET_ADDR_SZ


; Register usage
; --------------
      .asg     AR0, x_ptr           ;linear pointer
      .asg     AR2, r_ptr           ;linear pointer
      .asg     CDP, h_ptr           ;circular pointer

      .asg     BSAC, h_base         ;base addr for h_ptr
      .asg     BKC, h_sz            ;circ buffer size for h_sz
      .asg     XCDP, xh_base        ;extended base address for h_ptr

      .asg     CSR, inner_cnt       ;inner loop count
      .asg     BRC0, outer_cnt      ;outer loop count
      .asg     T0, oflag            ;returned value

      .global _convol1

      .text
_convol1:

;
; Allocate the local frame and argument block
;----------------------------------------------------------------
;      SP = SP - #(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ)
; - not necessary for this function (the above is zero)

;
; Save any save-on-entry registers that are used
;----------------------------------------------------------------
; - nothing to save for this function

;
; Configure the status registers as needed.
;----------------------------------------------------------------

        BCLR    ARMS
        BSET    FRCT
        BCLR    SMUL
        BCLR    ACOV0
        BCLR    ACOV1
;
; Setup passed parameters in their destination registers
; Setup circular/linear CDP/ARx behavior
;----------------------------------------------------------------

; x pointer - passed in its destination register, need do nothing

; Setup outer loop count
        SFTS    T0, #-1                 ;T0 = nr/2
        SUB     #1, T0                  ;T0 = (nr/2 - 1)
        MOV     T0, outer_cnt           ;BRC0 outer loop executes nr/2 times
;----------------------------------------------------------------

; h pointer - setup
        MOV     XAR1, xh_base           ;extended base address for h_ptr
        SUB     #1, T1, T0              ;T0 = nh-1
        MOV     T0, h_ptr               ;h_ptr = nh-1 (end of h[])
        MOV     AR1, mmap(h_base)       ;base address of coefficients
        MOV     T1, mmap(h_sz)          ;coefficient array size
; Set circular/linear ARx behavior
        BSET    CDPLC

; r pointer - passed in its destination register, need do nothing

;
; Setup inner loop count
;----------------------------------------------------------------
        SUB     #3, T1, T0              ;T0 = nh-3

        MOV     T0, inner_cnt           ;CSR inner loop executes nh-2 times
      ||MOV     #1, T0                  ;x_ptr offset for parallel computation

;
; Compute last iteration input pointer offsets
;----------------------------------------------------------------
        SUB     #3, T1                  ;T1 = nh-3, adjustment for x_ptr
;
; Start of outer loop
;----------------------------------------------------------------
      ||RPTBLOCAL EndLoop-1             ;start the outer loop

;1st iteration
                MPY     *x_ptr+, *h_ptr-, AC0               ;part 1 of dual-MPY
              ::MPY     *x_ptr(T0), *h_ptr-, AC1            ;part 2 of dual-MPY

;inner loop
              ||RPT     inner_cnt
                        MAC     *x_ptr+,  *h_ptr-, AC0      ;part 1 of dual-MAC
                      ::MAC     *x_ptr(T0), *h_ptr-, AC1    ;part 2 of dual-MAC

;last iteration has different pointer adjustment and rounding
                MACR    *(x_ptr-T1), *h_ptr-, AC0           ;part 1 of dual-MAC
              ::MACR    *x_ptr(T0), *h_ptr-, AC1            ;part 2 of dual-MAC

;store result to memory
                MOV     HI(AC0), *r_ptr+                    ;store 1st Q15 result to memory
                MOV     HI(AC1), *r_ptr+                    ;store 2nd Q15 result to memory
EndLoop:
;
; Check if overflow occurred, and setup return value
;----------------------------------------------------------------
        MOV     #0, oflag               ;clear oflag T0
     || BCLR    CDPLC
        XCCPART overflow(AC0)           ;clears ACOV0
              ||MOV        #1, oflag    ;T0=1 overflow occurred
        XCCPART overflow(AC1)           ;clears ACOV1
              ||MOV        #1, oflag    ;T0=1 overflow occurred
;
; Restore status regs to expected C-convention values as needed
;----------------------------------------------------------------
        BCLR    FRCT      ;clear FRCT
        BSET    ARMS      ;set ARMS
        BSET    SMUL
;
; Restore any save-on-entry registers that are used
;----------------------------------------------------------------
; - nothing to restore for this function

;
; Deallocate the local frame and argument block
;----------------------------------------------------------------
;      SP = SP + #(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ)
; - not necessary for this function (the above is zero)

;
; Return to calling function
;----------------------------------------------------------------
     || RET                      ;return to calling function

;----------------------------------------------------------------
;End of file

convol2.asm/    1362765892  0     0     0       8204      `
;/*
; * Copyright (C) 2013 Texas Instruments Incorporated - http://www.ti.com/ 
; * 
; * 
; *  Redistribution and use in source and binary forms, with or without 
; *  modification, are permitted provided that the following conditions 
; *  are met:
; *
; *    Redistributions of source code must retain the above copyright 
; *    notice, this list of conditions and the following disclaimer.
; *
; *    Redistributions in binary form must reproduce the above copyright
; *    notice, this list of conditions and the following disclaimer in the 
; *    documentation and/or other materials provided with the   
; *    distribution.
; *
; *    Neither the name of Texas Instruments Incorporated nor the names of
; *    its contributors may be used to endorse or promote products derived
; *    from this software without specific prior written permission.
; *
; *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
; *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
; *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
; *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
; *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
; *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
; *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
; *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
; *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
; *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
; *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
; *
;*/

;***********************************************************
; Version 3.00.00                                           
;***********************************************************
; Function:    convol2
; Processor:   C55xx
; Description: Implements real convolution algorithm using
;              dual-MAC approach.  C-callable.
;
; Usage: ushort oflag = convol2(DATA *x,
;                               DATA *h,
;                               DATA *r,
;                               ushort nr,
;                               ushort nh)
;
; Limitations:
;   nr is even
;   nh >= 3
;   r[] must be aligned on a 32-bit boundary
;
; Notes:
;   The algorithm will take twice as many cycles if x[] and h[]
;   are in the same block of on-chip memory.
;
; Benchmarks:
;   Cycles:       ((nr / 2) * (nh + 1)) + 28
;   Code Size (in bytes):  81
;
; History:
;   Craig Leeds 05/24/2012:  Set SMUL on exit
;                            Test ACOV1 on exit 
;****************************************************************

      .ARMS_off                     ;enable assembler for ARMS=0
      .CPL_on                       ;enable assembler for CPL=1
      .mmregs                       ;enable mem mapped register names

; Stack frame
; -----------
RET_ADDR_SZ    .set 1               ;return address
REG_SAVE_SZ    .set 0               ;save-on-entry registers saved
FRAME_SZ       .set 0               ;local variables
ARG_BLK_SZ     .set 0               ;argument block

PARAM_OFFSET   .set ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ + RET_ADDR_SZ


; Register usage
; --------------
      .asg     AR0, x_ptr           ;linear pointer
      .asg     AR2, r_ptr           ;linear pointer
      .asg     CDP, h_ptr           ;circular pointer

      .asg     BSAC, h_base         ;base addr for h_ptr
      .asg     BKC, h_sz            ;circ buffer size for h_sz
      .asg     XCDP, xh_base        ;extended base address for h_ptr

      .asg     CSR, inner_cnt       ;inner loop count
      .asg     BRC0, outer_cnt      ;outer loop count

      .asg     T0, oflag            ;returned value

      .global _convol2

      .text
_convol2:

;
; Allocate the local frame and argument block
;----------------------------------------------------------------
;      SP = SP - #(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ)
; - not necessary for this function (the above is zero)

;
; Save any save-on-entry registers that are used
;----------------------------------------------------------------
; - nothing to save for this function

;
; Configure the status registers as needed.
;----------------------------------------------------------------

        BCLR    ARMS
        BSET    FRCT
        BCLR    SMUL
        BCLR    ACOV0
        BCLR    ACOV1

;
; Setup passed parameters in their destination registers
; Setup circular/linear CDP/ARx behavior
;----------------------------------------------------------------

; x pointer - passed in its destination register, need do nothing

; Setup outer loop count
        SFTS    T0, #-1              ;T0 = nr/2
        SUB     #1, T0               ;T0 = (nr/2 - 1)
        MOV     T0, outer_cnt        ;outer loop executes nr/2 times
; h pointer - setup

        MOV     XAR1, xh_base        ;extended base address for h_ptr
        SUB     #1, T1, T0           ;T0 = nh - 1
        MOV     T0, h_ptr            ;h_ptr = nh-1(end of h[])
        MOV     AR1, mmap(h_base)    ;base address of coefficients
        MOV     T1, mmap(h_sz)       ;coefficient array size

; r pointer - passed in its destination register, need do nothing

; Set circular/linear ARx behavior
      BSET        CDPLC

;
; Setup inner loop count
;----------------------------------------------------------------
        SUB     #3, T1, T0           ;T0 = nh - 3

        MOV     T0, inner_cnt        ;inner loop executes nh-2 times
      ||MOV     #1, T0               ;x_ptr offset for parallel computation

;
; Compute last iteration input pointer offsets
;----------------------------------------------------------------
        SUB     #3, T1               ;T1 = nh-3, adjustment for x_ptr

;
; Start of outer loop
;----------------------------------------------------------------
     || RPTBLOCAL LoopEnd-1          ;start the outer loop

;1st iteration
                MPY     *x_ptr+, *h_ptr-, AC0              ;part 1 of dual-MPY
              ::MPY     *x_ptr(T0), *h_ptr-, AC1           ;part 2 of dual-MPY

;inner loop
              ||RPT     inner_cnt
                        MAC     *x_ptr+, *h_ptr-, AC0      ;part 1 pf dual-MAC
                      ::MAC     *x_ptr(T0), *h_ptr-, AC1   ;part 2 of dual-MAC

;last iteration has different pointer adjustment and rounding
                MACR    *(x_ptr-T1), *h_ptr-, AC0          ;part 1 pf dual-MAC
              ::MACR    *x_ptr(T0), *h_ptr-, AC1           ;part 2 of dual-MAC

;store result to memory
                MOV     pair(HI(AC0)), dbl(*r_ptr+)        ;store both Q15 results to memory
LoopEnd:

;
; Check if overflow occurred, and setup return value
;----------------------------------------------------------------
        MOV     #0, oflag            ;clear oflag T0
     || BCLR    CDPLC     ; restore CDP to linear for C
        XCCPART overflow(AC0)        ;clears ACOV0
              ||MOV     #1, oflag    ;T0=1 overflow occurred
        XCCPART overflow(AC1)        ;clears ACOV1
              ||MOV     #1, oflag    ;T0=1 overflow occurred

;
; Restore status regs to expected C-convention values as needed
;----------------------------------------------------------------
        BSET    ARMS      ;set ARMS
        BCLR    FRCT      ;clear FRCT
        BSET    SMUL
;
; Restore any save-on-entry registers that are used
;----------------------------------------------------------------
; - nothing to restore for this function

;
; Deallocate the local frame and argument block
;----------------------------------------------------------------
;      SP = SP + #(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ)
; - not necessary for this function (the above is zero)

;
; Return to calling function
;----------------------------------------------------------------
     || RET                                ;return to calling function

;----------------------------------------------------------------
;End of file
craw.asm/       1362765892  0     0     0       13400     `
;/*
; * Copyright (C) 2013 Texas Instruments Incorporated - http://www.ti.com/ 
; * 
; * 
; *  Redistribution and use in source and binary forms, with or without 
; *  modification, are permitted provided that the following conditions 
; *  are met:
; *
; *    Redistributions of source code must retain the above copyright 
; *    notice, this list of conditions and the following disclaimer.
; *
; *    Redistributions in binary form must reproduce the above copyright
; *    notice, this list of conditions and the following disclaimer in the 
; *    documentation and/or other materials provided with the   
; *    distribution.
; *
; *    Neither the name of Texas Instruments Incorporated nor the names of
; *    its contributors may be used to endorse or promote products derived
; *    from this software without specific prior written permission.
; *
; *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
; *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
; *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
; *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
; *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
; *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
; *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
; *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
; *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
; *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
; *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
; *
;*/

;***********************************************************
; Version 3.00.00                                           
;***********************************************************
; Function:    corr_raw
; Processor:   C55xx
; Description: raw full length correlation of two vectors
;
; Usage:  ushort corr_raw (DATA *x, DATA *y, DATA *r, ushort nx, ushort ny);
;
; Notes:
;   If y[] is in SARAM instead of DARAM, the function will take twice as many cycles.
;
; Limitations:
;   ny >= nx
;   x[] must be on-chip (i.e. DARAM or SARAM)
;
; Benchmarks:
;   Cycles:
;      Cycle computations are very complicated.
;        For nx and ny = 128:     9032
;        For nx and ny = 100:     5672
;        For nx and ny =  50:     1622
;        For nx and ny =  16:      309
;        For nx and ny =   8:      152
;   Code Size (in bytes):  309
;
; History:
; - Modified save and restore AR5/AR6/AR7 to XAR5/XAR6/XAR7 registers.
;   Li Yuan - 08/14/01
;
; - Added overflow checking and overflow is returned in T0 instead of 
;   AC0 register
;       Zhengting He - 10/25/2006
;
; - Bug fixed where T3 was modified but not restored.
; - Bug fixed where AC0 and AC1 checked for overflow, but bit not cleared on entry
; - Some optimizations of RPTBLOCAL blocks
;       Craig Leeds - 06/10/2012
;
;****************************************************************

      .ARMS_off                     ;enable assembler for ARMS=0
      .CPL_on                       ;enable assembler for CPL=1
      .mmregs                       ;enable mem mapped register names
      
        .global _corr_raw

; Stack frame
; -----------
RET_ADDR_SZ       .set 1            ;return address
REG_SAVE_SZ       .set 5            ;save-on-entry registers saved (T2, T3, AR5, AR6, AR7)
FRAME_SZ          .set 0            ;local variables
ARG_BLK_SZ        .set 0            ;argument block

; Register usage
; --------------

PARAM_OFFSET    .set  FRAME_SZ + REG_SAVE_SZ        
        .asg    0 + REG_SAVE_SZ + FRAME_SZ, RETURN_ADDR

        .asg    AR0, x_ptr
        .asg    XAR0, Xx_ptr
        .asg    AR1, y_ptr
        .asg    XAR1, Xy_ptr
        .asg    AR2, r_ptr
        .asg    AR3, mac_cnt
        .asg    AR4, x_save
        .asg    XAR4, Xx_save
        .asg    AR6, x2_save
        .asg    XAR6, Xx2_save
        .asg    AR5, y_save
        .asg    XAR5, Xy_save
        .asg    AR7, y_orig
        .asg    XAR7, Xy_orig

        .asg    T0, nx                      ; input arg
        .asg    T1, ny                      ; input arg
        .asg    T2, region1_and_3_loop_cnt
        
        .asg    T0, oflag                   ; for C55, return value in T0
        
        .text
_corr_raw:
;
; Allocate the local frame and argument block( +1 is for dbl alignment)
;----------------------------------------------------------------
; Save any save-on-entry registers that are used
; Configure the status registers as needed.
;----------------------------------------------------------------
        PSH     T2, T3
     || BCLR    ARMS                        ; clear ARMS
        PSHBOTH XAR5
     || BSET    #ST1_FRCT, ST1_55
        PSHBOTH XAR6
     || BCLR    ACOV0                        ; clear overflow bit 
        PSHBOTH XAR7
     || BCLR    ACOV1                        ; clear overflow bit 
        
;---------- X pointer setup    
; x_ptr                -        X pointer as passed
; x_save        -        X+nx
; x2_save        -        X
        MOV     Xx_ptr, Xx2_save ;
        MOV     Xx_ptr, Xx_save ;
        MOV     x_ptr, AC0
        ADD     nx, AC0
        MOV     AC0, x_save
        
;---------- Y pointer setup    
; y_ptr                -        Y pointer as passed
; y_orig        -        Unchainged original Y pointer
        MOV     Xy_ptr, Xy_save
        MOV     Xy_ptr, Xy_orig
        
; Initialize MAC cnt for regions 1 & 3, these will be          
; calculated in one loop, since the number of elements is the  
; same in each region.                                         
;----------------------------------------------------------------
        MOV     nx, AC1
        SUB     #4, AC1
;    region1_and_3_loop_cnt = AC1
        MOV     AC1, region1_and_3_loop_cnt
        SUB     #1, x_save

; ---- ODD detection ----
; Due to the Dual MAC, we need to know if the region 1 and region 3
; are odd or even in length. If the number is odd, then we will need
; to do an extra MAC outside of the loop.
;
; Test to see if the LSB 
; of NR is set. If it is, 
; then we have an odd number

        BTST    @#0, region1_and_3_loop_cnt, TC1       ; TC1 set if there is an odd count
        
; Begin Region 1:                                      
;----------------------------------------------------------------
REGION1:
        MOV     Xy_save, Xy_ptr
        MOV     Xx_save, Xx_ptr
                
; For the dual MAC, we need to divide by two followed
; by a subsequent subtraction by 1 only if we have and odd number
; of MAC's to do. 
; region1_and_3_loop_cnt = region1_and_3_loop_cnt >> #1;
        SFTL    region1_and_3_loop_cnt, #-1
; if (odd<#0) execute(d_unit)                                                                
        XCCPART !TC1
                ||SUB     #1, region1_and_3_loop_cnt

        MOV     region1_and_3_loop_cnt, BRC0
        MOV     #0, mac_cnt             ; 2 cycles 

; Calculate first couple of elements outside of the loop     
; ---- 1 -----
        MPYMR   *x_ptr, *y_ptr+, AC0
        MOV     HI(AC0), *r_ptr+
        
; ---- 2 and Pointer stuff ----

        MPYM    *x_ptr-, *y_ptr-, AC0 
     || ADD     #2, y_save

        MACMR   *x_ptr, *y_ptr, AC0, AC0
            
        MOV     Xx_save, XCDP
        MOV     Xy_save, Xx_ptr
        MOV     Xx_ptr, Xy_ptr
        ADD     #1, x_ptr, y_ptr    ; Setup the secondary point in case
                                ; we enter the Dual MAC        
        
        MOV     HI(AC0), *r_ptr+
        
;If there is an even number, skip the extra MAC
        BCC     REGION1_LOOP, TC1
        
; ---- 3 -----
REGION1_extra_mac:
        MPYM    *x_ptr-, *CDP-, AC0 
     || ADD     #1, y_save 

        MACM    *x_ptr-, *CDP-, AC0
        
        MACMR   *x_ptr-, *CDP-, AC0 
     || MOV     x_save, CDP
        
        MOV     Xy_save, Xx_ptr
        MOV     Xx_ptr, Xy_ptr
        ADD     #1, x_ptr, y_ptr
        ADD     #1, mac_cnt
        MOV     mac_cnt, CSR
        MOV     HI(AC0), *r_ptr+

REGION1_LOOP:
        
        RPTBLOCAL endlocal1-1
                ADD     #2, y_save

; ---- Preload AC0 ----
                MPY     *x_ptr-, *CDP-, AC0 
             :: MPY     *y_ptr-, *CDP-, AC1
        
; ---- Main Dual MAC loop  ----        
             || RPTADD  CSR, #2
                        MAC     *x_ptr-, *CDP-, AC0 
                     :: MAC     *y_ptr-, *CDP-, AC1

; ---- Cleanup MAC ----
                MACMR   *x_ptr, *CDP, AC0
            ||  AMOV    y_save, x_ptr
                MACM    *y_ptr-, *CDP-, AC1
                MACMR   *y_ptr, *CDP, AC1

; ---- Reload Pointers ----        
; ---- Store ----    
             || MOV     x_save, CDP
                MOV     HI(AC0), *r_ptr+
             || AMOV    y_save, y_ptr
                MOV     HI(AC1), *r_ptr+
             || AADD    #1, y_ptr   
endlocal1:        

; ---- Reload Pointers ----        
        MOV     Xy_orig, Xy_save
        MOV     Xx2_save, Xx_save

;
; Begin Loop for Region 2:                                      
;----------------------------------------------------------------
REGION2:
        
        MOV     Xx_save, Xx_ptr
        MOV     Xy_save, Xy_ptr

        SUB     #3, nx, mac_cnt
        MOV     mac_cnt, CSR

        MOV     ny, T3
        SUB     nx, T3
        MOV     T3, BRC0

        RPTBLOCAL localend2-1
; ---- Setup pointers ----
                ADD     #1, y_save
        
; ---- Preload A ----
                MPYM    *x_ptr+, *y_ptr+, AC0
    
; ---- Main MAC loop  ---- 
             || RPT     CSR
                        MACM     *x_ptr+, *y_ptr+, AC0, AC0

; ---- Cleanup ----
                MACMR   *x_ptr+, *y_ptr+, AC0, AC0
             || MOV     x_save, x_ptr
        
; ---- Setup for subsequent passes through Region 2 ----     
                AMOV    y_save, y_ptr
        
; ---- Store ----      
             || MOV     HI(AC0), *r_ptr+
localend2:        

;
; Begin REGION3 loop:                                           
;----------------------------------------------------------------
REGION3:

        MOV     Xx_save, XCDP
        MOV     Xy_save, Xx_ptr
        MOV     Xx_ptr, Xy_ptr
        ADD     #1, x_ptr, y_ptr

    ; We are re-loading mac_cnt to remove the dependency 
    ; from the region 2 setup code
        SUB     #5, nx, mac_cnt
        MOV     mac_cnt, CSR
        MOV     region1_and_3_loop_cnt, BRC0
        
        RPTBLOCAL localend3-1
                ADD     #2, y_save
; ---- Preload A ----
                MPY     *x_ptr+, *CDP+, AC0 
             :: MPY     *y_ptr+, *CDP+, AC1
; ---- Main Dual MAC loop  ----        
             || RPTSUB  CSR, #2
                        MAC     *x_ptr+, *CDP+, AC0 
                     :: MAC     *y_ptr+, *CDP+, AC1
; ---- Cleanup MAC ----
                MACMR   *y_ptr, *CDP, AC1
                MACM    *x_ptr+, *CDP+, AC0
             || AMOV    y_save, y_ptr
                MACMR   *x_ptr, *CDP, AC0
; ---- Reload Pointers ----        
             || MOV     x_save, CDP
; ---- Store ----    
                MOV     HI(AC0), *r_ptr+
             || AMOV    y_save, x_ptr
                MOV     HI(AC1), *r_ptr+
             || AADD    #1, y_ptr
localend3:        

;
; Calculate last correlation elements outside of loop       
;----------------------------------------------------------------
        BCC     REGION3_FINAL, TC1

; ---- 3 -----
        MPYM    *x_ptr+, *CDP+, AC0 
     || ADD     #1, y_save
        
        MACM    *x_ptr+, *CDP+, AC0
        MACMR   *x_ptr, *CDP, AC0
    
        MOV     Xx_save, XCDP
        MOV     Xy_save, Xx_ptr
        MOV     HI(AC0), *r_ptr+

; ---- 2 -----
REGION3_FINAL:
        MPYM    *x_ptr+, *CDP+, AC0
        MACMR   *x_ptr, *CDP-, AC0
        MOV     HI(AC0), *r_ptr+

; ---- 1 -----
        MPYM    *x_ptr, *CDP, AC0
        MOV     HI(AC0), *r_ptr+
        
;
; Check if overflow occurred, and setup return value
;----------------------------------------------------------------
        MOV     #0, oflag
        XCCPART overflow(AC0)
                || MOV #1, oflag                 ; 
        
        XCCPART overflow(AC1)
                || MOV #1, oflag 

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;        
;
; Deallocate the local frame and argument block
;----------------------------------------------------------------
;
; Restore status regs to expected C-convention values as needed
; Restore any save-on-entry registers that are used
;----------------------------------------------------------------
      
        POPBOTH XAR7
     || BSET    ARMS                        ; set ARMS for C
        POPBOTH XAR6
     || BCLR    #ST1_FRCT, ST1_55           ; clear FRCT for C
        POPBOTH XAR5
        POP     T2, T3
; Return to calling function
;----------------------------------------------------------------
        RET
;----------------------------------------------------------------
;End of file
cubias.asm/     1362765892  0     0     0       15805     `
;/*
; * Copyright (C) 2013 Texas Instruments Incorporated - http://www.ti.com/ 
; * 
; * 
; *  Redistribution and use in source and binary forms, with or without 
; *  modification, are permitted provided that the following conditions 
; *  are met:
; *
; *    Redistributions of source code must retain the above copyright 
; *    notice, this list of conditions and the following disclaimer.
; *
; *    Redistributions in binary form must reproduce the above copyright
; *    notice, this list of conditions and the following disclaimer in the 
; *    documentation and/or other materials provided with the   
; *    distribution.
; *
; *    Neither the name of Texas Instruments Incorporated nor the names of
; *    its contributors may be used to endorse or promote products derived
; *    from this software without specific prior written permission.
; *
; *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
; *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
; *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
; *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
; *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
; *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
; *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
; *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
; *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
; *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
; *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
; *
;*/

;***********************************************************
; Version 3.00.00                                           
;***********************************************************
;****************************************************************
; Function:    corr_unbias
; Description: unbiased full length correlation of two vectors
; Processor:   C55xx
;
; Usage:  ushort corr_unbias  (DATA *x, DATA *y, DATA *r, ushort nx, ushort ny);
;
; Notes:
;   If x[] and y[] are in the same memory block, the function will take twice as many cycles.
;   If x[] is in SARAM instead of DARAM, the function will take significantly more cycles.
;   If y[] is in SARAM instead of DARAM, the function will take significantly more cycles.
;
; Limitations:
;   ny >= nx
;   x[] must be on-chip (i.e. DARAM or SARAM)
;   y[] must be on-chip (i.e. DARAM or SARAM)
;
; Benchmarks:
;   Cycles:
;        Cycle computations are very complicated.
;        For nx and ny = 256:     0.60 * (nx * ny) 
;        For nx and ny = 100:     0.75 * (nx * ny) 
;        For nx and ny = 50:      1.00 * (nx * ny) 
;        For nx and ny = 16:      596
;   Code Size (in bytes):  424
;
; History:
; - Modified save and restore AR5/AR6/AR7 to XAR5/XAR6/XAR7 registers.
;   Li Yuan - 08/14/01
;
; - Fixed bug where T3 was modified but not correctly restored
; - Bug fixed where AC0 and AC1 checked for overflow, but bit not cleared on entry
; - Bug fixed where returned overflow flag was always set to 32 
; - Some optimizations of RPTBLOCAL blocks
;       Craig Leeds - 06/10/2012
;****************************************************************

      .ARMS_off                     ;enable assembler for ARMS=0
      .CPL_on                       ;enable assembler for CPL=1
      .mmregs                       ;enable mem mapped register names
        .global _corr_unbias

; Stack frame
; -----------
RET_ADDR_SZ       .set 1            ;return address
REG_SAVE_SZ       .set 5            ;save-on-entry registers saved (T2, T3, AR5, AR6, AR7)
FRAME_SZ          .set (7+1)        ;local variables
ARG_BLK_SZ        .set 0            ;argument block

; Register usage
; --------------
PARAM_OFFSET    .set   REG_SAVE_SZ + FRAME_SZ

        .asg    0, x_orig
        .asg    2, y_orig
        .asg    4, r_orig
        .asg    6, temp
        
        .asg    "0 + REG_SAVE_SZ + FRAME_SZ", RETURN_ADDR

        .asg    XAR0, Xx_ptr        
        .asg     AR0,  x_ptr
        .asg    XAR1, Xy_ptr
        .asg     AR1,  y_ptr
        .asg    XAR2, Xr_ptr
        .asg     AR2,  r_ptr
        .asg    XAR4, Xx_save
        .asg     AR4,  x_save
        .asg    XAR5, Xy_save        
        .asg     AR5,  y_save
        .asg     AR6,  r1_r3_count
        .asg    XAR7, Xr2_ptr
        .asg     AR7,  r2_ptr
        
        .asg     T0, nx              ;input argument
        .asg     T1, ny              ;input argument
        .asg     T2, mac_cnt
        
        .asg     T0, oflag           ;returned value

        .text
_corr_unbias:

;
; Allocate the local frame and argument block
;
; Save any save-on-entry registers that are used
; Configure the status registers as needed.
;----------------------------------------------------------------
        PSH     T2, T3
     || BCLR    ARMS
        PSHBOTH XAR5
     || BSET    #ST1_FRCT, ST1_55
        PSHBOTH XAR6
        PSHBOTH XAR7
        
        AADD    #-(ARG_BLK_SZ + FRAME_SZ), SP

;---------- X pointer setup    
; x_ptr                -        X pointer as passed
; x_save        -        Used extensively in Region 3 and Region 2
; x_orig        -        Unchanged original X pointer
        MOV     Xx_ptr, dbl(*SP(#x_orig))
        ADD     nx, x_ptr
        SUB     #1, x_ptr
        MOV     Xx_ptr, Xx_save
  
;---------- Y pointer setup    
; y_ptr                -        Y pointer as passed
; y_save        -        Y+nx-2 and Y+nx-1 in Region 3
; y_orig                -        Unchainged original Y pointer
        MOV     Xy_ptr, dbl(*SP(#y_orig))
        MOV     y_ptr, AC0
        ADD     nx, AC0
        SUB     #2, AC0
        MOV     Xy_ptr, Xy_save
        MOV     AC0, y_save

;---------- R pointer setup    
; r_ptr                -        R pointer as passed. Eventually used and initialized as r+nx-2
; r2_ptr        -        r+ny
; r_orig        -        Unchainged original Y pointer
        MOV     Xr_ptr,dbl( *SP(#r_orig))
        MOV     r_ptr, AC0
        MOV     r_ptr, AC1
        ADD     nx, AC1
        SUB     #2, AC1
        MOV     AC1, r_ptr
     || ADD     ny, AC0
        MOV     Xr_ptr, Xr2_ptr
        MOV     AC0, r2_ptr

;
; Initialize MAC cnt for regions 1 & 3, these will be          
; calculated in one loop, since the number of elements is the  
; same in each region.                                         
;----------------------------------------------------------------
        SUB     #4, nx, mac_cnt
        SUB     #1, nx, AC0
        MOV     mac_cnt, r1_r3_count


;+++++++++++ BIAS Calculator +++++++++++++++
; Upon entry:
; r_ptr        =        r+nx-2
; r2_ptr        =        r+ny
; mac_cnt        =        nx-4
; temp                =        nx-1
        MOV     mac_cnt, BRC0 
     || MOV     AC0, *SP(#temp)
                
        BCLR    #ST1_SXMD, ST1_55
                
        MOV     #32767, AC1 
     || RPTBLOCAL biasCalcLocalEnd-1
        
                ;Compute bias value
                SUBC    *SP(#temp), AC1, AC0
             || RPT     #15-1
                        SUBC    *SP(#temp), AC0, AC0
    
                ; Adjust the temp value
                ADD     #-1, *SP(#temp)
        
                ;Store bias value twice into output array
                MOV     AC0, *r_ptr-
             || MOV     AC0, *r2_ptr+
biasCalcLocalEnd:
        
        BSET    #ST1_SXMD, ST1_55
        BCLR    ACOV0                        ; clear overflow bit after division loop
        BCLR    ACOV1                        ; clear overflow bit after division loop
                        
;+++++++++++ End of BIAS calculator +++++++++++++++

; ---- ODD detection ----
; Due to the Dual MAC, we need to know if the region 1 and region 3
; are odd or even in length. If the number is odd, then we will need
; to do an extra MAC outside of the loop.
        BTST    @#0, r1_r3_count, TC1

; For the dual MAC, we need to divide by two followed
; by a subsequent subtraction by 1 only if we have and odd number
; of MAC's to do. 

        SFTL    r1_r3_count, #-1
        XCCPART !TC1
             || SUB     #1, r1_r3_count
        MOV     r1_r3_count, BRC0

        SUB     #4, nx, mac_cnt
        
    
; Initial lag is in region 1, load initial MAC count and      
; number of elements to calculate in region 1                 
;----------------------------------------------------------------

REGION1_AND_3:

; ---- Pointer Setup ----
        MOV     Xy_save, Xy_ptr
        MOV     Xy_ptr, Xx_ptr
        SUB     #1, y_ptr, x_ptr
        MOV     Xx_save, XCDP
            
        MOV     mac_cnt, CSR

        ;Reset r_ptr to initial values
        MOV     dbl(*SP(#r_orig)), AC1
        ADD     nx, AC1
        SUB     #2, AC1
        MOV     AC1, Xr_ptr
        SUB     #(2+1), y_save

;--------- Calculate sum in region 1  

     || RPTBLOCAL endlocal1-1
    
; ---- Preload AC0 ----
                MPY     *x_ptr-, *CDP-, AC0 
             :: MPY     *y_ptr-, *CDP-, AC1
        
; ---- Main Dual MAC loop  ----         
             || RPTSUB  CSR, #2
                        MAC     *x_ptr-, *CDP-, AC0
                     :: MAC     *y_ptr-, *CDP-, AC1
                
; ---- Cleanup MAC ----
                MACM    *y_ptr, *CDP, AC1
    
; ---- BIAS AC0 and AC1 and Store ----        
                MPYMR   *r_ptr, AC1, AC1
             || MOV     x_save, CDP
                AMOV    y_save, x_ptr
             || MOV     HI(AC1), *r_ptr-
                MPYMR   *r_ptr, AC0, AC0
                AMAR    *y_save(#1), Xy_ptr
                MOV     HI(AC0), *r_ptr-
             || SUB     #2, y_save
endlocal1:        
; ---- Setup for Region 1 ----       

;---------- Calculate some MAC's outside of the loop
        ADD     #(2+1), y_save
     || BCC     REGION1_FINAL, TC1
        
; ---- 3 -----        
        MPYM    *y_ptr-, *CDP-, AC0
        MACM    *y_ptr-, *CDP-, AC0
        MACM    *y_ptr, *CDP, AC0
        
        MOV     Xx_save, XCDP
        SUB     #1, y_save
        MOV     Xy_save, Xy_ptr
        ; BIAS
        MPYMR   *r_ptr, AC0, AC0        
        
        MOV     HI(AC0), *r_ptr-
        
        ; Setup pointers for next loop


; ---- 2 -----        
REGION1_FINAL:
        MPYM    *y_ptr-, *CDP-, AC0
        MACMR   *y_ptr, *CDP+, AC0
        MOV     HI(AC0 << #-1), *r_ptr-

; ---- 1 -----        
        MPYM    *y_ptr, *CDP, AC0
        MOV     HI(AC0), *r_ptr-

;--------- Calculate sum in region 3                              
        MOV     r1_r3_count, BRC0
        MOV     mac_cnt, CSR

; ---- Pointer Setup ----
        MOV     dbl(*SP(#y_orig)), AC1
        ADD     ny, AC1
        SUB     #1, AC1
        MOV     AC1, Xy_save
        MOV     Xy_save, XCDP

        ; Compute x_save=X+nx-2
        MOV     dbl(*SP(#x_orig)), Xx_save
        ADD     nx, x_save
        SUB     #3, x_save

        MOV     Xx_save, Xy_ptr
        MOV     Xx_save, Xx_ptr
        ADD     #1, y_ptr
        
        ;Reset r2_ptr to initial values
        MOV     dbl(*SP(#r_orig)), AC0
        ADD     ny, AC0
        MOV     AC0, Xr2_ptr

        SUB     #2, x_save
     || RPTBLOCAL localend3-1
        
; ---- Preload AC0 ----
                MPY     *x_ptr-, *CDP-, AC0 
             :: MPY     *y_ptr-, *CDP-, AC1
        
; ---- Main  Dual MAC loop  ----         
             || RPTSUB  CSR, #2
                        MAC     *x_ptr-, *CDP-, AC0 
                     :: MAC     *y_ptr-, *CDP-, AC1

; ---- Cleanup MAC ----
                MACM    *y_ptr, *CDP, AC1
             || MOV     y_save, CDP
        
; ---- BIAS AC0 and AC1 and Store ----        
                MPYMR   *r2_ptr+, AC1, AC1
             || MOV     x_save, x_ptr
                AMAR    *x_save(1), Xy_ptr
                MPYMR   *r2_ptr-, AC0, AC0
                MOV     HI(AC1), *r2_ptr+
                MOV     HI(AC0), *r2_ptr+
             || SUB     #2, x_save
localend3:        

; ---- Setup for Region 3 ----     

; ---- 3 -----        
        ADD     #2, x_save
     || BCC REGION3_FINAL, TC1
        
        ; no need for division since the previous one did it for me already
        
        ; MACs
        MPYM    *y_ptr-, *CDP-, AC0
        MACM    *y_ptr-, *CDP-, AC0
        MACM    *y_ptr, *CDP, AC0
        
                
        ; BIAS
        MPYMR   *r2_ptr, AC0, AC0        
        
        MOV     HI(AC0), *r2_ptr+
         
        ; Setup pointers for next loop
        MOV     Xx_save, XCDP
        MOV     Xy_save, Xy_ptr

; ---- 2 -----        
REGION3_FINAL:
        MPYM    *y_ptr-, *CDP-, AC0
        MACMR   *y_ptr+, *CDP, AC0
        MOV     HI(AC0 << #-1), *r2_ptr+
        
; ---- 1 -----        
        XCC     TC1
             || AMAR    *y_ptr-, *AR7, *cdp+

        MPYM    *y_ptr, *CDP, AC0
        MOV     HI(AC0), *r2_ptr

;--------- Calculate sum in region 2
; ---- BIAS calculation -----        
        BCLR    #ST1_SXMD, ST1_55
        
        ; Actual calculation
        MOV     #32767, AC0
        MOV     nx, *SP(#temp)
     || RPT     #16-1
                SUBC    *SP(#temp), AC0, AC0
        ADD     #1, AC0
        BSET    #ST1_SXMD, ST1_55
        MOV     AC0, *SP(#temp)
        

REGION2:
        ; Repeat setup
        MOV     ny, AC0
        SUB     nx, AC0
        MOV     AC0, T3
        MOV     T3, BRC0
        SUB     #2, nx, mac_cnt
         
        ; R pointer setup
        MOV     nx, AC1
        SUB     #1, AC1
        ADD     dbl(*SP(#r_orig)), AC1
        MOV     AC1, Xr_ptr

        ; Setup pointers
        MOV     dbl(*SP(#y_orig)), Xy_save
        MOV     dbl(*SP(#x_orig)), Xx_save
        MOV     Xx_save, XCDP
        MOV     Xy_save, Xy_ptr
        MOV     mac_cnt, CSR
        MOV     *SP(#temp), T3
        
        RPTBLOCAL r2localloop-1

; ---- Setup pointers ----
                ADD     #1, y_save

; ---- Preload AC0 ----
                MPYM    *y_ptr+, *CDP+, AC0 

; ---- Main MAC loop  ---- 
             || RPT     CSR
                        MACM *y_ptr+, *CDP+, AC0

; ---- Setup for subsequent passes through Region 2 ----     
                MOV     Xx_save, XCDP

; ---- BIAS ----
                MPYR    T3, AC0, AC0
             || AMOV    y_save, y_ptr
        
; ---- Store ----      
                MOV     HI(AC0), *r_ptr+
r2localloop:


; Check if overflow occurred, and setup return value
;----------------------------------------------------------------
        MOV     #0, oflag
        XCCPART overflow(AC0)
             || MOV     #1, oflag 
        XCCPART overflow(AC1)
             || MOV     #1, oflag 
;
; Restore status regs to expected C-convention values as needed
; Restore any save-on-entry registers that are used
;----------------------------------------------------------------
; Deallocate the local frame and argument block
;----------------------------------------------------------------
        AADD    #+(ARG_BLK_SZ + FRAME_SZ), SP
        POPBOTH XAR7
     || BSET    ARMS
        POPBOTH XAR6
     || BCLR    FRCT
        POPBOTH XAR5
        POP     T2, T3
;
; Return to calling function
;----------------------------------------------------------------
        RET
;----------------------------------------------------------------
;End of file

decimate.asm/   1362765892  0     0     0       9280      `
;/*
; * Copyright (C) 2013 Texas Instruments Incorporated - http://www.ti.com/ 
; * 
; * 
; *  Redistribution and use in source and binary forms, with or without 
; *  modification, are permitted provided that the following conditions 
; *  are met:
; *
; *    Redistributions of source code must retain the above copyright 
; *    notice, this list of conditions and the following disclaimer.
; *
; *    Redistributions in binary form must reproduce the above copyright
; *    notice, this list of conditions and the following disclaimer in the 
; *    documentation and/or other materials provided with the   
; *    distribution.
; *
; *    Neither the name of Texas Instruments Incorporated nor the names of
; *    its contributors may be used to endorse or promote products derived
; *    from this software without specific prior written permission.
; *
; *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
; *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
; *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
; *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
; *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
; *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
; *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
; *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
; *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
; *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
; *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
; *
;*/

;***********************************************************
; Version 3.00.00                                           
;***********************************************************
; Function:    firdec
; Processor:   C55xx
; Description: Decimation filter with user specified FIR coefficients
;
;					
; Usage:   ushort firdec(DATA *x,	XAR0 
;			DATA *h,	XAR1 
;			DATA *r,	XAR2
;			DATA *dbuffer,	XAR3 
;			ushort nh,	T0 
;			ushort nx,	T1 
;			ushort D);	XAR4
;
; Benchmarks:
;   Cycles:       ((nx/D) * (nh + D + 9)) + 64
;   Code Size (in bytes):  139
;
; History:
;  Craig Leeds 06/15/2012  3.00.00:
;    Clean up housekeeping
;
;****************************************************************

	.ARMS_off		;enable assembler for ARMS=0
	.CPL_on			;enable assembler for CPL=1
	.mmregs			;enable mem mapped register names

; Stack frame
; -----------
RET_ADDR_SZ	.set	1	;return address
REG_SAVE_SZ	.set	1	;save-on-entry registers saved
FRAME_SZ	.set	0	;local variables
ARG_BLK_SZ	.set	0	;argument block

PARAM_OFFSET	.set	ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ + RET_ADDR_SZ


; Register usage
; --------------
	.asg	AR0, x_ptr	;linear pointer
	.asg	AR1, h_ptr	;circular pointer
	.asg	AR2, r_ptr	;linear pointer
	.asg	AR4, db_ptr	;circular pointer

	.asg	BSA01, h_base	;base addr for h_ptr
	.asg	BK03, h_sz	;circ buffer size for h_sz
	.asg	BSA45, db_base	;base addr for db_ptr
	.asg	XAR4, xdb_base	;extended base addr for db_ptr
	.asg	BK47, db_sz	;circ buffer size for db_ptr
	.asg	BK47_L, db_sz_L	;for memory mapped access

	.asg	CSR, inner_cnt	;inner loop count
	.asg	BRC0, outer_cnt	;outer loop count

	.asg	T0, oflag	;returned value
	.asg	T2, DecFac	;decimation factor

ST2mask	.set	0000000000010010b	;circular/linear pointers (AR1LC, AR4LC)


	.global	_firdec

	.text
_firdec:

;
; Allocate the local frame and argument block
;----------------------------------------------------------------
;      SP = SP - #(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ)
; - not necessary for this function (the above is zero)

;
; Save any save-on-entry registers that are used
;----------------------------------------------------------------
; - nothing to save for this function

;
; Configure the status registers as needed.
;----------------------------------------------------------------
        PSH     T2
     || BCLR    ARMS
        BSET    FRCT
        BCLR    SMUL
        BCLR    ACOV0
;
; Setup passed parameters in their destination registers
; Setup circular/linear CDP/ARx behavior
;----------------------------------------------------------------

; x pointer - passed in its destination register, need do nothing

; h pointer
        MOV     AR1, mmap(h_base)          ;base address of coefficients
        MOV     #0,h_ptr                   ;point to first coefficient
        MOV     T0, mmap(h_sz)             ;coefficient array size h_sz = nh

; r pointer - already passed in its destination register

; db pointer
        MOV     AR4,DecFac                 ;save DecFac = D
        MOV     XAR3,xdb_base              ;db array address
        MOV     *AR3+,db_ptr               ;index of oldest db entry
        MOV     AR3, mmap(db_base)         ;base address for db_ptr
        MOV     T0, mmap(db_sz)            ;db_sz = nh

; Set circular/linear ARx behavior (AR1, AR4)
        BSET    AR1LC
        BSET    AR4LC

;
; Setup loop counts
;----------------------------------------------------------------
        BCLR    SXM
        MOV     T1,AC0                     ;AC0 = nx
        ||RPT   #(16-1)
                SUBC    mmap(DecFac),AC0                
        SUB     #1,AC0                     ;
        MOV     AC0, mmap(outer_cnt)       ;outer_cnt = (nx/D)-1
        BSET    SXM
        
        SUB     #3, T0                     ;setup reload for FIR taps inner_cnt = nh-3
        SUB     #2, DecFac                 ;setup reload for sample-to-db inner_cnt = D-2
        
        BCC     DecimateLoop, DecFac >= #0        
        
;
; Start of outer loop  D=1
;----------------------------------------------------------------
        MOV     T0,inner_cnt                     ;inner_cnt = nh-3 (2 iter outside loop)
        RPTBLOCAL NoDecimLoopEnd-1               ;start the outer loop
        
                ;move next input value into delay buffer
                MOV     *x_ptr+, *db_ptr                

                ;Sum h*x nh-iterations for next r value
                MPYM    *db_ptr+, *h_ptr+,AC0      
              ||RPT     inner_cnt
                        MACM    *db_ptr+, *h_ptr+, AC0, AC0
                MACMR   *db_ptr, *h_ptr+, AC0, AC0

                ;store result to memory
                MOV     HI(AC0), *r_ptr+         ;store Q15 value to memory
NoDecimLoopEnd:                                  ;end of outer loop
        B       FirDecDone                       ;goto exit procedure
;
;
; Start of outer loop  D>=2
;----------------------------------------------------------------

DecimateLoop:
        RPTBLOCAL DecimLoopEnd-1            ;outer loop (nx/D) iterations
        
                MOV     T0, inner_cnt       ;inner_cnt = nh-3 (2 iter outside loop)
                ;move next input value into delay buffer
                MOV     *x_ptr+, *db_ptr

                ;Sum h*x nh-iterations for next r value
                MPYM    *db_ptr+, *h_ptr+, AC0      
             || RPT     inner_cnt           ; Pipe 1 of 3 from MOV inner_cnt
                        MACM    *db_ptr+, *h_ptr+, AC0, AC0
                MOV     DecFac, inner_cnt   ;inner_cnt = D-2
                MACMR   *db_ptr, *h_ptr+, AC0, AC0

                ;store result to memory
                MOV     HI(AC0), *r_ptr+    ;store Q15 value to memory
        
                ;Move next D-1 input samples into delay buffer
             || RPT     inner_cnt           ; Pipe 1 of 3 from MOV inner_cnt
                        MOV     *x_ptr+, *db_ptr-
DecimLoopEnd:                               ;end of outer loop

; Update the db entry point
;----------------------------------------------------------------
FirDecDone:
        BCLR    AR1LC
        BCLR    AR4LC
        MOV     db_ptr, *-AR3               ;update 1st element of db array
;
; Check if overflow occurred, and setup return value
;----------------------------------------------------------------
      ||MOV     #0, oflag                   ;clear oflag
        XCCPART overflow(AC0)               ;clears ACOV0
              ||MOV     #1, oflag           ;overflow occurred

;
; Restore status regs to expected C-convention values as needed
;----------------------------------------------------------------
;
; Restore any save-on-entry registers that are used
;----------------------------------------------------------------
; - nothing to restore for this function
;
; Deallocate the local frame and argument block
;----------------------------------------------------------------
;      SP = SP + #(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ)
; - not necessary for this function (the above is zero)
;
; Return to calling function
;----------------------------------------------------------------

        BSET    SMUL
        POP     T2
      ||BSET    ARMS
        RET                                 ;return to calling function
      ||BCLR    FRCT

;----------------------------------------------------------------
;End of file
        .end
DLMS.asm/       1362765892  0     0     0       8773      `
;/*
; * Copyright (C) 2013 Texas Instruments Incorporated - http://www.ti.com/ 
; * 
; * 
; *  Redistribution and use in source and binary forms, with or without 
; *  modification, are permitted provided that the following conditions 
; *  are met:
; *
; *    Redistributions of source code must retain the above copyright 
; *    notice, this list of conditions and the following disclaimer.
; *
; *    Redistributions in binary form must reproduce the above copyright
; *    notice, this list of conditions and the following disclaimer in the 
; *    documentation and/or other materials provided with the   
; *    distribution.
; *
; *    Neither the name of Texas Instruments Incorporated nor the names of
; *    its contributors may be used to endorse or promote products derived
; *    from this software without specific prior written permission.
; *
; *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
; *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
; *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
; *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
; *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
; *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
; *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
; *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
; *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
; *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
; *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
; *
;*/

;***********************************************************
; Version 3.00.00                                           
;***********************************************************
; Function:	dlms
; Processor:   C55xx
; Description: dlms fir filter
;
; Usage: short oflag = dlms(DATA *h, DATA *x, DATA *r, DATA *des,
;                           DATA *dbuffer, DATA step, ushort nh, ushort nx)
;
; ...where
;	h[nh]		Pointer to coefficient vector of size nh
;			- h is stored in reverse order: h(n-1), ... h(0)
;	x[nx]		Pointer to input vector of size nx
;	r[xn]		Pointer to output data vector.
;			- r can be equal to x
;	des[nx]		Pointer to expected-output array
;	dbuffer[nh+2]	Pointer to delay buffer structure
;			- first element of structure is index into array
;			  of OLDEST data (to be overwritten with new)
;			- remaining elements are modulo-addressed for
;			  sample 0 to nh. NOTE that this delay buffer
;			  yields an array length of nh+1, which is used
;			  for Dual-MAC operations(not used here).
;	step		Scale factor to control adaptation rate = 2*mu
;	nh		Number of filter coefficients. Filter order = nh-1.
;	nx		Number of input samples to process (length of input
;			and output data vectors).
;	oflag	Overflow Flag
;			- If oflag = 1, a 32-bit overflow has occured
;			- If oflag = 0, a 32-bit overflow has not occured
;
; Benchmarks:
;   Cycles:       
;     nh =  21:  nx = 128:    6056
;     nh =  12:  nx = 100:    2940
;     nh =  32:  nx =  64:    4456
;     nh =  21:  nx =  40:    1920
;     nh =   3:  nx =  32:     392
;     nh =  12:  nx =  20:     620
;     nh =   3:  nx =   3:      74
;   Code Size (in bytes):  353
;
; History:
; 2.10	Rishi  08/03/2001 - optimized the code for benchmark.
; 3.00  Craig Leeds 06/15/2012 - Fixed bug where AR5H not set
;****************************************************************
        .cpl_on
        .arms_off
        .noremark 5684   ; BRC1 not modified indirectly

      .asg      0, save_T3      ; pushed on stack
      .asg      1, save_T2      ; pushed on stack
      .asg      2, save_AR5     ; pushed on stack
      .asg      3, ret_addr     ; return address on stack from CALL
      .asg      4, arg_nx       ; argument on stack

; register usage
;      XAR0-XAR4, T0 & T1 as well as accumulators are all available to callee
;      XAR0 through XAR4 are already loaded with *x, *h, *r, *des and *dbuffer
;       respectively upon entry.
;      While T0 and T1 are loaded with the values of STEP and NH, respectively

      .asg      AR0, ar_input
      .asg      AR1, ar_coef
      .asg      AR2, ar_output
      .asg      AR3, ar_des
      .asg      AR4, ar_dbuffer
      .asg      AR5, ar_data
      .asg      T0,  T_step
      .asg      T1,  T_nh

;*****************************************************************************
      .def      _dlms

        .text
_dlms:

; Preserve registers
;-------------------
      PSH  T3, T2                   
   || BCLR ARMS                       ;disable ARMS bit in ST2
      PSHBOTH XAR5                    ;AR5 will be used for the index into dbuffer
   || BSET FRCT
;
; Set math and overflow modes
;---------------------------
; Status registers
      MOV  XAR4, XAR5
      BCLR ACOV1
      BSET AR1LC                     ;AR1 pointer put in circular mode
      BSET AR5LC                     ;AR5 pointer put in circular mode
;
; Get arguments
;---------------
      MOV  *ar_dbuffer+, ar_data      ;set AR5 to index in data array
                                      ; of oldest input sample
      MOV  AR4, mmap(BSA45)           ;set BSA45 to start of data buffer
                                      ; NOTE that this is the SECOND
                                      ; element of the dbuffer structure
      MOV  AR1, mmap(BSA01)           ;copy start of coeffs to BSA01
      MOV  #0, ar_coef                ;...then set AR0 to zero (1st coeff)
      ADD  #-1, *SP(arg_nx)           ;sub 1 from # of inputs for loopcount
      MOV  *SP(arg_nx), BRC0          ;set outer loop to number of inputs-1
      MOV  T_nh, mmap(BK03)           ;load BK03 with # of coeffs for use w/ AR2
      AADD #1, T_nh
      MOV  T_nh, mmap(BK47)           ;load BK03 with # of data samples (nh+1)
                                      ; in delay-line for use w/ AR4
      ASUB #3, T_nh
      MOV  T_nh, BRC1                 ;set inner loop to number of coeffs-2

; Loop through input data stream
;-------------------------------
      MOV  #0, AC3                    ;clear AC3 for initial error term
   || RPTBLOCAL OuterLoopEnd-1        ;...while starting outer loop
             MOV  *ar_input+, *ar_data+          ;copy input -> state(0) 
             MPYM *ar_data+, AC3, AC0            ;place first update term in AC0 
          || MOV  #0, AC1                        ;...while clearing FIR value
             LMS  *ar_coef, *ar_data, AC0, AC1   ;AC0 = update coef
                                                 ;AC1 = start of FIR output
          || RPTBLOCAL InnerLoopEnd-1            ;...while starting inner loop
                    MOV  HI(AC0), *ar_coef+            ;store updated coef
                 || MPYM *ar_data+, AC3, AC0            ;...while calculating next update term
                    LMS  *ar_coef, *ar_data, AC0, AC1  ;AC0 = update coef
InnerLoopEnd:
                                                 ;AC1 = update of FIR output
             MOV  HI(AC0), *ar_coef+             ;store updated coef
          || MOV  rnd(HI(AC1)), *ar_output+      ;...and store FIR output

             SUB  AC1, *ar_des+ << #16, AC2      ;AC2 is error amount
          || AMAR *ar_data+                      ;point to oldest data sample
             MPYR T_step, AC2, AC3               ;place updated mu_error term in AC3
OuterLoopEnd:

      MOV  ar_data, *-ar_dbuffer      ;dbuffer.index = index of oldest data

; Return overflow flag
; --------------------
   || MOV  #0, T0                     ;store zero for return value
      XCCPART overflow(AC1)
            || MOV  #1, T0            ;return value 1 if overflow was encountered

;
; Restore stack to previous value
; Reset status regs to restore normal C operating environment
; Return to calling function
;----------------------------------------------------------------

;NO presumed values in ST0 by C-environment

      BCLR AR1LC                     ;AR1 pointer restored to linear mode
      POPBOTH XAR5
   || BCLR AR5LC                     ;AR5 pointer restored to linear mode
      POP  T3, T2
   || BSET ARMS                       ;set ARMS bit for C-environment

;No presumed values of ST3 were modified

      RET                             ;return to calling function
   || BCLR FRCT                       ;clear FRCT bit in ST1 for C-environment

        .end

;end of file. please do not remove. it is left here to ensure that no lines of code are removed by any editor

dlmsfast.asm/   1364913716  0     0     0       19973     `
;/*
; * Copyright (C) 2013 Texas Instruments Incorporated - http://www.ti.com/ 
; * 
; * 
; *  Redistribution and use in source and binary forms, with or without 
; *  modification, are permitted provided that the following conditions 
; *  are met:
; *
; *    Redistributions of source code must retain the above copyright 
; *    notice, this list of conditions and the following disclaimer.
; *
; *    Redistributions in binary form must reproduce the above copyright
; *    notice, this list of conditions and the following disclaimer in the 
; *    documentation and/or other materials provided with the   
; *    distribution.
; *
; *    Neither the name of Texas Instruments Incorporated nor the names of
; *    its contributors may be used to endorse or promote products derived
; *    from this software without specific prior written permission.
; *
; *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
; *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
; *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
; *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
; *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
; *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
; *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
; *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
; *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
; *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
; *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
; *
;*/

;***********************************************************
; Version 3.00.00                                           
;***********************************************************
; Function:	dlms
; Processor:   C55xx
; Description: dlms fir filter
;
; Usage: short oflag = dlmsfast(DATA *h, DATA *x, DATA *r, DATA *des,
;			        DATA *dbuffer, DATA step, ushort nh, ushort nx)
;
; ...where
;	h[2nh]		Pointer to coefficient vector of size nh
;			- h is stored in reverse order: h(n-1), ... h(0)
;	x[nx]		Pointer to input vector of size nx
;	r[xn]		Pointer to output data vector.
;			- r can be equal to x
;	des[nx]		Pointer to expected-output array
;	dbuffer[nh+3]	Pointer to delay buffer structure
;			- first element of structure is index into array
;			  of OLDEST data (to be overwritten with new)
;			- remaining elements are modulo-addressed for
;			  sample 0 to nh+1. NOTE that this delay buffer
;			  yields an array length of nh+1, which is used
;			  for Dual-MAC operations(not used here).
;	step		Scale factor to control adaptation rate = 2*mu
;	nh		Number of filter coefficients. Filter order = nh-1.
;	nx		Number of input samples to process (length of input
;			and output data vectors).
;	oflag	Overflow Flag
;			- If oflag = 1, a 32-bit overflow has occured
;			- If oflag = 0, a 32-bit overflow has not occured
;
; Benchmarks:
;   Cycles:       
;     nh =  12:  nx = 100:    3766
;     nh =  32:  nx =  64:    4354
;     nh =  10:  nx =  50:    1766
;     nh =  12:  nx =  20:     806
;   Code Size (in bytes):  304
;
; History:
;  2.10	Rishi  08/03/2001 - optimized the code for benchmark.
;  3.00  Craig Leeds 06/15/2012 
;    - fix bug where AR6H and AR7H not set
;    - fix bug where DP was modified and not restored
;    - move .bss usage to stack
;
;****************************************************************

        .cpl_on
        .ARMS_off

	.asg    0, err
	.asg    1, index_filt
	.asg	2, filler              ; for alignment of stack
	.asg	3, save_AR7
	.asg	4, save_AR6		
	.asg	5, save_AR5
	.asg	6, save_T3		; 2*mu*error(i) variable
	.asg	7, ret_addr
	.asg    8, arg_nx               ; argument on stack
	
;//-----------------------------------------------------------------------------
;// Temp data
;//-----------------------------------------------------------------------------

; register usage
;	XAR0-XAR4, T0 & T1 as well as accumulators are all available to callee
;	XAR0 through XAR5 are already loaded with *x, *h, *r, *des and *dbuffer
;	 respectively upon entry.
;	While T0 and T1 are loaded with the values of STEP and NH, respectively

	.asg	 AR0, ar_input
	.asg	 AR1, ar_coef
	.asg	 AR2, ar_scratch
	.asg	 AR3, ar_des
	.asg	 AR4, ar_dbuffer
	.asg     AR5, ar_output
	.asg	 AR6, ar_data1
	.asg	 AR7, ar_data2
	.asg	XAR4, Xar_dbuffer
	.asg	XAR6, Xar_data1
	.asg	XAR7, Xar_data2
	.asg	  T3, T_step
	.asg	  T1, T_nh

;*****************************************************************************
	.def	_dlmsfast
	
	
	; Stack frame
; -----------
RET_ADDR_SZ       .set 1            ;return address
REG_SAVE_SZ       .set 4            ;save-on-entry registers saved (T3, AR5, AR6, AR7)
FRAME_SZ          .set 3            ;local variables
ARG_BLK_SZ        .set 0            ;argument block

PARAM_OFFSET      .set ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ + RET_ADDR_SZ
	

        .text
_dlmsfast:


; Preserve registers
;-------------------
    PSH T3                                      ;T3 is needed for LMS instruction
  ||BCLR ARMS                                   ;disable ARMS bit in ST2
    PSHBOTH XAR5				;AR5 will be used for the index into dbuffer
  ||BSET FRCT                                   ;
    PSHBOTH XAR6				;AR6 and AR7 are used in this function
  ||BCLR SST                                    ;make sure Saturate-on-STore bit in ST3 is disabled
    PSHBOTH XAR7				;AR6 and AR7 are used in this function
  ||BCLR ACOV0                                  ;clear AC0 overflow bit so that it can be tested at end
    BCLR ACOV1                                  ;clear AC1 overflow bit so that it can be tested at end
;
; Allocate the local frame and argument block
;----------------------------------------------------------------
  ||AADD	#-(FRAME_SZ + ARG_BLK_SZ), SP
; - one local variable


; Set math and overflow modes
;---------------------------
; Status registers
    OR  #0x00C6, mmap(ST2_55)                           ;AR1, AR2, AR6, & AR7 pointers put in circular mode
;
; Get arguments
;---------------

    MOV XAR2, XAR5;                                     ;XAR5 set to ar_output
    MOV Xar_dbuffer, Xar_data1                          ;set AR6H 
    MOV Xar_dbuffer, Xar_data2                          ;set AR7H 
    MOV T0, T_step

; NOTE!!!  the index value saved points to the oldest value:
; EXample: if we need to update x(-16) and X(-15) it will point to X(-16) 

    MOV *ar_dbuffer, ar_data2                           ;set AR6 to index in data array
                                                        ; of oldest input sample
    MOV *ar_dbuffer+, ar_data1							
							
	 
;***** Delay buffer ********
;       
;   |          |     
;   | x(0)     | <------ ar_data1 
;   | x(1)     | <------ ar_data2
;   | x(-N)	   |
;   | x(-(N-1))|
;   | .....    |
;   | x(-2)    |  
;   | x(-1)    |    
	
								
    MOV ar_dbuffer, mmap(BSA67)                         ;set BSA67 to start of data buffer
                                                        ; NOTE that this is the SECOND
                                                        ; element of the dbuffer structure

    ; initialize delay buffer CDP pointer	
    MOV ar_dbuffer, mmap(BSAC)
																											
    MOV T_nh, T0      
    AADD  AR1, T0 								
    MOV T0, mmap(BSA23)                                 ; BSA scratch = BSA coeff + NH
    MOV #0, ar_scratch				
								
    MOV AR1, mmap(BSA01)                                ;copy start of coeffs to BSA01
    MOV #0, ar_coef                                     ;...then set AR0 to zero (1st coeff)
	
	
    ; initialize counter for Coef update loop
    MOV  T1, T0
    SFTS T0, #-1                                        ;T0 = nh/2
    SUB	 #5, T0                                         ;T0 = (nh/2 - 2 - 3) => (-3) is for inner loop unroll
    MOV T0, BRC1                                        ; BRC1 = coef_cntr
	
    ; initialize counter for Filter loop
    MOV  T1, T0
    SUB  #2, T0                                         ;T0 = (nh - 2 - 4) => 4 is for unrolls
    MOV  T0, CSR                                        ; CSR = filt_cntr
	
    ;initialize the error 
    AMOV XSP, XCDP	                                ; CDP = &err (on stack)
    MOV  T_nh, mmap(BK03)                               ;load BK03 with # of coeffs for use w/ AR2
    ADD  #2, T_nh
    MOV  T_nh, mmap(BK47)                               ;load BK47 with # of data samples (nh+2)
                                                        ;in delay-line for use w/ AR6,7
    MOV  T_nh, mmap(BKC)

 .if (err != 0)
    AMAR *+CDP(#err)                                    ; CDP = &err (on stack)
 .endif
															
    MOV *SP(arg_nx), T0
    SFTS T0, #-1
    SUB #1, T0
    MOV T0, BRC0                                  ;BRC0 = nx/2 -1

    MOV  #0,*CDP 	                                    ;Set initial error is 0
    MOV  #5, T1		                                    ;circular buffer pointer wrap
    MOV  #2, T0

    MOV  *ar_input+, *ar_data2+                          ;update the two oldest values 
    MOV  *ar_input+, *(ar_data2+T0) 
    AMAR *(ar_data1+T0)

    MOV  ar_data2, *SP(index_filt)	
				

;  First Coefficient update stage
;  ------------------------------
;  Update Coefficients from the previous error e(n-1)
;
;   The coefficients h and h' are stored in reversed order: h(n-1)... h(0) where
;	h(n) is at the lowest memory address. 
;
;  AR6 ---> h
;  AR7 ---> h'
;  AR1 ---> x[n-(N-(2*k))]
;  AR3 ---> x[n-(N-(2*k+1))]
;  CDP ---> e(n-1)
;  T0 = #2
;  BRC1 = NH/2 -2
; 

; 21 = 15AD + 6IBQ stalls in the LOOP

;***** Filter coefficients buffer ********
;
;   | h(N-1)  | <------ ar_coef
;   |  .....  |
;   | h(0)    |
;   | h'(N-1) | <------ ar_scratch
;   |  .....  |
;   |  h'(0)  |  

;***** Delay buffer ********
;                      
;   | x(0)     | 
;   | x(1)     | 
;   | x(-N)	   | <------ ar_data1
;   | x(-(N-1))| <------ ar_data2
;   | .....    |
;   | x(-2)    |  
;   | x(-1)    | 

    RPTB #(ext_loop-1)

        MOV   dbl(*(ar_coef+T0)), PAIR(HI(AC0))

        ; Following 3 unrolls for BRC1 set up 4 cycles before rptb
        
        MACR  *(ar_data1+T0),*CDP,AC0    			
        :: MACR  *(ar_data2+T0),*CDP,AC1    		
        MOV   PAIR(HI(AC0)),dbl(*(ar_scratch+T0)) 	
     || MOV   dbl(*(ar_coef+T0)), PAIR(HI(AC0))	


        MACR  *(ar_data1+T0),*CDP,AC0    			
        :: MACR  *(ar_data2+T0),*CDP,AC1    		
        MOV   PAIR(HI(AC0)),dbl(*(ar_scratch+T0)) 	
        || MOV   dbl(*(ar_coef+T0)), PAIR(HI(AC0))	

        MACR  *(ar_data1+T0),*CDP,AC0    			
        :: MACR  *(ar_data2+T0),*CDP,AC1    		
        MOV   PAIR(HI(AC0)),dbl(*(ar_scratch+T0)) 	
     || MOV   dbl(*(ar_coef+T0)), PAIR(HI(AC0))	
        

        RPTBLOCAL   #(coef_updt1 -1)                ; 2 stalls 	; segment update loop       
            MACR  *(ar_data1+T0),*CDP,AC0    			; AC0=AC0+2^15+en*x[n-(N-(2*k))]
            :: MACR  *(ar_data2+T0),*CDP,AC1    		; AC1=AC1+2^15+en*x[n-(N-(2*k+1))]
            MOV   PAIR(HI(AC0)),dbl(*(ar_scratch+T0)) 		; h'(N-1-(2*k)) = HIGH(AC0)
         || MOV   dbl(*(ar_coef+T0)), PAIR(HI(AC0))	        ; h'(N-1-(2*k+1)) = HIGH(AC1)
                                                                ; HI(AC0) = h[N-(2*k+2)]
                                                                ; HI(AC0) = h[N-(2*k+2+1)]
        ; 1 stall in rptblocal loop after 1st iteration                                         
coef_updt1:    

        ; modify arr_data1 and ar_data2 pointing to the correct position      
        MACR  *(ar_data1+T1),*CDP,AC0      			; AC0=AC0+2^15+en*x[n-1]
        ::MACR  *(ar_data2+T1),*CDP,AC1      			; AC1=AC1+2^15+en*x[n-2]
        MOV   PAIR(HI(AC0)),dbl(*(ar_scratch+T0)) 	        ; h'[0] = HIGH(AC0)
                                                                ; h'[1] = HIGH(AC1)

;   Filtering stage
;	----------------
;	Two filters are processes in parallel using the dual MAC instruction.
;   The filter coefficients are stored in the buffers h[n](k) and h[n+1](k).
;   (n is the time index and k is the coefficient index)
;   We will use the following notations:
;								h(k)  = h[i](k) 
;								h'(k) = h[i+1](k)
;
;   Equations:
;   ----------
;   y(i)   =            h(0) x(i-1)+h(1)(1)x(i-2)+ ... +h(N-2)x(i-(N-1))+h(N-1)x(i-N)
;   y(i+1) = h'(0)x(i)+ h'(1)x(i-1)+       ...         +h'(N-1)x(i-(N-1)
;
;   Implementation:
;	---------------
;   Head and tail are computed using single MAC, all the other mpys are 
;   implemented using dual MAC.
;
;   The coefficients h and h' are stored in reversed order: h(n-1)... h(0) where
;	h(n) is at the lowest memory address.
;
;   CDP ---> db , circular
;   AR6 ---> h
;   AR7 ---> h'  
;
;
;***** Filter coefficients buffer ********
;
;   | h(N-1)  | <------ ar_coef
;   |  .....  |
;   |  h(0)   |
;   | h'(N-1) | <------ ar_scratch
;   |  .....  |
;   |  h'(0)  |  

;***** Delay buffer ********
;                      
;   | x(0)     | 
;   | x(1)     | 
;   | x(-N)	   |
;   | x(-(N-1))|
;   | x(-(N-2))| <------ CDP
;   | .....    |
;   | x(-2)    | 
;   | x(-1)    | 

; TEMP comments 
; ar_coef and ar_scratch should be in correct position since they are circular ptrs
; CDP has to be set circular ( parameters BKC, BSAC are set in initialization code)
; the index of CDP has to be set
; CSR has to be set

        BSET CDPLC					; 
        MOV  #0, AC1
        MOV  XAR4, XCDP		; initialize extended part
        
        MOV  *SP(index_filt), CDP    ; 
        MPYM *ar_coef+,*CDP+,AC0	;   4 stalls	; h(N-1)x(i-N)	    
        
     || RPT   CSR
            MAC    *ar_coef+,*CDP+,AC0
            :: MAC *ar_scratch+,*CDP+,AC1
        
        MACM   *ar_scratch+,*CDP+,AC1			; h'(0)x(i)
        AMAR *+CDP(#3)
        
        MOV  CDP, *SP(index_filt)
	
        ; store output
        MOV  rnd(HI(AC0)), *ar_output+;
        MOV  rnd(HI(AC1)), *ar_output+;
	
;   Error computation stage
;	-----------------------
;	Computing e(n) and e(n+1)		
        BCLR    CDPLC                                   ; 5 stalls; Disable CDP for circ addressing
        MOV     XSP, XCDP                               ; CDP = &err (on stack)
        SUB     AC0,*ar_des+<<#16,AC0                   ; AC0 = e(n) = y(n) - AC0
        MPYR    T_step, AC0

        SUB     AC1,*ar_des+<<#16,AC2                   ; AC1 = e(n+1) = y(n+1) - AC1
 .if (err != 0)
        AMAR *+CDP(#err)                                 ; CDP = &err (on stack)
 .endif
        MPYR    T_step, AC2
      ||MOV     HI(AC0), *CDP
         
;  Second Coefficient update stage
;  ------------------------------
;  Update Coefficients from the previous error e(n)
;
;   The coefficients h and h' are stored in reversed order: h(n-1)... h(0) where
;	h(n) is at the lowest memory address. 
;
;  AR6 ---> h
;  AR7 ---> h'
;  AR1 ---> x[n-(N-(2*k))]
;  AR3 ---> x[n-(N-(2*k+1))]
;  CDP ---> e(n)
;  T0 = #2
;  BRC1 = NH/2 -2
; 				

;***** Filter coefficients buffer ********
;
;   | h(N-1)  | <------ ar_coef
;   |  .....  |
;   |  h(0)   |
;   | h'(N-1) | <------ ar_scratch
;   |  .....  |
;   |  h'(0)  |  

;***** Delay buffer ********
;                      
;   | x(0)     | <------ ar_data1
;   | x(1)     | 
;   | x(-N)	   |
;   | x(-(N-1))| <------ ar_data1
;   | .....    | <------ ar_data2
;   | x(-2)    | 
;   | x(-1)    |  

        ; loop starts here	
        MOV   dbl(*(ar_scratch+T0)),PAIR(HI(AC0)) 		

        ; Following 3 unrolls are to allow BRC1 setup
        MACR  *(ar_data1+T0),*CDP,AC0    			
        :: MACR  *(ar_data2+T0),*CDP,AC1    		
        MOV   PAIR(HI(AC0)),dbl(*(ar_coef+T0)) 		
     || MOV   dbl(*(ar_scratch+T0)), PAIR(HI(AC0))

        MACR  *(ar_data1+T0),*CDP,AC0    			
        :: MACR  *(ar_data2+T0),*CDP,AC1    		
        MOV   PAIR(HI(AC0)),dbl(*(ar_coef+T0)) 		
     || MOV   dbl(*(ar_scratch+T0)), PAIR(HI(AC0))

        MACR  *(ar_data1+T0),*CDP,AC0    			
        :: MACR  *(ar_data2+T0),*CDP,AC1    		
        MOV   PAIR(HI(AC0)),dbl(*(ar_coef+T0)) 		
     || MOV   dbl(*(ar_scratch+T0)), PAIR(HI(AC0))
                                                    
        RPTBLOCAL   #(coef_updt2-1)                                 ; 2 stalls   ; segment update loop            
            MACR  *(ar_data1+T0),*CDP,AC0                           ; AC0=AC0+2^15+en*x[n-(N-(2*k))]
            :: MACR  *(ar_data2+T0),*CDP,AC1                        ; AC1=AC1+2^15+en*x[n-(N-(2*k+1))]
            MOV   PAIR(HI(AC0)),dbl(*(ar_coef+T0))                  ; h'(N-1-(2*k)) = HIGH(AC0)
         || MOV   dbl(*(ar_scratch+T0)), PAIR(HI(AC0))              ; h'(N-1-(2*k+1)) = HIGH(AC1)
                                                                    ; HI(AC0) = h[N-(2*k+2)]
                                                                    ; HI(AC0) = h[N-(2*k+2+1)]
        ; 1 stall in rptblocal loop after 1st iteration                                            
coef_updt2:          

	MACR  *(ar_data1+T1),*CDP,AC0                               ; AC0=AC0+2^15+en*x[n-1]
	::MACR  *(ar_data2+T0),*CDP,AC1                             ; AC1=AC1+2^15+en*x[n-2]
	MOV   PAIR(HI(AC0)),dbl(*(ar_coef+T0))                      ; h'[0] = HIGH(AC0)
	                                                            ; h'[1] = HIGH(AC1)

;   Update the delay line
;  -------------------------
;	
        MOV  *ar_input+, *ar_data2+                                  ;copy input -> state(0)
        MOV  *ar_input+, *(ar_data2+T0)                              ;copy input -> state(0)
	
;  Preserve e(n+1) for next stage
;  ------------------------------
;  
        MOV     HI(AC2), *CDP

ext_loop:     ; end of RPTB loop

;NO presumed values in ST0 by C-environment
;No presumed values of ST3 were modified

    AND  #0xF800, mmap(ST2_55)                                  ;all pointers put in linear mode, clear RDM

; Return overflow flag
; --------------------
    MOV  #0, T0                                                  ;store zero for return value
    XCCPART overflow(AC0)
        || MOV  #1, T0                                           ;return value 1 if overflow was encountered
    XCCPART overflow(AC1)
        || MOV  #1, T0                                           ;return value 1 if overflow was encountered
;
; Allocate the local frame and argument block
;----------------------------------------------------------------
    AADD   #+(FRAME_SZ + ARG_BLK_SZ), SP
	
;
; Restore stack to previous value
; Reset status regs to restore normal C operating environment
; Return to calling function
;----------------------------------------------------------------
    POPBOTH XAR7                                                ;AR6 and AR7 are used in this function
 || BSET ARMS                                                   ;set ARMS bit for C-environment
    POPBOTH XAR6                                                ;AR6 and AR7 are used in this function
 || BCLR FRCT                                                   ;clear FRCT bit in ST1 for C-environment
    POPBOTH XAR5                                                ;AR6 and AR7 are used in this function
    POP  T3
    RET                                                         ;return to calling function

    .end

;end of file. please do not remove. it is left here to ensure that no lines of code are removed by any editor

expn.asm/       1362765892  0     0     0       5213      `
;/*
; * Copyright (C) 2013 Texas Instruments Incorporated - http://www.ti.com/ 
; * 
; * 
; *  Redistribution and use in source and binary forms, with or without 
; *  modification, are permitted provided that the following conditions 
; *  are met:
; *
; *    Redistributions of source code must retain the above copyright 
; *    notice, this list of conditions and the following disclaimer.
; *
; *    Redistributions in binary form must reproduce the above copyright
; *    notice, this list of conditions and the following disclaimer in the 
; *    documentation and/or other materials provided with the   
; *    distribution.
; *
; *    Neither the name of Texas Instruments Incorporated nor the names of
; *    its contributors may be used to endorse or promote products derived
; *    from this software without specific prior written permission.
; *
; *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
; *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
; *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
; *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
; *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
; *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
; *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
; *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
; *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
; *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
; *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
; *
;*/

;***********************************************************
; Version 3.00.00                                           
;***********************************************************
;  Function:	expn
;  Description: exponent vector evaluation via polynomial approximation
;
;  Usage:  ushort expn(DATA *x, DATA *r, ushort nx);
;
; Benchmarks:
;   Cycles:       (7 * nx) + 15
;   Code Size (in bytes): 
;        .text:     60
;        .const:    12
;
;  History
;        Zhengting He - 10/25/2006
; - Added overflow checking and overflow is returned in T0 instead of 
;   AC0 register
;
;        Craig Leeds  - 05/17/2012
;   Fix alignment of expn_coeffs.
;   Move expn_coeffs from .data to .const
;   Clear AC0 overflow bit on entry.
;   Optimized.
;********************************************************************************

	.mmregs

; Table containing the coefficients for the polynomial


	.sect ".const"
	.align			; 
expn_coeffs:			; hex values in q4.12
	.word	0x0039	;0.0139		(coef for x^5 = c5)
	.word	0x008f	;0.0348		(coef for x^4 = c4)
	.word	0x02ba	;0.1705		(coef for x^3 = c3)
	.word	0x07fc	;0.4990		(coef for x^2 = c2)
	.word	0x1000	;1.0001		(coef for x^1 = c1)
	.word	0x1000	;1.0000		(coef for x^0 = c0)


;****************************************************************
	.global	_expn
	.text

; Get arguments and set modes
; ---------------------------

_expn:
	SUB	#1, T0			;b = n-1
	MOV	T0, mmap(BRC0)		;BRC = n-1

	BSET	FRCT			;set FRCT on
	BSET	SATD			
;;;	BSET	SXMD	                ; (Not necessary since it's required on entry by C)
	BCLR	ACOV0			; clear overflow bit 
	AMAR	*(#expn_coeffs), XAR4	;pointer to coeff table
        MOV     #-5, T0
	MOV	*AR0+, T1		;t = x(sign-extended) (Prime the Pump)

	||RPTBLOCAL	loop-1 			;repeat n times

; Start polynomial evaluation
; ---------------------------

; this should be moved out from the loop and rewound
; back to beginning by t1 register. It is not possible yet with beta tools.


	        MOV	dbl(*AR4+), pair(HI(AC0))

	        MOV	*AR4+ << #16, AC1
	      ||MACR	AC0, T1, AC1, AC0	;a = ah*t + b
					        ;  = c5*x + c4
					        ;bh = c3  point to c2

	        MOV	*AR4+ << #16, AC1	
	      ||MACR	AC0, T1, AC1, AC0	;a = ah*t + b
					        ;  = (c5*x + c4)*x + c3
					        ;  =  c5*x^2 + c4*x + c3
					        ; bh = c2	point to c1

	        MOV	*AR4+ << #16, AC1	
	      ||MACR	AC0, T1, AC1, AC0	;a = ah*t + b
					        ;   = (c5*x^2+c4*x+c3)*x + c2
					        ;   = c5*x^3+c4*x^2+c3*x + c2
					        ; bh = c1	point to c0

	        MOV	*(AR4+T0) << #16, AC1	
	      ||MACR	AC0, T1, AC1, AC0	;a = ah*t + b
					        ;   = (c5*x^3+c4*x^2+c3*x + c2)*x + c1
					        ;   = c5*x^4+c4*x^3+c3*x^2+c2*x +c1
					        ; bh = c0	point to c(-1)
        
	        MAC	AC0, T1, AC1, AC0	; a = ah*t + b				
					        ;   = (c5*x^4+c4*x^3+c3*x^2 + c2*x+c1)*x + c0
					        ;   = c5*x^5+c4*x^4+c3*x^3+c2*x^2 +c1*x + c0
        
        
	        MOV	HI(AC0), *AR1+		;store q4.12 output
	      ||MOV	*AR0+, T1		;t = x(sign-extended) (for next iteration)
loop:

; Return overflow flag
; --------------------
; bug: original code put return value in AC0
; fix: put to T0
	MOV	#0, T0
	||BCLR	FRCT
	XCCPART	overflow(AC0)
	     ||MOV    #1, T0

	BCLR	SATD
	||RET
;end of file. please do not remove. it is left here to ensure that no lines of code are removed by any editor	

fir.asm/        1362765892  0     0     0       7405      `
;/*
; * Copyright (C) 2013 Texas Instruments Incorporated - http://www.ti.com/ 
; * 
; * 
; *  Redistribution and use in source and binary forms, with or without 
; *  modification, are permitted provided that the following conditions 
; *  are met:
; *
; *    Redistributions of source code must retain the above copyright 
; *    notice, this list of conditions and the following disclaimer.
; *
; *    Redistributions in binary form must reproduce the above copyright
; *    notice, this list of conditions and the following disclaimer in the 
; *    documentation and/or other materials provided with the   
; *    distribution.
; *
; *    Neither the name of Texas Instruments Incorporated nor the names of
; *    its contributors may be used to endorse or promote products derived
; *    from this software without specific prior written permission.
; *
; *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
; *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
; *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
; *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
; *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
; *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
; *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
; *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
; *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
; *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
; *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
; *
;*/

;***********************************************************
; Version 3.00.00                                           
;***********************************************************
; Function:    fir
; Processor:   C55xx
; Description: Implements finite impulse response filter using
;              single-MAC approach.  C-callable.
;
; Usage: ushort oflag = fir(DATA *x,           // XAR0
;                           DATA *h,           // XAR1
;                           DATA *r,           // XAR2
;                           DATA *dbuffer,     // XAR3
;                           ushort nx,         // T0
;                           ushort nh)         // T1
;
;
; Limitations:
;   nh >= 3
;
; Benchmarks:
;   Cycles:       (nx * (nh + 2)) + 37
;   Code Size (in bytes):  88
;
; History:
;   05/26/2012 Craig Leeds:  Bug fixed: SMUL must be set on exit
;****************************************************************

      .ARMS_on                      ;enable assembler for ARMS=1
      .CPL_on                       ;enable assembler for CPL=1
      .mmregs                       ;enable mem mapped register names

; Stack frame
; -----------
RET_ADDR_SZ       .set 1            ;return address
REG_SAVE_SZ       .set 1            ;save-on-entry registers saved (T3)
FRAME_SZ          .set 0            ;local variables
ARG_BLK_SZ        .set 0            ;argument block

PARAM_OFFSET      .set ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ + RET_ADDR_SZ


; Register usage
; --------------
      .asg     AR0, x_ptr           ;linear pointer
      .asg     AR1, h_ptr           ;circular pointer
      .asg     AR2, r_ptr           ;linear pointer
      .asg     AR4, db_ptr          ;circular pointer

      .asg     BSA45, db_base       ;base addr for db_ptr
      .asg     XAR4, xdb_base       ;extended base addr for db_ptr
      .asg     BK47, db_sz          ;circ buffer size for db_ptr
      .asg     BK47_L, db_sz_L      ;for memory mapped access
      .asg     BSA01, h_base        ;base addr for h_ptr
      .asg     BK03, h_sz           ;circ buffer size for h_sz

      .asg     T0, oflag            ;returned value

      .global _fir

      .text
_fir:

;
; Allocate the local frame and argument block
;----------------------------------------------------------------
;      SP = SP - #(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ)
; - not necessary for this function (the above is zero)
;
; Save any save-on-entry registers that are used
;----------------------------------------------------------------
; - nothing to save for this function
;
; Configure the status registers as needed.
;----------------------------------------------------------------
	PSH     T3
	|| BCLR    ACOV0
	BSET    FRCT
	BCLR    SMUL
;
; Setup passed parameters in their destination registers
; Setup circular/linear CDP/ARx behavior
;----------------------------------------------------------------

; x pointer - passed in its destination register, need do nothing

; h pointer

	MOV	AR1, mmap(h_base)	;base address of coefficients
	MOV	T1, mmap(h_sz)		;coefficient array size
	MOV	#0, h_ptr		;point to first coefficient

; r pointer - passed in its destination register, need do nothing

; db pointer

     || MOV	XAR3, xdb_base		;db array address
	MOV	*AR3+, db_ptr		;index of oldest db entry
	ADD     #1, T1, T3
	MOV	T3, mmap(db_sz)		;db_sz = nh+1
	MOV	AR3, mmap(db_base)	;base address for db_ptr

; Set circular/linear ARx behavior

	BSET    AR1LC
	BSET    AR4LC
;
; Setup loop counts
;----------------------------------------------------------------

	SUB	#1, T0			;T0 = nx-1
     || MAR     *AR3-
	MOV	T0, BRC0		;outer loop executes nx times
	MOV     T1, T0
	SUB	#3, T1 		;T1 = nh-3
	MOV	T1, CSR		;inner loop executes nh-2 times
;
; Compute last iteration input pointer offsets
;----------------------------------------------------------------
; - computation not needed since T0 contains nh
;
; Start of outer loop
;----------------------------------------------------------------

      ||RPTBLOCAL	loop1-1		;start the outer loop
		MPYM	T3 = *x_ptr+, *h_ptr+, AC0
		MOV     T3, *db_ptr+
		||RPT	CSR
			MACM	*h_ptr+, *db_ptr+, AC0
		MACMR	*h_ptr+, *(db_ptr-T0), AC0   ;last iteration has different pointer adjustment and rounding
		;store result to memory 
		MOV	HI(AC0), *r_ptr+	;store Q15 value to memory
loop1:					;end of outer loop

;
; Update the db entry point
;----------------------------------------------------------------
	MOV	db_ptr, *AR3		;update 1st element of db array
;
; Check if overflow occurred, and setup return value
;----------------------------------------------------------------

	||MOV	#0, oflag		;clear oflag
	XCCPART	overflow(AC0)	;clears ACOV0
	    ||MOV	#1, oflag		;overflow occurred
;
; Restore status regs to expected C-convention values as needed
;----------------------------------------------------------------
	BCLR    AR1LC
	BCLR    AR4LC
	POP     T3
     || BCLR	FRCT			;clear FRCT
	BSET	SMUL			;set SMUL
;
; Restore any save-on-entry registers that are used
;----------------------------------------------------------------
; - nothing to restore for this function

;
; Deallocate the local frame and argument block
;----------------------------------------------------------------
;      SP = SP + #(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ)
; - not necessary for this function (the above is zero)

;
; Return to calling function
;----------------------------------------------------------------
	||RET

;----------------------------------------------------------------
;End of file

fir2.asm/       1362765892  0     0     0       10235     `
;/*
; * Copyright (C) 2013 Texas Instruments Incorporated - http://www.ti.com/ 
; * 
; * 
; *  Redistribution and use in source and binary forms, with or without 
; *  modification, are permitted provided that the following conditions 
; *  are met:
; *
; *    Redistributions of source code must retain the above copyright 
; *    notice, this list of conditions and the following disclaimer.
; *
; *    Redistributions in binary form must reproduce the above copyright
; *    notice, this list of conditions and the following disclaimer in the 
; *    documentation and/or other materials provided with the   
; *    distribution.
; *
; *    Neither the name of Texas Instruments Incorporated nor the names of
; *    its contributors may be used to endorse or promote products derived
; *    from this software without specific prior written permission.
; *
; *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
; *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
; *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
; *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
; *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
; *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
; *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
; *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
; *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
; *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
; *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
; *
;*/

;***********************************************************
; Version 3.00.00                                           
;***********************************************************
; Function:    fir2
; Processor:   C55xx
; Description: Implements finite impulse response filter using
;              dual-MAC approach.  C-callable.
;
; Usage: ushort oflag = fir2(DATA *x,           // XAR0
;                            DATA *h,           // XAR1
;                            DATA *r,           // XAR2
;                            DATA *dbuffer,     // XAR3
;                            ushort nx,         // T0
;                            ushort nh)         // T1
;
; Limitations:
;   nh >= 3
;   h[] is addressible by bbus (i.e. on-chip)
;
; Notes:
;   if dbuffer is in saram instead of daram, the function takes twice as many cycles.
;
; Benchmarks:
;   Cycles:       ((nx / 2) * (nh + 5)) + 38
;   Code Size (in bytes):  120???
;
; History:
;   2.10  Rishi       08/03/2001 - optimized the code for benchmark.
;   3.00  Craig Leeds 05/27/2012 - clear SMUL on exit
;****************************************************************

      .ARMS_off                     ;enable assembler for ARMS=0
      .CPL_on                       ;enable assembler for CPL=1
      .mmregs                       ;enable mem mapped register names

; Stack frame
; -----------
RET_ADDR_SZ       .set 1            ;return address
REG_SAVE_SZ       .set 0            ;save-on-entry registers saved
FRAME_SZ          .set 0            ;local variables
ARG_BLK_SZ        .set 0            ;argument block
PARAM_OFFSET      .set ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ + RET_ADDR_SZ


; Register usage
; --------------
      .asg     AR0, x_ptr           ;linear pointer
      .asg     AR1, db_ptr1         ;circular pointer
      .asg     AR2, r_ptr           ;linear pointer
      .asg     AR3, db_ptr2         ;circular pointer
      .asg     CDP, h_ptr           ;circular pointer

      .asg     BSA01, db_base1      ;base addr for db_ptr1
      .asg     XAR1, xdb_base1      ;extended base addr for db_ptr1
      .asg     BSA23, db_base2      ;base addr for db_ptr2
      .asg     BK03, db_sz          ;circ buffer size for db_ptr1 and db_ptr2
      .asg     BK03_L, db_sz_L      ;for memory mapped access
      .asg     BSAC, h_base         ;base addr for h_ptr
      .asg     XCDP, xh_base        ;extended base addr for h_ptr
      .asg     BKC, h_sz            ;circ buffer size for h_sz

      .asg     T0, oflag            ;returned value

ST2mask  .set  0000000100001010b    ;circular/linear pointers (AR1, AR3, CDP)


      .global _fir2

      .text
_fir2:

;
; Allocate the local frame and argument block
;----------------------------------------------------------------
;      SP = SP - #(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ)
; - not necessary for this function (the above is zero)

;
; Save any save-on-entry registers that are used
;----------------------------------------------------------------
; - nothing to save for this function

;
; Configure the status registers as needed.
;----------------------------------------------------------------
        BCLR    ARMS
        BCLR    SMUL
        BSET    FRCT
        BCLR    ACOV0
        BCLR    ACOV1
;
; Setup passed parameters in their destination registers
; Setup circular/linear CDP/ARx behavior
;----------------------------------------------------------------

; x pointer - passed in its destination register, need do nothing

; h pointer
        MOV     XAR1, xh_base            ;extended base address for h_ptr
        MOV     #0, h_ptr                ;point to first coefficient
        MOV     AR1, mmap(h_base)        ;base address of coefficients
        MOV     T1, mmap(h_sz)           ;coefficient array size

; r pointer - passed in its destination register, need do nothing

; db pointers, part 1 - must come before circ/linear ARx setup
        MOV     XAR3, XAR4               ;save db array address
        MOV     XAR4, xdb_base1          ;extended base address for db_ptr1
                                         ;xdb_base2 already setup via argument pass
        MOV     *AR4, db_ptr1            ;index of oldest db entry
        MOV     *AR4+, db_ptr2           ;index of oldest db entry

        MOV     AR4, mmap(db_base1)      ;base address for db_ptr1
        MOV     AR4, mmap(db_base2)      ;base address for db_ptr2

; Set circular/linear ARx behavior
        OR      #ST2mask, mmap(ST2_55)   ;config circ/linear pointers
        MOV     T1, mmap(db_sz)          ;db_sz = nh
        ADD     #1, mmap(db_sz)          ;db_sz = nh+1

; db pointers, part 2 - must come after circ/linear ARx setup
        AMAR    *db_ptr2-                ;index of 2nd oldest db entry
;
; Setup loop counts
;----------------------------------------------------------------
      ||SFTS    T0, #-1                  ;T0 = nx/2

        SUB     #1, T0                   ;T0 = (nx/2 - 1)
        MOV     T0, BRC0                 ;outer loop executes nx/2 times
        SUB     #3, T1, T0               ;T0 = nh-3
        MOV     T0, CSR                  ;inner loop executes nh-2 times
;
; Compute last iteration input pointer offsets
;----------------------------------------------------------------
        ADD     #1, T1, T0               ;T0 = nh+1, adjustment for db_ptr1, db_ptr2
        MOV     *x_ptr+, *db_ptr1        ;get 1st new input value
        MOV     *x_ptr+, *db_ptr2        ;get 2nd new input value (newest)
;
; Start of outer loop
;----------------------------------------------------------------
      ||RPTBLOCAL  LoopEnd-1             ;start the outer loop

;1st iteration
                MPY     *db_ptr1+, *h_ptr+, AC0           ;part 1 of dual-MPY
                ::MPY   *db_ptr2+, *h_ptr+, AC1           ;part 2 of dual-MPY
;inner loop
              ||RPT     CSR
                        MAC     *db_ptr1+, *h_ptr+, AC0   ;part 1 of dual-MAC
                        ::MAC   *db_ptr2+, *h_ptr+, AC1   ;part 2 of dual-MAC
;last iteration has different pointer adjustment and rounding
                MACR    *(db_ptr1-T0), *h_ptr+, AC0       ;part 1 of dual-MAC
                ::MACR  *(db_ptr2-T0), *h_ptr+, AC1       ;part 2 of dual-MAC
        
                MOV     *x_ptr+, *db_ptr1                 ;get 1st new input value
                MOV     *x_ptr+, *db_ptr2                 ;get 2nd new input value (newest)
;store results to memory        
                MOV     pair(HI(AC0)), dbl(*r_ptr+)       ;store 1st Q15 result to memory
                                                          ;store 2nd Q15 result to memory
LoopEnd:                                 ;end of outer loop

;
; Update the db entry point
;----------------------------------------------------------------
        MOV     db_ptr1, *-AR4           ;update 1st element of db array
;
; Check if overflow occurred, and setup return value
;----------------------------------------------------------------
      ||MOV     #0, oflag                ;clear oflag

        XCCPART overflow(AC0)            ;clears ACOV0
            ||MOV    #1, oflag           ;overflow occurred

        XCCPART overflow(AC1)            ;clears ACOV1
            ||MOV    #1, oflag           ;overflow occurred
;
; Restore status regs to expected C-convention values as needed
;----------------------------------------------------------------
        AND     #0FE00h, mmap(ST2_55)    ;clear CDPLC and AR[7-0]LC (specifically AR1LC, AR3LC, CDPLC) for C
        BCLR    FRCT                     ;clear FRCT for C
        BSET    ARMS                     ;set ARMS for C
        BSET    SMUL                     ;set SMUL for C
;
; Restore any save-on-entry registers that are used
;----------------------------------------------------------------
; - nothing to restore for this function

;
; Deallocate the local frame and argument block
;----------------------------------------------------------------
;      SP = SP + #(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ)
; - not necessary for this function (the above is zero)

;
; Return to calling function
;----------------------------------------------------------------
      ||RET                              ;return to calling function

;----------------------------------------------------------------
;End of file


firlat.asm/     1362765892  0     0     0       9569      `
;/*
; * Copyright (C) 2013 Texas Instruments Incorporated - http://www.ti.com/ 
; * 
; * 
; *  Redistribution and use in source and binary forms, with or without 
; *  modification, are permitted provided that the following conditions 
; *  are met:
; *
; *    Redistributions of source code must retain the above copyright 
; *    notice, this list of conditions and the following disclaimer.
; *
; *    Redistributions in binary form must reproduce the above copyright
; *    notice, this list of conditions and the following disclaimer in the 
; *    documentation and/or other materials provided with the   
; *    distribution.
; *
; *    Neither the name of Texas Instruments Incorporated nor the names of
; *    its contributors may be used to endorse or promote products derived
; *    from this software without specific prior written permission.
; *
; *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
; *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
; *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
; *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
; *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
; *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
; *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
; *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
; *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
; *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
; *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
; *
;*/

;***********************************************************
; Version 3.00.00                                           
;***********************************************************
;****************************************************************
; Function:    firlat
; Processor:   C55xx
; Description: Computes a real lattice FIR filter implementation 
;		using coefficient stored in vector h. The real data 
;		input is stored in vector x. The filter output result 
;		is stored in vector r .  This function retains the 
;		address of the delay filter memory d containing the 
;		previous delayed values to allow consecutive processing 
;		of blocks. This function can be used for both 
;		block-by-block and  sample-by-sample filtering (nx=1).   
;		C-callable.
;
; Usage: short oflag = firlat (DATA *x, 
;                              DATA *h, 
;                              DATA *r,
;                              DATA *pbuffer, 
;                              int nx, 
;                              int nh)
;
;Algorithm:
; 
;	e(0)[0]  = e'(0)[0]=x[0]
; 	e(i)[n]  = e(i-1)[n] + k(i)*e'(i-1)[n-1]   i=1,2,.. nh
;       e'(i)[n] = k(i)*e(i-1)[n] + e'(i-1)[n-1]   i=1,2,.. nh
;	e(nh)[n] = r[n]
;
;
;pbuffer: procession buffer of nh length
;      e'0[n-1]
;      e'1[n-1]
;      e'2[n-1]
;      e'3[n-1]
;	.
;	.
;      e'nh-2[n-1]
;      e'nh-1[n-1]
;
;x: input of length nx
;	x[0]
;	x[1]
;	.
;	.
;	.
;	x[nx-2]
;	x[nx-1]
;
;h: input of length nh
;	h[0]
;	h[1]
;	.
;	.
;	.
;	h[nx-2]
;	h[nx-1]
;
;y: output of length nx
;	y[0]
;	y[1]
;	.
;	.
;	.
;	y[nx-2]
;	y[nx-1]                                          
;
;
; Limitations:
;   nh >= 2
;
; Benchmarks:
;   Cycles:       (nx * nh * 4) + 30
;   Code Size (in bytes):  97
;
; History:
; 2.10	Rishi  08/03/2001 - optimized the code for benchmark.
; 3.00	Craig Leeds  05/28/2012 - fixed bug in overflow checking
*********************************************************************/

      .ARMS_off                     ;enable assembler for ARMS=0
      .CPL_on                       ;enable assembler for CPL=1
      .mmregs                       ;enable mem mapped register names
      .noremark 5684                ;CPU_116: BRC1 not modified indirectly

; Stack frame
; -----------
RET_ADDR_SZ       .set 1            ;return address
REG_SAVE_SZ       .set 0            ;save-on-entry registers saved
FRAME_SZ          .set 0            ;local variables
ARG_BLK_SZ        .set 0            ;argument block

PARAM_OFFSET      .set ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ + RET_ADDR_SZ


; Register usage
; --------------
      .asg     AR0, x_ptr           ;linear pointer
      .asg     AR1, h_ptr           ;circular pointer
      .asg     AR2, r_ptr           ;linear pointer
      .asg     AR4, p_ptr           ;circular pointer
      .asg     AR3, temp	        ; temp buffer
     
      .asg     BSA45, p_base       ;base addr for p_ptr
      .asg     XAR4, xp_base      ;extended base addr for p_ptr
      .asg     BK47, p_sz          ;circ buffer size for p_ptr
      .asg     BK47_L, p_sz_L      ;for memory mapped access
      .asg     BSA01, h_base        ;base addr for h_ptr
      .asg     BK03, h_sz           ;circ buffer size for h_sz

      .asg     BRC1, inner_cnt       ;inner loop count
      .asg     BRC0, outer_cnt      ;outer loop count

      .asg     T0, oflag           ;returned value

ST2mask  .set  0000000000010010b    ;circular/linear pointers, AR4, AR1 circular

      .global _firlat

      .text
_firlat:

;
; Allocate the local frame and argument block
;----------------------------------------------------------------
;      SP = SP - #(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ)
; - not necessary for this function (the above is zero)

;
; Save any save-on-entry registers that are used
;----------------------------------------------------------------
; - nothing to save for this function
;
; Configure the status registers as needed.
;----------------------------------------------------------------
        BCLR    SMUL
        BCLR    ARMS
        BSET    FRCT
        BCLR    ACOV0
        BCLR    ACOV1
;
; Setup passed parameters in their destination registers
; Setup circular/linear CDP/ARx behavior
;----------------------------------------------------------------
; x pointer - passed in its destination register, need do nothing
; h pointer

        MOV    AR1, mmap(h_base)        ;base address of coefficients
        MOV    T1, mmap(h_sz)           ;coefficient array size

; r pointer - passed in its destination register, need do nothing
; db pointer
        MOV     XAR3, XAR4
        MOV    AR3, mmap(p_base)        ;base address for p_ptr
        MOV    T1, mmap(p_sz)           ;p_sz = nh
; Set circular/linear ARx behavior
        BSET   AR1LC
        BSET   AR4LC
;
; Setup loop counts
;----------------------------------------------------------------

        SUB    #1, T0                   ;T0 = nx-1
     || AMOV    #0, h_ptr               ;point to first coefficient
        MOV    T0, BRC0                 ;outer loop executes nx times
        SUB    #2, T1, T0               ;T0 = nh-3
        MOV    T0, BRC1                 ;inner loop executes nh-2 times
        AMOV   #0, p_ptr                ;point to first coeffiecient
;
; Start of outer loop
;----------------------------------------------------------------

     || RPTBLOCAL  OuterLoopEnd-1                       ;start the outer loop
                MOV     *x_ptr+ << #16, AC0             ;setup for e(0): input value
                ;1st iteration
                MOV     HI(AC0), AR3
                
              ||RPTBLOCAL  InnerLoopEnd-1
                        NOP_16                          ;for CPU_116
                      ||MOV     *p_ptr << #16, AC1      ;setup for e'(0): input value
                        MACM    *h_ptr, AC0, AC1        ;calculate e'(0)
                        MACM    *p_ptr, *h_ptr+, AC0    ;calculate e(0)
                        MOV     AR3, *p_ptr+            ;store previously cacluclated e'(i)
                      ||MOV     HI(AC1), AR3
InnerLoopEnd:

                ;last iteration has rounding
                MACMR   *p_ptr, *h_ptr+, AC0
                MOV     AR3, *p_ptr+                    ;store previously cacluclated e'(i)
                ; Store result to memory
              ||MOV     HI(AC0), *r_ptr+                ;store Q15 value to memory
OuterLoopEnd:

;
; Check if overflow occurred, and setup return value
;----------------------------------------------------------------

	MOV     #0, oflag
     || BCLR    AR1LC
        XCCPART overflow(AC0)        ;clears ACOV0
            ||MOV   #1, oflag        ;overflow occurred
        XCCPART overflow(AC1)        ;clears ACOV0
            ||MOV   #1, oflag        ;overflow occurred

;
; Restore status regs to expected C-convention values as needed
;----------------------------------------------------------------
        BCLR    AR4LC
        BCLR    FRCT                 ;clear FRCT
        BSET    ARMS                 ;set ARMS
        BSET    SMUL
;
; Restore any save-on-entry registers that are used
;----------------------------------------------------------------
; - nothing to restore for this function
;
; Deallocate the local frame and argument block
;----------------------------------------------------------------
;      SP = SP + #(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ)
; - not necessary for this function (the above is zero)
;
; Return to calling function
;----------------------------------------------------------------
     || RET
;----------------------------------------------------------------
;End of file

firs.asm/       1362765892  0     0     0       8556      `
;/*
; * Copyright (C) 2013 Texas Instruments Incorporated - http://www.ti.com/ 
; * 
; * 
; *  Redistribution and use in source and binary forms, with or without 
; *  modification, are permitted provided that the following conditions 
; *  are met:
; *
; *    Redistributions of source code must retain the above copyright 
; *    notice, this list of conditions and the following disclaimer.
; *
; *    Redistributions in binary form must reproduce the above copyright
; *    notice, this list of conditions and the following disclaimer in the 
; *    documentation and/or other materials provided with the   
; *    distribution.
; *
; *    Neither the name of Texas Instruments Incorporated nor the names of
; *    its contributors may be used to endorse or promote products derived
; *    from this software without specific prior written permission.
; *
; *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
; *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
; *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
; *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
; *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
; *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
; *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
; *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
; *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
; *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
; *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
; *
;*/

;***********************************************************
; Version 3.00.00                                           
;***********************************************************
; Function:    firs
; Processor:   C55xx
; Description: Implements symmetric finite impulse response
;              filter using FIRS approach.  C-callable.
;
; Usage: ushort oflag = firs(DATA *x,            // XAR0
;                            DATA *h,            // XAR1
;                            DATA *r,            // XAR2
;                            DATA *dbuffer,      // XAR3
;                            ushort nx,          // T0
;                            ushort nh)          // T1
;
; Limitations:
;   nh >= 3
;   h[] is addressible by bbus (i.e. on-chip)
;
; Notes:
;   if dbuffer is in saram instead of daram, the function takes twice as many cycles.
;
; Benchmarks:
;   Cycles:       (nx * (nh + 3)) + 46
;   Code Size (in bytes):  120
;
; History:
;   05/26/2012 Craig Leeds:  Bug fixed: AC0 cleared before first iteration of loop
;****************************************************************

      .ARMS_off                     ;enable assembler for ARMS=0
      .CPL_on                       ;enable assembler for CPL=1
      .mmregs                       ;enable mem mapped register names

; Stack frame
; -----------
RET_ADDR_SZ       .set 1            ;return address
REG_SAVE_SZ       .set 0            ;save-on-entry registers saved
FRAME_SZ          .set 0            ;local variables
ARG_BLK_SZ        .set 0            ;argument block

PARAM_OFFSET      .set ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ + RET_ADDR_SZ


; Register usage
; --------------
      .asg    AR0, x_ptr            ;linear pointer
      .asg    AR1, db_ptr1          ;circular pointer
      .asg    AR2, r_ptr            ;linear pointer
      .asg    AR3, db_ptr2          ;circular pointer
      .asg    CDP, h_ptr            ;circular pointer

      .asg    BSA01, db_base1       ;base addr for db_ptr1
      .asg    XAR1, xdb_base1       ;extended base addr for db_ptr1
      .asg    BSA23, db_base2       ;base addr for db_ptr2
      .asg    BK03, db_sz           ;circ buffer size for db_ptr1 and db_ptr2
      .asg    BSAC, h_base          ;base addr for h_ptr
      .asg    XCDP, xh_base         ;extended base addr for h_ptr
      .asg    BKC, h_sz             ;circ buffer size for h_sz


      .asg    T0, oflag             ;returned value

ST2mask  .set  0000000100001010b    ;circular/linear pointers (AR1LC, AR3LC, CDPLC)


      .global _firs

      .text
_firs:

; Allocate the local frame and argument block
;----------------------------------------------------------------
;      SP = SP - #(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ)
; - not necessary for this function (the above is zero)
;
; Save any save-on-entry registers that are used
;----------------------------------------------------------------
; - nothing to save for this function
;
; Configure the status registers as needed.
;----------------------------------------------------------------
        BCLR    ACOV0
        BCLR    ARMS
        BSET    FRCT
        BCLR    SMUL
;
; Setup passed parameters in their destination registers
; Setup circular/linear CDP/ARx behavior
;----------------------------------------------------------------

; x pointer - passed in its destination register, need do nothing

; h pointer
        MOV     XAR1, xh_base      ; set CDPH
        MOV     AR1, mmap(h_base)  ; set BSAC
        MOV     T1, mmap(h_sz)     ; set BKC to nh2
        MOV     #0, h_ptr          ; clear CDP

; r pointer - passed in its destination register, need do nothing

; db pointers, part 1 - must come before circ/linear ARx setup
        MOV     XAR3, XAR4
        MOV     XAR4, xdb_base1

        MOV     *AR4, db_ptr1
        MOV     *AR4+, db_ptr2
      ||MOV     #1, AC0

        MOV     AR4, mmap(db_base1)
        MOV     AR4, mmap(db_base2)

; Set circular/linear ARx behavior
        OR      #ST2mask, mmap(ST2_55)   ; AR1LC, AR3LC, CDPLC
        ADD     mmap(T1) << #1, AC0
        MOV     AC0, mmap(db_sz)

; db pointers, part 2 - must come after circ/linear ARx setup
        AMAR    *db_ptr2-

;
; Setup loop counts
;----------------------------------------------------------------
      ||SUB     #1, T0
        MOV     T0, BRC0
      ||AMAR    *db_ptr2-
        SUB     #3, T1, T0
        MOV     T0, CSR

;
; Compute last iteration input pointer offsets
;----------------------------------------------------------------
        MOV     T1, T0
      ||MOV     #0, AC0                                
        SUB     #2, T1
        MOV     *x_ptr+, *db_ptr1  
;
; Start of outer loop
;----------------------------------------------------------------
     || RPTBLOCAL OuterLoopEnd-1

;clear AC0 and pre-load AC1 with the sum of the 1st and last inputs
        
                ADD     *db_ptr1+, *db_ptr2-, AC1

;inner loop
             || RPT     CSR
                        FIRSADD *db_ptr1+, *db_ptr2-, *h_ptr+, AC1, AC0        

;2nd to last iteration has different pointer adjustment
                FIRSADD *(db_ptr1-T0), *(db_ptr2+T1), *h_ptr+, AC1, AC0

;last iteration is a MAC with rounding
                MACMR   *h_ptr+, AC1, AC0
                MOV     *x_ptr+, *db_ptr1
    
;store result to memory
                MOV     HI(AC0), *r_ptr+        
             || MOV     #0, AC0
OuterLoopEnd:

;
; Update the db entry point
;----------------------------------------------------------------
        MOV     db_ptr1, *-AR4
;
; Check if overflow occurred, and setup return value
;----------------------------------------------------------------
      ||MOV     #0, oflag         ;clear oflag
        XCCPART overflow(AC0)   ;clears ACOV0
              ||MOV     #1, oflag     ;overflow occurred
;
; Restore status regs to expected C-convention values as needed
;----------------------------------------------------------------

        AND     #0FE00h, mmap(ST2_55)   ; clear all 8 ARxLC and CDPLC
        BSET    ARMS
        BCLR    FRCT
        BSET    SMUL
;
; Restore any save-on-entry registers that are used
;----------------------------------------------------------------
; - nothing to restore for this function
;
; Deallocate the local frame and argument block
;----------------------------------------------------------------
;      SP = SP + #(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ)
; - not necessary for this function (the above is zero)
;
; Return to calling function
;----------------------------------------------------------------
     || RET

;----------------------------------------------------------------
;End of file
fltoq15.asm/    1362765892  0     0     0       7288      `
;/*
; * Copyright (C) 2013 Texas Instruments Incorporated - http://www.ti.com/ 
; * 
; * 
; *  Redistribution and use in source and binary forms, with or without 
; *  modification, are permitted provided that the following conditions 
; *  are met:
; *
; *    Redistributions of source code must retain the above copyright 
; *    notice, this list of conditions and the following disclaimer.
; *
; *    Redistributions in binary form must reproduce the above copyright
; *    notice, this list of conditions and the following disclaimer in the 
; *    documentation and/or other materials provided with the   
; *    distribution.
; *
; *    Neither the name of Texas Instruments Incorporated nor the names of
; *    its contributors may be used to endorse or promote products derived
; *    from this software without specific prior written permission.
; *
; *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
; *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
; *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
; *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
; *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
; *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
; *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
; *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
; *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
; *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
; *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
; *
;*/

;***********************************************************
; Version 3.00.00                                           
;***********************************************************
; Function:	fltoq15
; Processor:   C55xx
; Description: convert IEEE floating point to Q15"
;
; Usage:  ushort fltoq15(float *x, DATA *r, ushort nx);
; 
; Notes:
;   The 32-bit single precision IEEE Floating Point is stored as follows:
;     Bit 31:      sign:  0 => positive, 1 => negative
;     Bits 23-30:  exponent: 2's complement from -128 to +127
;     Bits 0-22:   mantissa: 23-bits unsigned
;   The mantissa also includes an implied bit at bit 23 equal to 1 unless the exponent is 0.
;
; Benchmarks:
;   Cycles:       (23 * nx) + 16
;   Code Size (in bytes):  101
;
; History:
;   T2 registered is pushed and poped.
;    Zhengting He 10/25/2006
; 
;   Error conditions now correctly reported.
;   Optimized by 50%
;     Craig Leeds 05/25/2012
;
;****************************************************************



        .ARMS_on                      ;enable assembler for ARMS=1
        .CPL_on                       ;enable assembler for CPL=1
        .mmregs

;----------------------------------------------------------------
; local stack variables:
;----------------------------------------------------------------

;----------------------------------------------------------------
; Function definition:
;----------------------------------------------------------------

        .global        _fltoq15
        .text

_fltoq15:

;----------------------------------------------------------------
; Prolog: establish local frame, reset sign extension mode
;----------------------------------------------------------------
        MOV     #32768 << #16, AC3                ; (Note: this must be done before SXMD is cleared!)
        BCLR    SXMD
     || PSH     T2, T3

;----------------------------------------------------------------
; Process function arguments
;----------------------------------------------------------------
        SUB     #1, T0
     || NOT     AC3                               ; AC3 = 0x007fffffff
        MOV     T0, BRC0
;----------------------------------------------------------------
; Store function constants
;----------------------------------------------------------------
        MOV     #127, T3                          ; T3 = 127
        MOV     #0, T0                            ; clear error flag
     || BSET    TC2                               ; so that BCC ...,TC2 will always be True inside repeat block
        MOV     #32767, AR4                       ; AR4 = 32767
        MOV     dbl(*AR0+), AC0
        
;----------------------------------------------------------------
; Convert each element of vector A, to Q15 format
; Pre-Load first vector element
;----------------------------------------------------------------

        ||RPTBLOCAL end_loop-1

                MOV     HI(AC0), AR3
             || AND     AC3, AC0
                AND     #0x7f80 << #16, AC0, AC1
                SFTL    AC1, #-(7+16), AC1      
                SUB     T3, AC1                   ; -= 127
                MOV     AC1, T2
             || BCC     store_result, AC0 == #0   ; Branch if value is zero, then AC0 is already zero

                ABS     AC1, AC2
             || SFTS    AC0, #-7
                SUB     #15, AC2
                MOV     mmap(AC0_L) << #-1, AC0  
                BSET    #15, AC0                 ; |= 0x8000
                SFTS    AC0, T2
             || BCC     not_too_large, AC1 < #0
                
;----------------------------------------------------------------
; If unbiased exponent is >= 0, then value is too large to
; represent in Q15 format
;----------------------------------------------------------------
                MOV     AR4, AC0                 ; AC0 = 0x7fff
             || OR      #1, T0                   ; error flag
                XCCPART AR3 < #0
                     || ADD     #1, AC0
                BCC     store_result, TC2        ; branch always taken since TC2 is 1
                
not_too_large:
                
;----------------------------------------------------------------
; If exponent (abs) exp > abs(min_exp) then value is too small
; to represent in Q15 format. (min_exp = -15, since 2^-15 is
; least significant bit of Q15 number
;----------------------------------------------------------------

;----------------------------------------------------------------
; Shift floating point mantissa to keep only the most significant
; 15 bits. The implied 1 of the IEEE floating point format is ORed
; in as most significant bit.
;----------------------------------------------------------------

                XCCPART AR3 < #0
                     || NEG     AC0

		XCCPART AC2 > #0                         ; check if too small
                        OR      #2, T0                   ; error flag: too small
                     || MOV     #0, AC0                  ; error: too small
store_result:
                MOV     AC0, *AR1+
              ||MOV     dbl(*AR0+), AC0
end_loop:

;----------------------------------------------------------------
; Return to calling program. Set error conditions on return"
;----------------------------------------------------------------"

        POP     T2, T3
     || BSET    SXMD
        RET
;----------------------------------------------------------------
;End of file
hilb16.asm/     1362765892  0     0     0       8270      `
;/*
; * Copyright (C) 2013 Texas Instruments Incorporated - http://www.ti.com/ 
; * 
; * 
; *  Redistribution and use in source and binary forms, with or without 
; *  modification, are permitted provided that the following conditions 
; *  are met:
; *
; *    Redistributions of source code must retain the above copyright 
; *    notice, this list of conditions and the following disclaimer.
; *
; *    Redistributions in binary form must reproduce the above copyright
; *    notice, this list of conditions and the following disclaimer in the 
; *    documentation and/or other materials provided with the   
; *    distribution.
; *
; *    Neither the name of Texas Instruments Incorporated nor the names of
; *    its contributors may be used to endorse or promote products derived
; *    from this software without specific prior written permission.
; *
; *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
; *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
; *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
; *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
; *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
; *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
; *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
; *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
; *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
; *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
; *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
; *
;*/

;***********************************************************
; Version 3.00.00                                           
;***********************************************************
; Function:    hilb16
; Processor:   C55xx
; Description: Hilbert tansformer using FIR filter - single MAC approach
;
;
; Usage: ushort oflag = hilb16 (DATA *x,        // XAR0
;                               DATA *h,        // XAR1
;                               DATA *r,        // XAR2
;                               DATA *dbuffer,  // XAR3
;                               ushort nx,      // T0
;                               ushort nh)      // T1
; Notes:
;
; Benchmarks:
;   Cycles:       (nx * (nh/2 + 2)) + 41
;   Code Size (in bytes):  95
;
; History:
;  05/27/2012: Craig Leeds: Clean up housekeeping
;****************************************************************

      .ARMS_off                     ;enable assembler for ARMS=0
      .CPL_on                       ;enable assembler for CPL=1
      .mmregs                       ;enable mem mapped register names

; Stack frame
; -----------
RET_ADDR_SZ       .set 1            ;return address
REG_SAVE_SZ       .set 0            ;save-on-entry registers saved
FRAME_SZ          .set 0            ;local variables
ARG_BLK_SZ        .set 0            ;argument block

PARAM_OFFSET      .set ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ + RET_ADDR_SZ


; Register usage
; --------------
      .asg     AR0, x_ptr           ;linear pointer
      .asg     AR1, h_ptr           ;circular pointer
      .asg     AR2, r_ptr           ;linear pointer
      .asg     AR4, db_ptr          ;circular pointer

      .asg     BSA45, db_base       ;base addr for db_ptr
      .asg     XAR4, xdb_base       ;extended base addr for db_ptr
      .asg     BK47, db_sz          ;circ buffer size for db_ptr
      .asg     BK47_L, db_sz_L      ;for memory mapped access
      .asg     BSA01, h_base        ;base addr for h_ptr
      .asg     BK03, h_sz           ;circ buffer size for h_sz

      .asg     T0, oflag            ;returned value

ST2mask  .set  0000000000010010b    ;circular/linear pointers  (AR1LC, AR4LC)


      .global _hilb16

      .text
_hilb16:
;
; Allocate the local frame and argument block
;----------------------------------------------------------------
;      SP = SP - #(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ)
; - not necessary for this function (the above is zero)
;
; Save any save-on-entry registers that are used
; Configure the status registers as needed.
;----------------------------------------------------------------
      PSH     T3
   || BCLR    ARMS
      BSET    FRCT
      BCLR    SMUL
      BCLR    ACOV0
;
; Setup passed parameters in their destination registers
; Setup circular/linear CDP/ARx behavior
;----------------------------------------------------------------

; x pointer - passed in its destination register, need do nothing

; h pointer
      MOV     XAR3, xdb_base           ;db array address
      MOV     AR1, mmap(h_base)        ;base address of coefficients
      MOV     T1, mmap(h_sz)           ;coefficient array size

; r pointer - passed in its destination register, need do nothing

; Set circular/linear ARx behavior
      OR      #ST2mask, mmap(ST2_55)   ;config circ/linear pointers  (AR1LC, AR4LC)
; db pointer
      MOV     *AR3+, db_ptr            ;index of oldest db entry
      ADD     #1, T1, T3
      MOV     T3, mmap(db_sz)          ;db_sz = nh+1
      MOV     AR3, mmap(db_base)       ;base address for db_ptr
;
; Setup loop counts
;----------------------------------------------------------------
      SUB     #1, T0                   ;T0 = nx-1
   || MOV     #0, h_ptr                ;point to first coefficient
      MOV     T0, BRC0                 ;outer loop executes nx times
      SUB     #4, T1                   ;T1 = nh-4
      SFTS    T1, #-1                  ;T1 = (nh-4)/2
      MOV     T1, CSR                  ;inner loop executes (nh/2-2) times
;
; Setup step to 2 because of decimation
;
      AMOV    #2, T0                  ;circular buffer step = 2 
;
; Compute last iteration input pointer offsets
;----------------------------------------------------------------

;
; Start of outer loop
;----------------------------------------------------------------
      MOV    *x_ptr+, T3                                     ;get next input value (prime the pump)
    ||RPTBLOCAL LoopEnd-1                                    ;start the outer loop
              MOV    T3, *(db_ptr+T0)
              ;1st iteration
              MPYM   *(h_ptr+T0), T3, AC0      
              ;inner loop
            ||RPT    CSR
                      MACM *(db_ptr+T0), *(h_ptr+T0), AC0, AC0
              ;store result to memory
              MOV    RND(HI(AC0)), *r_ptr+                   ;store Q15 value to memory
           || MOV    *x_ptr+, T3                             ;get next input value (for next iteration)
LoopEnd:                                                     ;end of outer loop

;
; Update the db entry point
;----------------------------------------------------------------
      MOV     db_ptr, *-AR3              ;update 1st element of db array
;
; Check if overflow occurred, and setup return value
;----------------------------------------------------------------
    ||MOV     #0, oflag                  ;clear oflag
      XCCPART overflow(AC0)              ;clears ACOV0
          ||MOV    #1, oflag             ;overflow occurred
;
; Restore status regs to expected C-convention values as needed
;----------------------------------------------------------------
      AND     #0xFE00, mmap(ST2_55)      ;clear CDPLC and AR[7-0]LC (AR1LC, AR4LC)
      POP     T3
   || BSET    ARMS
      BCLR    FRCT
      BSET    SMUL
;
; Restore any save-on-entry registers that are used
;----------------------------------------------------------------
; - nothing to restore for this function

;
; Deallocate the local frame and argument block
;----------------------------------------------------------------
;      SP = SP + #(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ)
; - not necessary for this function (the above is zero)

;
; Return to calling function
;----------------------------------------------------------------
   || RET                                ;return to calling function

;----------------------------------------------------------------
;End of file
iircas32.asm/   1362765892  0     0     0       13130     `
;/*
; * Copyright (C) 2013 Texas Instruments Incorporated - http://www.ti.com/ 
; * 
; * 
; *  Redistribution and use in source and binary forms, with or without 
; *  modification, are permitted provided that the following conditions 
; *  are met:
; *
; *    Redistributions of source code must retain the above copyright 
; *    notice, this list of conditions and the following disclaimer.
; *
; *    Redistributions in binary form must reproduce the above copyright
; *    notice, this list of conditions and the following disclaimer in the 
; *    documentation and/or other materials provided with the   
; *    distribution.
; *
; *    Neither the name of Texas Instruments Incorporated nor the names of
; *    its contributors may be used to endorse or promote products derived
; *    from this software without specific prior written permission.
; *
; *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
; *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
; *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
; *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
; *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
; *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
; *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
; *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
; *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
; *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
; *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
; *
;*/

;***********************************************************
; Version 3.00.00                                           
;***********************************************************
; Function:	 iircas32
; Processor:   C55xx
; Description:  cascaded IIR direct form II using 5-coefs per biquad
;                using 32 bit coefficients and delay buffer
;
;  Usage:  short oflag iir32(DATA *x,LDATA *h,DATA *r,LDATA *d, 
;                            ushort nbiq, ushort nx);
;
; Notes;
;   dbuffer[] array size is ((4 * nbiq) + 2) words.
;   There are no alignment requirements of the arrays.
;
; Benchmarks:
;   Cycles:       (nx * ((24 * nbiq) + 8)) + 28
;   Code Size (in bytes):  181
;
; History
; 2.40 Cleared XDP instead of DP register
;      Zhengting He - 10/25/2006
;
; 3.00 Fixed overflow handling.  Optimized.
;      Craig Leeds - 05/28/2012
; 
;*****************************************************************************
;
;
;	IIR Biquad Structure
;
;                  d(n)         
;  x(n) ---> + -----.-----x-- + --> y(n)
;           /|      |    b0   |\
;          | |    [z-1]       | |
;          | |      |         | |
;          | |      v         | | 
;          | |--x-d(n-1)--x---| |         
;          |  -a1   |    b1     | 
;          |        |           |
;          |      [z-1]         |
;          |        |           |
;          |        v           |
;          |---x--d(n-2)--x-----|
;            -a2         b2 
;
;              "FB"   "FF"
;
;
;        "FB" = Feedback Terms
;        "FF" = Feedforward Terms
;
;
; Algorithm (for single biquad)
; -----------------------------
;  d(n) = x(n) - a1*d(n-1) - a2*d(n-2)
;  y(n) = b0*d(n) + b1*d(n-1) + b2*d(n-2)
; 
;
; Function Call
; -------------
;
;  short oflag iir32(DATA *x,LDATA *h,DATA *r,LDATA *d, ushort nbiq, ushort nx);
;
;   where:
; x[nx]: PASSED in XAR0.					16 bit
;        Pointer to input vector of nx real elements.  
;        x(0) is the first input, 
;        while x(nx-1) is the last input.
;        
; h[2(5*nbiq)]: PASSED in XAR1.				32 bit
;        Pointer to longword filter coefficient vector with the following format:
;        H = a11 a21 b21 b01 b11 ....a1i a2i b2i b0i b1i
;         where i is the biquad index.
;         (i.e. a21: is the a2 coefficient of biquad 1). 
;         Pole (recursive) coefficients = a. 
;         Zero (non-recursive) coefficients = b
;
;        This array must be located in internal memory if it is 
;        accessed by the C55xx coefficient bus.
;
; r[nx]: PASSED in XAR2.					16 bit
;        Pointer to output vector of nx real elements.  
;        In-place computation (r = x) is allowed.  r(0) is the first 
;        output, while r(nx-1) is the last output.
;
; dbuffer[(2*nbiq) + 1]: PASSED in XAR3.	32 bit
;        Pointer to longword delay buffer of length 2*nbiq + 1.  See figure 
;        below for organization. In the case of multiple-buffering schemes, 
;        this array should be initialized to 0 for the first filter block 
;        only.  Between consecutive blocks, the delay buffer preserves the 
;        previous elements needed.
;
;        The first element in this array is special in that it 
;        contains the array index of the first buffer element in the 
;        delay buffer.  This is needed for multiple-buffering schemes, 
;        and should be initialized to zero (like all the other array 
;        entries) for the first block only.
;
; nbiq:  PASSED in T0.
;        The number of biquads making up the filter.  
;
; nx:    PASSED in T1.
;        Number of elements in the input and output vectors
;
; oflag: RETURNED in T0.
;        Overflow error flag  (returned value)
;         = 1 if a 32-bit data overflow occurred in an intermediate 
;             or final result.
;         = 0 if no such overflow occurred.
;
;
; Memory and Pointer Use Definition
; ---------------------------------
;
;              "x[nx]"                  "r[nx]"
;      AR0(x)--> x(0)            AR2(r)-->r(0)     first
;                x(1)                     r(1)
;                x(2)                     r(2)
;                 :                        :
;                 :                        :
;                x(nx-1)                  r(nx-1)  last
;
;
;      "dbuffer[2*(2*nbiq+2)]"        "h[2*(5*nbiq)]"
;               index             AR1(h)->b21H
;               dummy                     b21L 
;       R3(dn)-->d21L                     b11H
;               d21H                      b11L
;               d11L                      b01H
;               d11H                      b01L
;               d22L                      a21H
;               d22H                      a21L
;               d12L                      a11H
;               d12H                      a11L
;                :                         :
;               d1nH                       :
;               extra 
;               dummy
;
;      Def: dij / aij / bij  where i = delay #
;                                  j = biquad #


	.arms_off
	.mmregs
        .noremark 5684    ; CPU_116: BRC1 not written indirectly in outer loop

;******************************************
;*       Assigns
;******************************************
	.def	_iir32

;******************************************
;*       Constant Defines
;******************************************

;******************************************
;*       Variable Declarations
;******************************************

;**********************************************************************
; Program section
;**********************************************************************
	.text
_iir32:
;Context save
        psh     T3, T2
     || bset    FRCT, ST1_55            ;fractional mode enable
        pshboth XAR5
     || bset    AR3LC, ST2_55           ;init AR3 = circular (dbuffer)
        pshboth XAR7
     || bclr    ARMS
        bset    M40
        bclr    ACOV0

;Initialization
    
;Save pointer to index at dbuffer[0]    
        mov     XAR3, XAR5

; Setup loop counters
        sub     #1, T1, T3              ;compute nx-1
        mov     T3, BRC0                ;init outer loop counter (nx-1)
        
        sub     #1, T0, T3              ;init inner loop counter (#bi-quads-1)
        mov     T3, BRC1

; Setup circular addressing
        mov     #4, BK03                ;init AR0-3 circular buf size (2 delay elements)
        mov     *AR5, AR3               ;init AR3 offset to buffer start
     || add     #2, AR5                 ;adjust AR5 to buffer start address (d20L)

        mov     XAR1, XAR7              ;save coeff buffer start address to reinit pntr

; Setup offset registers
        amov    #3, T0                  ;b0 bypass index
     || mov     #5, T1                  ;b0 pick up index
        
; Kernel
;  XAR0: x[] input (16 bit)
;  XAR1: h[] coefficients (32 bit: H/L)
;  XAR2: r[] result (16 bit)
;  XAR3: dbuffer[] (32 bit: H/L)
;  XAR5: dbuffer d2jL pointer 
;  XAR7: reinit XAR1
;
;                                                               
; BIQUAD's are calculated as follows                            
;    tmp = b2*d[n-2] + b1*d[n-1]                                
;    d[n] = x[n] or y[n]   (depending on BIQUAD)                
;    d[n] = d[n] - a2*d[n-2] - a1*d[n-1] 
;    store new d[n]                        
;    y[n] = b0*d[n] + tmp
;    store y[n]
;
; Note: u---L * u---L not needed for 32 bit result. 
;        Saves one MAC per tap.
;----------------------------------------------------------------                                                               

;  for(i=0; i<nx; i++)
        rptblocal OuterLoopEnd-1                             ; Outer Loop: Process a new input
                 mov    AR5, mmap(BSA23)                     ; 
; HI(AC0) = x(n)
                 mov    *AR0+ << #16, AC0        
;      for(j=0; j<nbiq; j++)
              || rptblocal InnerLoopEnd-1                    ; Inner Loop: Process a bi-quad

; AC2 = b2 * d[n-2]
                        NOP_16                               ; CPU_116: Remark 5684
                     || mpym    *AR1, uns(*AR3+), AC3        ; b2jH * ud2jL
                        mpym    *AR1+, *AR3, AC2             ; b2jH * d2jH
                        macm    uns(*AR1+), *AR3+, AC3       ; ub2jL * d2jH
                        add     AC3 << #-16, AC2
                
; AC2 += b1 * d[n-1]
                     || mpym    *AR1, uns(*AR3+), AC3        ; b1jH * ud1jL        
                        macm    *AR1+, *AR3, AC2             ; b1jH * d1jH
                        macm    uns(*(AR1+T0)), *AR3+, AC3   ; ub1jL * d1jH
                        add     AC3 << #-16, AC2
;   AR3 circular addressing -> last d2jL
;   AR1+index -> a2jH 
;    (skip b0j temporarily)

; AC0 -= a2 * d[n-2]
                     || mpym    *AR1, uns(*AR3+), AC1        ; a2jH * ud2jL        
                        masm    *AR1+, *AR3, AC0             ; a2jH * d2jH
                        macm    uns(*AR1+), *AR3+, AC1       ; ua2jL * d2jH
                        sub     AC1 << #-16, AC0

; d[n] = AC0 -= a1 * d[n-1]
                     || mpym    *AR1, uns(*AR3+), AC1        ; a1jH * ud1jL        
                        masm    *AR1+, *AR3, AC0             ; a1jH * d1jH
                        macm    uns(*(AR1-T1)), *AR3+, AC1   ; ua1jL * d1jH
                        sub     AC1 << #-16, AC0
;   AR3 circular addressing -> last d2jL
;   AR1-index -> b0jH

;   Replace d[n-2] with new d[n]
                        sat     AC0                          ; probably not necessary
                        mov     AC0, *AR3+                   ; d0jL
                        mov     HI(AC0), *AR3-               ; d0jH

; AC0 = b0 * d[n]
                     || mpym    *AR1, AC0                    ; b0jH * d0jH
                        mpym    *AR1+, uns(*AR3+), AC1       ; b0jH * ud0jL
                        macm    uns(*AR1+), *AR3-, AC1       ; ub0jL * d0jH
                        add     #4, mmap(BSA23)                
                        add     AC1 << #-16, AC0
;   AR3 adjusted -> last d2jH

; y[n] = AC0 += AC2
;  or input to next biquad
                        add     AC2, AC0

;   update AR1 -> b2jH
                     || aadd    #4, AR1                        ; 
InnerLoopEnd:

                amov    AR7, AR1                        ; reinitialize coeff pointer
             || mov     rnd(HI(saturate(AC0))), *AR2+   ; store result to output buffer
                aadd    #2, AR3                         ; Adjust dbuffer offset for next sample
OuterLoopEnd:
;  end of outer loop

        asub    #2, AR5

;Signal overflow check
     || mov     #0, T0
        xccpart overflow(AC0)
            ||mov   #1, T0

;Save last index value
        mov     AR3, *AR5                ; save index to dbuffer[0]

;Context restore
     || popboth XAR7
        popboth XAR5
     || bclr    AR3LC, ST2_55            ; restore for C
        pop     T3, T2
     || bset    ARMS                     ; restore for C
        bclr    FRCT, ST1_55             ; restore for C
        ret
     || bclr    M40                      ; restore for C


 iircas4.asm/    1362765892  0     0     0       12950     `
;/*
; * Copyright (C) 2013 Texas Instruments Incorporated - http://www.ti.com/ 
; * 
; * 
; *  Redistribution and use in source and binary forms, with or without 
; *  modification, are permitted provided that the following conditions 
; *  are met:
; *
; *    Redistributions of source code must retain the above copyright 
; *    notice, this list of conditions and the following disclaimer.
; *
; *    Redistributions in binary form must reproduce the above copyright
; *    notice, this list of conditions and the following disclaimer in the 
; *    documentation and/or other materials provided with the   
; *    distribution.
; *
; *    Neither the name of Texas Instruments Incorporated nor the names of
; *    its contributors may be used to endorse or promote products derived
; *    from this software without specific prior written permission.
; *
; *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
; *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
; *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
; *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
; *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
; *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
; *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
; *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
; *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
; *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
; *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
; *
;*/

;***********************************************************
; Version 3.00.00                                           
;***********************************************************
;  Function:	 iircas4
;  Description:  cascaded IIR direct form II using 4-coefs per biquad
;
;  Usage: short oflag = iircas4(DATA *x, DATA *h, DATA *r, DATA *dbuffer, 
;                               ushort nbiq, ushort nx)
;
; Notes:
;   If h[] is in SARAM instead of DARAM, the function will take twice 
;   as many cycles.
;
; Limitations:
;   nbiq must be even.
;   dbuffer[] must be on-chip (i.e. in DARAM or SARAM).
;
; Benchmarks:
;   Cycles:       (nx * ((3 * nbiq) + 2)) + 56
;   Code Size (in bytes):  145
;-----------------------------------------------------------------------------
; Revision History:
; 1.00  T. Horner, 2/15/00. Original version. Started from code by Rosemarie 
;   Piedra, Greg Peake, and Karim Djafarian.
; 1.01  Li Yuan, 6/13/00. Fixed pop up order error.
; 2.00  C. Iovescu, 5/20/02 Modified implementation to use Dual Mac
; 2.10 Cesar I. optimized code for benchmark purpose. 08/03/01
;
; 2.40 Cleared XDP instead of DP register
;      Zhengting He - 10/25/2006
;
; 3.00 Fixed overflow checking.
;      Fixed dbuffer index.
;      Craig Leeds - 06/28/2012
;*****************************************************************************
;*****************************************************************************
;
;
;	IIR Biquad Structure
;
;                  d(n)         
;  x(n) ---> + -----.----- + --> y(n)
;           /|      |      |\
;          | |    [z-1]    | |
;          |        |        |
;          | |      v      | | 
;          | |--x-d(n-1)-x-| |         
;          |  -a1   |   b1   | 
;          |        |        |
;          |      [z-1]      |
;          |        |        |
;          |        v        |
;          |---x--d(n-2)--x--|
;            -a2         b2
;
;              "FB"   "FF"
;
;
;        "FB" = Feedback Terms
;        "FF" = Feedforward Terms
;
;
; Algorithm (for single biquad)
; -----------------------------
;  d(n) = x(n) - a1*d(n-1) - a2*d(n-2)
;  y(n) = d(n) + b1*d(n-1) + b2*d(n-2)
;
;
; Function Call
; -------------
;
;  short oflag = iircas4(DATA *x, DATA *h, DATA *r, DATA *dbuffer, ushort nbiq,
;                        ushort nx)
;
;   where:
; x[nx]: PASSED in XAR0.
;        Pointer to input vector of nx real elements.  
;        x(0) is the first input, 
;        while x(nx-1) is the last input.
;        
; h[4*nbiq]: PASSED in XAR1.
;        Pointer to filter coefficient vector with the following format:
;        H = a11 a21 b21 b11 ....a1i a2i b2i b1i
;         where i is the biquad index.
;         (i.e. a21: is the a2 coefficient of biquad 1). 
;         Pole (recursive) coefficients = a. 
;         Zero (non-recursive) coefficients = b
;
;        This array must be located in internal memory if it is 
;        accessed by the C55xx coefficient bus.
;
; r[nx]: PASSED in XAR2.
;        Pointer to output vector of nx real elements.  
;        In-place computation (r = x) is allowed.  r(0) is the first 
;        output, while r(nx-1) is the last output.
;
; dbuffer[2*nbiq + 2]: PASSED in XAR3.
;        Pointer to delay buffer of length 2*nbiq.  See figure below for  
;        organization. In the case of multiple-buffering schemes, this 
;        array should be initialized to 0 for the first filter block only. 
;        Between consecutive blocks, the delay buffer preserves the 
;        previous elements needed.
;
;        The first element in this array is special in that it 
;        contains the array index of the first buffer element in the 
;        delay buffer.  This is needed for multiple-buffering schemes, 
;        and should be initialized to zero (like all the other array 
;        entries) for the first  block only.
;
; nbiq:  PASSED in T0.
;        The number of biquads making up the filter.  
;
; nx:    PASSED in T1.
;        Number of elements in the input and output vectors
;
; oflag: RETURNED in T0.
;        Overflow error flag  (returned value)
;         = 1 if a 32-bit data overflow occurred in an intermediate 
;             or final result.
;         = 0 if no such overflow occurred.
;
;
; Memory and Pointer Use Definition
; ---------------------------------
;
;              "x[nx]"                  "r[nx]"
;      AR0(x)--> x(0)            AR2(r)-->r(0)     newest
;                x(1)                     r(1)
;                x(2)                     r(2)
;                 :                        :
;                 :                        :
;                x(nx-1)                  r(nx-1)  oldest
;
;
;      "dbuffer[2*nbiq+1]"            "h[4*nbiq]"
;                index            AR1(h)->a11
;      AR3(dn)-->d11                      b11 
;                d21                      a21
;                 :                       b21
;                dn1                      
; 				 dn2                      a12
;                                         b12
;                                         a22
;                                         b22
;                                          :
;                                         a1i
;                                         b1i
;                                         a2i
;                                         b2i
;
;      Def: dij / aij / bij  where i = delay #
;                                  j = biquad #

	.arms_off
	.cpl_on
	.mmregs    
	.noremark  5684    ; CPU_116: BRC1 not written indirectly
;******************************************
;*       Assigns
;******************************************
	.def	_iircas4

;******************************************
;*       Constant Defines
;******************************************
SCALE	.set	0

;******************************************
;*       Variable Declarations
;******************************************

;----------------------------------------------------------------
; Assign auxiliary registers for temporaries and address
; calculations.
;----------------------------------------------------------------
	.asg     CDP, db_ptr        ;circular pointer
 	.asg     AR0, in_ptr        ;linear pointer
 	.asg     AR1, h_ptr         ;circular pointer
 	.asg     AR2, out_ptr       ;linear pointer
        .asg     AR3, index         ;
	.asg     AR4, tap_updt      ;circular pointer

;**********************************************************************
; Program section
;**********************************************************************
	.text
_iircas4:
;Context save

; Configure the status registers as needed.
;----------------------------------------------------------------
        PSH     mmap(ST2_L)            ; save ARMS, AR1LC, AR4LC, CDPLC
        PSH     T2, T3
     || BSET    #CDPLC, ST2_55         ;init CDP = circular (dbuffer)    
        PSHBOTH XAR5
     || BSET    #AR1LC, ST2_55         ;init AR1 = circular (dbuffer)

;Initialization   
        BSET    #AR4LC, ST2_55         ;init AR4 = circular (coeff)
        BCLR    #ARMS, ST2_55
        MOV     XAR3, XAR5 
        BSET    FRCT
        BCLR    ACOV0                  ; clear overflow bit 
        BCLR    ACOV1                  ; clear overflow bit 
    
;Save pointer to index at dbuffer[0]    

;Restore index of the current dbuffer location
        MOV     *AR3, AR3 

; Setup circular addressing for db_ptr (CDP) and tap_updt (AR4)
     || MOV     T0, T3                 ;compute 2*nbiq
        SFTL    T3, #1
        ADD     #1, T3 
        MOV     T3, mmap(BKC)          ;init CDP circular buf size (2*nbiq+1)
        MOV     T3, mmap(BK47)         ;init AR4 circular buf size (2*nbiq+1)
        ADD     #1, AR5 
        MOV     AR5, mmap(BSAC)        ;init CDP circular start addr: dbuffer
        MOV     AR5, mmap(BSA45)
        MOV     XAR3, XCDP             ; MOV index, db_ptr
     
        AMAR    *db_ptr+
    
        MOV     XAR3, XAR4             ;MOV index, tap_updt

 ; Setup circular addressing for h_ptr (AR1)
        MOV     T0,T3                  ;compute 4*nbiq
        SFTL    T3, #1   
        SFTL    T3, #1
        MOV     T3, mmap(BK03)         ;init AR0-3 circular buf size (4*nbiq)
        MOV     AR1, mmap(BSA01)       ;init AR0-1 circular start addr: coeff
        MOV     #0, AR1
 
 ; Store loop counters 
            
        SUB     #1, T1,T3              ;compute nx-1
        MOV     T3, BRC0               ;init outer loop counter (nx-1)                
        
        MOV     T0, T3                 ;init inner loop counter (#bi-quads/2-1)
        SFTL    T3, #-1 
     || AMOV    #1, T0
        SUB     #1, T3
     || AMOV    #2, T1 
        MOV     T3, BRC1  

; Define Address indexes 

; Define scale factor
        MOV     #SCALE, T2             ;scale factor
; Kernel
;  XAR0: x[] input
;  XAR1: h[] coefficients
;  XAR2: r[] result
;  XAR3: dbuffer[]
;  XAR7: reinit XAR1

     || RPTBLOCAL outer_loop-1                       ; Outer Loop: Process a new input

                MOV     *in_ptr+ << #16, AC0                   ; HI(AC0) = x(n)
             || RPTBLOCAL inner_loop-1                         ; Inner Loop: Process a bi-quad
       
                        MAS     *(h_ptr+T1), *db_ptr+, AC0     ; AC0 = x(n) - a1*d(n-1)
                        ::MPY   *h_ptr(T0), *db_ptr+, AC1      ; AC1 = b1*d(n-1)
                       
                        MAS     *(h_ptr+T1), *db_ptr+, AC0     ; AC0=d(n)=x(n)-a1*d(n-1)-a2*d(n-2)
                        ::MAC   *h_ptr(T0), *db_ptr+, AC1      ; AC1=b1*d(n-1)+b2*d(n-2)
                       
                        MOV     HI(AC0<<T2), *(tap_updt+T1)    ; T1 = #2 , X2 
                     || ADD     AC1, AC0                       ; AC0 =  d(n) + b1*d(n-1) + b2*d(n-2)
         
                        ; Beginning of second Biquad
                    
                        MAS     *(h_ptr+T1), *db_ptr+, AC0     ; AC0 = x(n) - a1*d(n-1)
                        ::MPY   *h_ptr(T0), *db_ptr+, AC1      ; AC1 = b1*d(n-1)
 
                        MAS     *(h_ptr+T1), *db_ptr+, AC0     ; AC0=d(n)=x(n)-a1*d(n-1)-a2*d(n-2)
                        :: MAC  *h_ptr(T0), *db_ptr+, AC1      ; AC1=b1*d(n-1)+b2*d(n-2)
      
                        MOV     HI(AC0<<T2), *(tap_updt+T1)    ; T1 = #2 , T2 = #SCALE 
                      ||ADD     AC1, AC0
inner_loop:  
             
                MOV     rnd(HI(AC0)), *out_ptr+                ; store result to output buf
outer_loop:      
       
;Signal overflow
        MOV     #0, T0
        XCCPART overflow(AC0) 
             || MOV     #1,T0 
        XCCPART overflow(AC1) 
             || MOV     #1,T0 
;Save last index value
        MOV     tap_updt, *-AR5                                ; save index to dbuffer[0]
;Context restore
        POPBOTH XAR5
      ||BCLR    FRCT
        POP     T2, T3
        POP     mmap(@ST2_L)        ; restore ARMS, AR1LC, AR4LC, CDPLC
        RET


 iircas5.asm/    1362765892  0     0     0       9728      `
;/*
; * Copyright (C) 2013 Texas Instruments Incorporated - http://www.ti.com/ 
; * 
; * 
; *  Redistribution and use in source and binary forms, with or without 
; *  modification, are permitted provided that the following conditions 
; *  are met:
; *
; *    Redistributions of source code must retain the above copyright 
; *    notice, this list of conditions and the following disclaimer.
; *
; *    Redistributions in binary form must reproduce the above copyright
; *    notice, this list of conditions and the following disclaimer in the 
; *    documentation and/or other materials provided with the   
; *    distribution.
; *
; *    Neither the name of Texas Instruments Incorporated nor the names of
; *    its contributors may be used to endorse or promote products derived
; *    from this software without specific prior written permission.
; *
; *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
; *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
; *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
; *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
; *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
; *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
; *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
; *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
; *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
; *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
; *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
; *
;*/

;***********************************************************
; Version 3.00.00                                           
;***********************************************************
; Function:	 iircas5
; Processor:   C55xx
; Description:  cascaded IIR direct form II using 5-coefs per biquad
;
;  Usage: short oflag = iircas5(DATA *x, DATA *h, DATA *r, DATA *dbuffer, 
;                              ushort nbiq, ushort nx)
;
; Benchmarks:
;   Cycles:       (nx * ((6 * nbiq) + 2)) + 28
;   Code Size (in bytes):  87
;
; History
; 2.40 Cleared XDP instead of DP register
;      Zhengting He - 10/25/2006
;
; 3.00 Clear ACOV0 on entry.  Optimize outer loop
;      Craig Leeds - 5/29/2012
;*****************************************************************************
;
;
;	IIR Biquad Structure
;
;                  d(n)         
;  x(n) ---> + -----.-----x-- + --> y(n)
;           /|      |    b0   |\
;          | |    [z-1]       | |
;          | |      |         | |
;          | |      v         | | 
;          | |--x-d(n-1)--x---| |         
;          |  -a1   |    b1     | 
;          |        |           |
;          |      [z-1]         |
;          |        |           |
;          |        v           |
;          |---x--d(n-2)--x-----|
;            -a2         b2 
;
;              "FB"   "FF"
;
;
;        "FB" = Feedback Terms
;        "FF" = Feedforward Terms
;
;
; Algorithm (for single biquad)
; -----------------------------
;  d(n) = x(n) - a1*d(n-1) - a2*d(n-2)
;  y(n) = b0*d(n) + b1*d(n-1) + b2*d(n-2)
; 
;
; Function Call
; -------------
;
;  short oflag = iircas5(DATA *x, DATA *h, DATA *r, DATA *dbuffer, ushort nbiq,
;                        ushort nx)
;
;   where:
; x[nx]: PASSED in XAR0.
;        Pointer to input vector of nx real elements.  
;        x(0) is the first input, 
;        while x(nx-1) is the last input.
;        
; h[5*nbiq]: PASSED in XAR1.
;        Pointer to filter coefficient vector with the following format:
;        H = a11 a21 b21 b01 b11 ....a1i a2i b2i b0i b1i
;         where i is the biquad index.
;         (i.e. a21: is the a2 coefficient of biquad 1). 
;         Pole (recursive) coefficients = a. 
;         Zero (non-recursive) coefficients = b
;
;        This array must be located in internal memory if it is 
;        accessed by the C55xx coefficient bus.
;
; r[nx]: PASSED in XAR2.
;        Pointer to output vector of nx real elements.  
;        In-place computation (r = x) is allowed.  r(0) is the first 
;        output, while r(nx-1) is the last output.
;
; dbuffer[2*nbiq]: PASSED in XAR3.
;        Pointer to delay buffer of length 2*nbiq.  See figure below for  
;        organization. In the case of multiple-buffering schemes, this 
;        array should be initialized to 0 for the first filter block only. 
;        Between consecutive blocks, the delay buffer preserves the 
;        previous elements needed.
;
; nbiq:  PASSED in T0.
;        The number of biquads making up the filter.  
;
; nx:    PASSED in T1.
;        Number of elements in the input and output vectors
;
; oflag: RETURNED in T0.
;        Overflow error flag  (returned value)
;         = 1 if a 32-bit data overflow occurred in an intermediate 
;             or final result.
;         = 0 if no such overflow occurred.
;
;
; Memory and Pointer Use Definition
; ---------------------------------
;
;              "x[nx]"                  "r[nx]"
;      AR0(x)--> x(0)            AR2(r)-->r(0)     first
;                x(1)                     r(1)
;                x(2)                     r(2)
;                 :                        :
;                 :                        :
;                x(nx-1)                  r(nx-1)  last
;
;
;      "dbuffer[2*nbiq]"            "h[5*nbiq]"
;                                 AR1(h)->a11
;      AR3(dn)-->d11                      a21 
;                d12                      b21
;                 :                       b01
;                d1n                      b11
;                d21                      a12
;                d22                      a22
;                 :                       b22
;                d2n                      b02
;                                         b12
;                                          :
;                                         a1i
;                                         a2i
;                                         b2i
;                                         b0i
;                                         b1i
;
;      Def: dij / aij / bij  where i = delay #
;                                  j = biquad #


	.arms_on
	.cpl_on
	.mmregs
        .noremark 5684    ; CPU_116: No indirect write to BRC1
;******************************************
;*       Assigns
;******************************************
	.def	_iircas5

;******************************************
;*       Constant Defines
;******************************************
SCALE	.set	0

;******************************************
;*       Variable Declarations
;******************************************

;**********************************************************************
; Program section
;**********************************************************************
	.text
_iircas5:
;Context save
        PSH     T2,T3
;Initialization
     || BSET    FRCT               ;fractional mode enable
        BCLR    ACOV0              ; clear overflow bit 
    
; Setup circular addressing
        AMAR    *AR3(1), XAR4      ; point AR4 to beginning of dbuffer data &dbuffer[1]
        MOV     T0, T3             ;compute 2*nbiq
        SFTS    T3, #1
        MOV     T3, mmap(BK47)     ;init AR7-7 circular buf size (2*nbiq)

        MOV     AR4, mmap(BSA45)   ;init AR4-5 circular start addr: dbuffer(0)

        BSET    AR4LC              ;init AR4 = circular (dbuffer)
        MOV     *AR3, AR4               
     || SUB     #1, T1             ;compute nx-1
        MOV     T1, BRC0           ;init outer loop counter (nx-1)                

        MOV     AR1, T2            ;save original value to reinitialize coeff buffer pntr
        
        SUB     #1, T0, T3         ;init inner loop counter (#bi-quads-1)
        MOV     T3, BRC1   

        
; Kernel
;  XAR0: x[] input
;  XAR1: h[] coefficients
;  XAR2: r[] result
;  XAR4: dbuffer[0]  (pointer to index)
;  XAR4: dbuffer[]  (circular)
;  T2:   reinit XAR1

        RPTBLOCAL OuterLoopEnd-1                  ; Outer Loop: Process a new input
                MOV     *AR0+ << #16, AC0         ; HI(AC0) = x(n)
              ||RPTBLOCAL InnerLoopEnd-1                  ; Inner Loop: Process a bi-quad
                        MASM    *(AR4+T0), *AR1+, AC0     ; AC0 -= a1*d(n-1)      (1) 
                        MASM    T3 = *AR4, *AR1+, AC0     ; AC0 -= a2*d(n-2)      (2)
                        MOV     HI(AC0), T1
                     || MOV     HI(AC0), *(AR4+T0)        ; d(n) replaces d(n-2)
                        MPYM    *AR1+, T3, AC0            ; AC0 = b2*d(n-2)       (3)
                        MACM    *AR1+, T1, AC0            ; AC0 += b0*d(n)        (4)
                        MACM    *AR4+, *AR1+, AC0         ; AC0 += b1*d(n-1)      (5)
                                                          ; input to next biquad
InnerLoopEnd:

                AMOV    T2, AR1                  ; reinitialize coeff pointer
             || MOV     rnd(HI(AC0)), *AR2+       ; store result to output buffer
OuterLoopEnd:

;Signal overflow
        MOV     AR4, *AR3                                ; save index to dbuffer[0]
     || MOV     #0, T0
        XCCPART overflow(AC0)
            ||MOV   #1, T0

;Context restore
        POP     T2,T3
     || BCLR    AR4LC                ; restore AR4LC for C
        RET
     || BCLR    FRCT                 ; restore FRCT for C

iircas51.asm/   1362765892  0     0     0       10756     `
;/*
; * Copyright (C) 2013 Texas Instruments Incorporated - http://www.ti.com/ 
; * 
; * 
; *  Redistribution and use in source and binary forms, with or without 
; *  modification, are permitted provided that the following conditions 
; *  are met:
; *
; *    Redistributions of source code must retain the above copyright 
; *    notice, this list of conditions and the following disclaimer.
; *
; *    Redistributions in binary form must reproduce the above copyright
; *    notice, this list of conditions and the following disclaimer in the 
; *    documentation and/or other materials provided with the   
; *    distribution.
; *
; *    Neither the name of Texas Instruments Incorporated nor the names of
; *    its contributors may be used to endorse or promote products derived
; *    from this software without specific prior written permission.
; *
; *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
; *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
; *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
; *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
; *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
; *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
; *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
; *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
; *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
; *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
; *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
; *
;*/

;***********************************************************
; Version 3.00.00                                           
;***********************************************************
; Function:	 iircas51
; Processor:   C55xx
; Description:  cascaded IIR direct form II using 5-coefs per biquad
;
; Usage:  short oflag = iircas51(DATA *x, DATA *h, DATA *r, DATA *dbuffer, 
;                                ushort nbiq, ushort nx)
;
; Benchmarks:
;   Cycles:       (nx * ((7 * nbiq) + 3)) + 37
;   Code Size (in bytes):  128
;
; History
; 2.40 Cleared XDP instead of DP register
;      Zhengting He - 10/25/2006
; 3.00 Clear AC0V0 on entry for overflow testing.  Optimize.
;      Craig Leeds - 05/29/2012
;*****************************************************************************
;
;
;	IIR Biquad Structure
;
;                          
;  x(n) ------.-----x-->+ -------> + -----.---------> y(n)
;             |    b0   |\        /|      |       
;           [z-1]       | |      | |    [z-1]     
;             |         | |      | |      |       
;             v         | |      | |      v       
;           x(n-1)--x---| |      | |--x-d(n-1)           
;             |    b1     |      |  -a1   |       
;             |           |      |        |       
;           [z-1]         |      |      [z-1]     
;             |           |      |        |       
;             v           |      |        v       
;           x(n-2)--x-----|      |---x--d(n-2)    
;                  b2              -a2            
;            
;                 "FF"             "FB"
;
;
;        "FB" = Feedback Terms
;        "FF" = Feedforward Terms
;
;
; Algorithm (for single biquad)
; -----------------------------
;  y(n)= b0*x(n) + b1*x(n-1) + b2*x(n-2) - a1*y(n-1) - a2*y(n-2)
; 
;
; Function Call
; -------------
;
;  short oflag = iircas51(DATA *x, DATA *h, DATA *r, DATA *dbuffer, ushort nbiq,
;                        ushort nx)
;
;   where:
; x[nx]: PASSED in XAR0.
;        Pointer to input vector of nx real elements.  
;        x(0) is the first input, 
;        while x(nx-1) is the last input.
;        
; h[5*nbiq]: PASSED in XAR1.
;        Pointer to filter coefficient vector with the following format:
;        H = b01 b11 b21 a11 a21 ....b0i b1i b2i a1i a2i
;         where i is the biquad index.
;         (i.e. a21: is the a2 coefficient of biquad 1). 
;         Pole (recursive) coefficients = a. 
;         Zero (non-recursive) coefficients = b
;
;        This array must be located in internal memory if it is 
;        accessed by the C55xx coefficient bus.
;
; r[nx]: PASSED in XAR2.
;        Pointer to output vector of nx real elements.  
;        In-place computation (r = x) is allowed.  r(0) is the first 
;        output, while r(nx-1) is the last output.
;
; dbuffer[1+4*nbiq]: PASSED in XAR3.
;        Pointer to delay buffer of length 4*nbiq.  See figure below for  
;        organization. In the case of multiple-buffering schemes, this 
;        array should be initialized to 0 for the first filter block only. 
;        Between consecutive blocks, the delay buffer preserves the 
;        previous elements needed.
;
;
; nbiq:  PASSED in T0.
;        The number of biquads making up the filter.  
;
; nx:    PASSED in T1.
;        Number of elements in the input and output vectors
;
; oflag: RETURNED in T0.
;        Overflow error flag  (returned value)
;         = 1 if a 32-bit data overflow occurred in an intermediate 
;             or final result.
;         = 0 if no such overflow occurred.
;
;
; Memory and Pointer Use Definition
; ---------------------------------
;
;              "x[nx]"                  "r[nx]"
;      AR0(x)--> x(0)            AR2(r)-->r(0)     first
;                x(1)                     r(1)
;                x(2)                     r(2)
;                 :                        :
;                 :                        :
;                x(nx-1)                  r(nx-1)  last
;
;
;      "dbuffer[4*nbiq]"            "h[5*nbiq]"
;                                 AR1(h)->b01
;      AR3(xn)-->x11                      b11 
;                x12                      b21
;                 :                       a11
;                x1n                      a21
;                x21                      b02
;                x22                      b12
;                 :                       b22
;                x2n                      a12
;      AR4(yn)-->y11                      a22
;                y12                       :
;                 :                       b0i
;                y1n                      b1i
;                y21                      b2i
;                y22                      a1i
;                 :                       a2i
;                y2n
;               
;
;      Def: xij/yij/aij/bij  where i = delay #
;                                  j = biquad #


	.arms_off
	.cpl_on
	.mmregs
        .noremark 5684   ; BRC1 not modified indirectly

;******************************************
;*       Assigns
;******************************************
	.def	_iircas51

;******************************************
;*       Constant Defines
;******************************************

;******************************************
;*       Variable Declarations
;******************************************

;**********************************************************************
; Program section
;**********************************************************************
	.text
_iircas51:
;Context save
;initialization

        PSH     T3, T2
     || BCLR    ARMS
        PSHBOTH XAR6
     || BSET    FRCT                   ;fractional mode enable
        PSHBOTH XAR7
     || BCLR    ACOV0                  ; clear overflow bit 
        BCLR    ACOV1                  ; clear overflow bit 

;setup circular addressing in AR6 and AR4
        MOV     T0, T3                 ;compute 2*nbiq
        SFTS    T3, #1
        MOV     T3, mmap(BK47)         ;init AR4-7 circular buf size (2*nbiq)
        AMAR    *AR3(1), XAR6          ; set AR6H (and skip over pointer)
        MOV     XAR6, XAR4             ;adjust AR4 to buffer start
        MOV     AR6, mmap(BSA67)       ;init AR6-7 circular start addr: dbuffer(1)
        
        ADD     T3, AR4
        MOV     AR4, mmap(BSA45)       ;init AR45 circ start addr: dbuffer(2*nbiq)
        BSET    AR4LC                  ;init AR4 = circular (dbuffer)
        BSET    AR6LC                  ;init AR6 = circular (dbuffer)

        SUB     #1, T1, T3             ;compute nx-1
        MOV     *AR3, AR6              ;init AR6 offset to x(n) buffer start
        MOV     T3, BRC0               ;init outer loop counter (nx-1)
        MOV     AR6, AR4               ;init AR4 offset to y(n) buffer start

        MOV     XAR1, XAR7             ;save original value to reinitialize coeff buffer pntr

        SUB     #1, T0, T3             ;init inner loop counter (#bi-quads-1)
        MOV     T3, BRC1

        ADD     #1, T0, T1             ;index for buffer reset

; Kernel
;  XAR0: x[] input
;  XAR1: h[] coefficients
;  XAR2: r[] result
;  XAR4: dbuffer[y]
;  XAR6: dbuffer[x]
;  XAR7: reinit XAR1

     || RPTBLOCAL OuterLoopEnd-1                          ;outer loop: process a new input
                MOV     *AR0+ << #16, AC1                 ; HI(AC1) = x(n)
                ||RPTBLOCAL     InnerLoopEnd-1            ;inner loop: process a bi-quad
                        NOP_16                            ; CPU_116: Remark 5682
                     || MPYM    *AR1+, AC1, AC0           ; AC0 = b0*x(n)
                        MACM    *AR1+, *(AR6+T0), AC0     ; AC0 += b1*x(n-1)
                        MACM    *AR1+, *AR6, AC0          ; AC0 += b2*x(n-2)
                        MOV     HI(AC1), *(AR6+T1)        ; x(n) replaces x(n-2) 
                        MASM    *AR1+, *(AR4+T0), AC0     ; AC0 -= a0*y(n-1) 
                        MASM    *AR1+, *AR4, AC0, AC1     ; AC1 -= a1*y(n-2) 
                        MOV     rnd(HI(AC1)), *(AR4+T1)   ; y(n) replaces y(n-2)
InnerLoopEnd:
                AMOV    AR7, AR1                          ;reinitialize coeff pointer 
             || MOV     rnd(HI(AC1)), *AR2+               ;store result to output buffer
OuterLoopEnd:

        MOV     AR4, *AR3                                 ; Update delay pointer

; Signal overflow
     || MOV     #0, T0
        XCCPART overflow(AC0)
            ||MOV  #1, T0
        XCCPART overflow(AC1)
            ||MOV  #1, T0

;Context restore
        POPBOTH XAR7
     || BCLR    AR6LC             ; restore for C
        POPBOTH XAR6
     || BCLR    AR4LC             ; restore for C
        POP     T3, T2
     || BSET    ARMS              ; restore for C
        RET        
     || BCLR    FRCT              ; restore for C
        
iirlat.asm/     1362765892  0     0     0       9885      `
;/*
; * Copyright (C) 2013 Texas Instruments Incorporated - http://www.ti.com/ 
; * 
; * 
; *  Redistribution and use in source and binary forms, with or without 
; *  modification, are permitted provided that the following conditions 
; *  are met:
; *
; *    Redistributions of source code must retain the above copyright 
; *    notice, this list of conditions and the following disclaimer.
; *
; *    Redistributions in binary form must reproduce the above copyright
; *    notice, this list of conditions and the following disclaimer in the 
; *    documentation and/or other materials provided with the   
; *    distribution.
; *
; *    Neither the name of Texas Instruments Incorporated nor the names of
; *    its contributors may be used to endorse or promote products derived
; *    from this software without specific prior written permission.
; *
; *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
; *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
; *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
; *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
; *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
; *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
; *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
; *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
; *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
; *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
; *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
; *
;*/

;***********************************************************
; Version 3.00.00                                           
;***********************************************************
;****************************************************************
; Function:    iirlat
; Processor:   C55xx
; Description: Computes a real lattice IIR filter implementation using 
;		coefficient stored in vector h. The real data input is 
;		stored in vector x. The filter output result is stored 
;		in vector r .  This function retains the address of the 
;		delay filter memory d containing the previous delayed 
;		values to allow consecutive processing of blocks. This 
;		function can be used for both block-by-block and  
;		sample-by-sample filtering (nx=1).    
;		C-callable.
;
; Usage: short oflag = iirlat (DATA *x,            // XAR0
;                              DATA *h,            // XAR1
;                              DATA *r,            // XAR2
;                              DATA *pbuffer,      // XAR3
;                              int nx,             // T0
;                              int nh)             // T1
;
; Benchmarks:
;   Cycles:       (nx * (4 *nh - 1)) + 33
;   Code Size (in bytes):  99
;
; History:
;   05/27/2012 Craig Leeds: include AC1 in overflow checking
;****************************************************************
*;Algorithm:
*; 	e(nh)[n] = x[n]
*;	
*; 	e(i-1)[n]  = e(i)[n] + k(i)*e'(i-1)[n-1]   i=nh,nh-1,.. 1
*;       e'(i)[n] = k(i)*e(i-1)[n] + e'(i-1)[n-1]   i=nh,nh-1,.. 1
*;	r[n] = e(0)[n]=e'(0)[0]
*;
*;
*;pbuffer: procession buffer of nh length
*;      e'0[n-1]
*;      e'1[n-1]
*;      e'2[n-1]
*;      e'3[n-1]
*;	.
*;	.
*;      e'nh-2[n-1]
*;      e'nh-1[n-1]
*;
*;x: input of length nx
*;	x[0]
*;	x[1]
*;	.
*;	.
*;	.
*;	x[nx-2]
*;	x[nx-1]
*;
*;h: input of length nh-1 (zero pad 1st value)
*;	0
;	h[1]
;	.
;	.
;	.
;	h[nh-1]
;	h[nh]
;
;r: output of length nx
;	r[0]
;	r[1]
;	.
;	.
;	.
;	r[nx-2]
;	r[nx-1]  
;
;
;****************************************************************


      .ARMS_off                     ;enable assembler for ARMS=0
      .CPL_on                       ;enable assembler for CPL=1
      .mmregs                       ;enable mem mapped register names
      .noremark 5684                ;BRC1 is not modified indirectly

; Stack frame
; -----------
RET_ADDR_SZ       .set 1            ;return address
REG_SAVE_SZ       .set 0            ;save-on-entry registers saved
FRAME_SZ          .set 0            ;local variables
ARG_BLK_SZ        .set 0            ;argument block

PARAM_OFFSET      .set ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ + RET_ADDR_SZ


; Register usage
; --------------
      .asg     AR0, x_ptr           ;linear pointer
      .asg     AR1, h_ptr           ;circular pointer
      .asg     AR2, r_ptr           ;linear pointer
      .asg     AR4, p_ptr           ;circular pointer
      .asg     AR3, temp	    ;temp buffer
	
       
      .asg     BSA45, p_base        ;base addr for p_ptr
      .asg     XAR4, xdb_base       ;extended base addr for p_ptr
      .asg     BK47, p_sz           ;circ buffer size for p_ptr
      .asg     BK47_L, p_sz_L       ;for memory mapped access
      .asg     BSA01, h_base        ;base addr for h_ptr
      .asg     BK03, h_sz           ;circ buffer size for h_sz

      .asg     T0, oflag           ;returned value

ST2mask  .set  0000000000010010b    ;circular/linear pointers, AR4, AR1 circular


      .global _iirlat

      .text
_iirlat:
;
; Allocate the local frame and argument block
;----------------------------------------------------------------
;      SP = SP - #(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ)
; - not necessary for this function (the above is zero)

;
; Save any save-on-entry registers that are used
;----------------------------------------------------------------
; - nothing to save for this function

;
; Configure the status registers as needed.
;----------------------------------------------------------------

        BCLR    ARMS
        BSET    FRCT
        BCLR    SMUL
        BCLR    ACOV0
        BCLR    ACOV1
;
; Setup passed parameters in their destination registers
; Setup circular/linear CDP/ARx behavior
;----------------------------------------------------------------

; x pointer - passed in its destination register, need do nothing
; h pointer 
                
        MOV     AR1, mmap(h_base)        ;base address of coefficients passed in AR1
        MOV     T1, mmap(h_sz)           ;h_sz = nh

; r pointer - passed in its destination register, need do nothing
; p pointer

        MOV     XAR3, XAR4
        MOV     AR3, mmap(p_base)        ;base address for p_ptr
        MOV     T1, mmap(p_sz)           ;p_sz = nh
; Set circular/linear ARx behavior
        OR      #ST2mask, mmap(ST2_55)   ;config circ/linear pointers
;
; Setup loop counts
;----------------------------------------------------------------
        SUB     #1, T0                   ;T0 = nx-1
        MOV     T0, BRC0                 ;outer loop executes nx times
        SUB     #2, T1, T0               ;T0 = nh-2
        SUB     #1, T1                   ; T1 = nh-1   
        MOV     T1, p_ptr                ;point to last coefficient
        MOV     T1, h_ptr                ;point to last coefficient
        MOV     T0, BRC1                 ;inner loop executes nh-1 times
        AMOV     #-1, T0                  ; setup offset register 
      
;
; Start of outer loop
;----------------------------------------------------------------
     || RPTBLOCAL  loop1-1               ;start the outer loop
                ;1st iteration
                MOV     *x_ptr+ << #16, AC0                ; setup for e(0): input value
                
              ||RPTBLOCAL  loop2-1                         ;inner loop
                        NOP_16                             ; for CPU_116 Remark 5682
                      ||MOV     *p_ptr(T0) <<#16, AC1      ; setup for e'(0): input value
                        MASM    *h_ptr, *p_ptr(T0), AC0    ; calculate e(0)
                        MACM    *h_ptr-, AC0, AC1          ; calculate e'(0)
                        MOV     HI(AC1), *p_ptr-           ; store e'(i)
loop2:                   

                ;last iteration has rounding
                MACMR   *h_ptr-, *p_ptr(T0), AC0
                MOV     HI(AC0), *p_ptr-                   ; store previously cacluclated e'(i)
              ||MOV     HI(AC0), *r_ptr+                   ;store Q15 value to memory
loop1:                                                     ;end of outer loop

;
; Check if overflow occurred, and setup return value
;----------------------------------------------------------------
        MOV     #0, oflag                ;clear oflag
        XCCPART overflow(AC0)            ;clears ACOV0
             ||MOV        #1, oflag      ;overflow occurred
        XCCPART overflow(AC1)            ; 
             ||MOV  #1, oflag            ; 

;
; Restore status regs to expected C-convention values as needed
;----------------------------------------------------------------

        AND     #0FE00h, mmap(ST2_55)    ;clear CDPLC and AR[7-0]LC
      
        BCLR    FRCT                     ;clear FRCT
        BSET    ARMS                     ;set ARMS

;
; Restore any save-on-entry registers that are used
;----------------------------------------------------------------
; - nothing to restore for this function

;
; Deallocate the local frame and argument block
;----------------------------------------------------------------
;      SP = SP + #(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ)
; - not necessary for this function (the above is zero)
;
; Return to calling function
;----------------------------------------------------------------
        BSET    SMUL                     ;restore SMUL for C
     || RET                              ;return to calling function

;----------------------------------------------------------------
;End of file

interp.asm/     1362765892  0     0     0       9737      `
;/*
; * Copyright (C) 2013 Texas Instruments Incorporated - http://www.ti.com/ 
; * 
; * 
; *  Redistribution and use in source and binary forms, with or without 
; *  modification, are permitted provided that the following conditions 
; *  are met:
; *
; *    Redistributions of source code must retain the above copyright 
; *    notice, this list of conditions and the following disclaimer.
; *
; *    Redistributions in binary form must reproduce the above copyright
; *    notice, this list of conditions and the following disclaimer in the 
; *    documentation and/or other materials provided with the   
; *    distribution.
; *
; *    Neither the name of Texas Instruments Incorporated nor the names of
; *    its contributors may be used to endorse or promote products derived
; *    from this software without specific prior written permission.
; *
; *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
; *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
; *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
; *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
; *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
; *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
; *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
; *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
; *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
; *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
; *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
; *
;*/

;***********************************************************
; Version 3.00.00                                           
;***********************************************************
; Function:    firinterp
; Processor:   C55xx
; Description: Interpolation filter with user specified FIR coefficients
;
;						Passing:
; Usage:   short firinterp(	DATA *x,	XAR0
;				DATA *h,	XAR1
;				DATA *r,	XAR2
;				DATA *dbuffer,	XAR3
;				ushort nh,	T0
;				ushort nx,	T1
;				ushort I);	XAR4
;
; Requirements:	I >= 1
;		nh/I >= 3
;		x[nx]
;		h[nh]
;		r[nx*I]
;		dbuffer[(nh/I)+1]
;			dbuffer[0] is ptr to last db entry
;			dbuffer[1...(nh/I)] is db data
; Benchmarks:
;   Cycles:       (nx * (3 + I *(1 + nh/I))) + 64
;   Code Size (in bytes):  144
;
; History:
;  05/27/2012 Craig Leeds: Fixes following bugs: 
;          T2 was modified but not restored
;          T3 is tested but not set
;****************************************************************

	.ARMS_off			;enable assembler for ARMS=0
	.CPL_on				;enable assembler for CPL=1
	.mmregs				;enable mem mapped register names
        .noremark 5684                  ; CPU_116: BRC1 not written indirectly

; Stack frame
; -----------
RET_ADDR_SZ	.set	1		;return address
REG_SAVE_SZ	.set	0		;save-on-entry registers saved
FRAME_SZ	.set	0		;local variables
ARG_BLK_SZ	.set	0		;argument block

PARAM_OFFSET	.set	ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ + RET_ADDR_SZ


; Register usage
; --------------
	.asg	AR0, x_ptr		;linear pointer
	.asg	AR1, h_ptr		;circular pointer
	.asg	AR2, r_ptr		;linear pointer
	.asg	AR4, db_ptr		;circular pointer

	.asg	BSA01, h_base		;base addr for h_ptr
	.asg	BK03, h_sz		;circ buffer size for h_sz
	.asg	BSA45, db_base		;base addr for db_ptr
	.asg	XAR4, xdb_base		;extended base addr for db_ptr
	.asg	BK47, db_sz		;circ buffer size for db_ptr
                                	
	.asg	T0, oflag		;returned value

	.global	_firinterp

	.text
_firinterp:
;
; Allocate the local frame and argument block
;----------------------------------------------------------------
;      SP = SP - #(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ)
; - not necessary for this function (the above is zero)

;
; Save any save-on-entry registers that are used
;----------------------------------------------------------------
; - nothing to save for this function

;
; Configure the status registers as needed.
;----------------------------------------------------------------
        PSH     T3, T2
     || BCLR    ARMS
        BSET    FRCT
        BCLR    SMUL
        BCLR    ACOV0
;
; Setup passed parameters in their destination registers
; Setup circular/linear CDP/ARx behavior
; Setup loop counts
;----------------------------------------------------------------

; outer loop count
        SUB     #1, T1
        MOV     T1, BRC0                  ;BRC0 = nx-1
        MOV     AR4, T1                   ;save I in T1 (interpolation factor)

; x pointer - passed in its destination register, need do nothing

; h pointer
        MOV     AR1, mmap(h_base)         ;base address of coefficients
        MOV     #0, h_ptr                 ;point to first coefficient
        MOV     T0, mmap(h_sz)            ;coefficient array size h_sz = nh

; r pointer - already passed in its destination register

; db pointer
        MOV     XAR3, xdb_base            ;db array address
        MOV     *AR3+, db_ptr             ;index of oldest db entry
        MOV     AR3, mmap(db_base)        ;base address for db_ptr
; Set circular/linear ARx behavior
        BSET    AR1LC                     ; set AR1 as a circular buffer
        BSET    AR4LC                     ; set AR4 as a circular buffer
; Setup loop counts
        BCLR    SXM
        MOV     T0, AC0                   ;AC0 = nh
      ||RPT     #(16-1)
                SUBC    mmap(T1), AC0     ;LO(AC0) = (nh/I)
        MOV     HI(AC0), T0               ;T0 = remainder of (nh/I)
        MOV     AC0, mmap(db_sz)          ;db_sz = (nh/I)
        SUB     #3, AC0                   ;
        MOV     AC0, mmap(CSR)            ;inner_cnt = (nh/I)-3 (reload for FIR taps)
        ADD     T1, T0                    ;T0 += I
        ADD     #1, T0                    ;T0 = remainder+I+1 (last tap hptr update)
        BSET    SXM

        SUB     #1, T1, T2                ;T2 = I-1
        MOV     T2, BRC1                  ;BRC1 = I-1        
        
        BCC     InterpLoop, T2 >= #0        
        
;
; Start of outer loop  I=1
;----------------------------------------------------------------
No_Interp:
        MOV     T2, CSR                   ;inner_cnt = nh-3 (2 iter outside loop)
        
        RPTBLOCAL NoInterpLoopEnd-1                     ;start the outer loop
                ;Sum h*x nh-iterations for next r value
                MPYM    T3 = *x_ptr+, *h_ptr+, AC0      
                ;move next input value into delay buffer
                MOV     T3, *db_ptr+
              ||RPT     CSR
                        MACM    *db_ptr+, *h_ptr+, AC0, AC0
                MACMR   *db_ptr, *h_ptr+, AC0, AC0
                MOV     HI(AC0), *r_ptr+                ;store Q15 value to memory
NoInterpLoopEnd:                                        ;end of outer loop
        
        B       InterpDone                ;goto exit procedure
;
; Start of outer loop  I>=2
;----------------------------------------------------------------
InterpLoop:
        RPTBLOCAL   OuterLoopEnd-1        ;outer loop (nx iterations)
        
                ;move next input value into delay buffer
                MOV     *x_ptr+, *db_ptr                

              ||RPTBLOCAL  InnerLoopEnd-1           ;  middle loop (I iterations)
                        ;Sum h*x (nh/I)-iterations (only non-zero) for next r value
                        MPYM    *db_ptr+, *(h_ptr+T1), AC0        ;    inner loop (nh/I iterations)      
                      ||RPT     CSR
                                MACM    *db_ptr+, *(h_ptr+T1), AC0, AC0
                        MACMR   *db_ptr+, *(h_ptr+T0), AC0, AC0
                        MOV     HI(AC0), *r_ptr+                ;    store Q15 value to memory
InnerLoopEnd:        
                ;reset h_ptr
                AMAR    *(h_ptr-T1)                 ;  h_ptr = &h[0]        
                ;Point db_ptr to new entry
              ||AMAR    *db_ptr-                
OuterLoopEnd:                             ;end of outer loop

;
; Update the db entry point
;----------------------------------------------------------------
InterpDone:
        MOV     db_ptr, *-AR3            ;update 1st element of db array
;
; Check if overflow occurred, and setup return value
;----------------------------------------------------------------
      ||MOV     #0, oflag                ;clear oflag
        XCCPART overflow(AC0)            ;clears ACOV0
            ||MOV    #1, oflag           ;overflow occurred
;
; Restore status regs to expected C-convention values as needed
;----------------------------------------------------------------
        AND     #0xfe00, mmap(ST2_55)    ; Clear AR0LC-AR7LC, CDPLC (specifically AR1LC and AR4LC)
        POP     T3, T2
     || BSET    ARMS
        BCLR    FRCT
        BSET    SMUL
;
; Restore any save-on-entry registers that are used
;----------------------------------------------------------------
; - nothing to restore for this function

;
; Deallocate the local frame and argument block
;----------------------------------------------------------------
;      SP = SP + #(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ)
; - not necessary for this function (the above is zero)

;
; Return to calling function
;----------------------------------------------------------------
     || RET                              ;return to calling function

;----------------------------------------------------------------
;End of file

ldiv16.asm/     1362765892  0     0     0       9453      `
;/*
; * Copyright (C) 2013 Texas Instruments Incorporated - http://www.ti.com/ 
; * 
; * 
; *  Redistribution and use in source and binary forms, with or without 
; *  modification, are permitted provided that the following conditions 
; *  are met:
; *
; *    Redistributions of source code must retain the above copyright 
; *    notice, this list of conditions and the following disclaimer.
; *
; *    Redistributions in binary form must reproduce the above copyright
; *    notice, this list of conditions and the following disclaimer in the 
; *    documentation and/or other materials provided with the   
; *    distribution.
; *
; *    Neither the name of Texas Instruments Incorporated nor the names of
; *    its contributors may be used to endorse or promote products derived
; *    from this software without specific prior written permission.
; *
; *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
; *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
; *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
; *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
; *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
; *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
; *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
; *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
; *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
; *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
; *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
; *
;*/

;***********************************************************
; Version 3.00.00                                           
;***********************************************************
; Function:    ldiv16
; Processor:   C55xx
; Description: Implements long division function.  Reciprocal of Q15, y 
; 	       is calculated then multiplied times Q31 x. C-callable.
;
; Usage: void ldiv16(LDATA *x, 
;                    DATA *y, 
;                    DATA *z, 
;                    DATA *zexp, 
;                    ushort nx)
;
; Algorithm:
;     This routine returns the fractional and exponential portion
;  of the division in the form of :
;          
;               z[i] * zexp[i] = reciprocal
;
; Benchmarks:
;   Cycles:       (29 * nx) + 27
;   Code Size (in bytes):  123
;
; History:
;         07/07/2003 - d. elam fixed bug in range test 
;         05/25/2012 - Craig Leeds: optimize by 45%
;****************************************************************
   
      .ARMS_off                     ;enable assembler for ARMS=0
      .CPL_on                       ;enable assembler for CPL=1
      .mmregs                       ;enable mem mapped register names

; Stack frame
; -----------
RET_ADDR_SZ       .set 1            ;return address
REG_SAVE_SZ       .set 2            ;save-on-entry registers saved
FRAME_SZ          .set 2            ;local variables
ARG_BLK_SZ        .set 0            ;argument block

PARAM_OFFSET      .set ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ + RET_ADDR_SZ


; Register usage
; --------------
      .asg     AR0, x_ptr           ;linear pointer
      .asg     AR1, y_ptr            ;linear pointer
      .asg     AR2, z_ptr           ;linear pointer
      .asg     AR3, zexp_ptr        ;linear pointer
                   
      .global _ldiv16
      
      .text
_ldiv16:


;
; Allocate the local frame and argument block
;----------------------------------------------------------------
;      SP = SP - #(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ)
; - not necessary for this function (the above is zero)

;
; Save any save-on-entry registers that are used
;----------------------------------------------------------------
; - nothing to save for this function

;
; Configure the status registers as needed.
;----------------------------------------------------------------
        PSH     T2, T3
     || BCLR    ARMS
        AADD    #-(2+1), SP
     || BSET    FRCT
        BCLR    SMUL
        BSET    M40
;
; Setup passed parameters in their destination registers
; Setup circular/linear CDP/ARx behavior
;----------------------------------------------------------------

; x pointer - passed in its destination register, need do nothing
; z pointer - passed in its destination register, need do nothing
; zexp  pointer - passed in its destination register, need do nothing
; Set circular/linear ARx behavior
;
; Setup loop counts
;----------------------------------------------------------------
        SUB     #1, T0                   ;T0 = n-1
        AMAR    *SP(0), XAR4
        MOV     T0, BRC0                 ;outer loop executes n times
        MOV     #3-1, BRC1               ;repeat inner loop 3x
        AMOV    #3, T0
        ADD     #1, x_ptr                ; x_ptr = &x[0].Lo
        
                MOV     *y_ptr+ << #16, AC1       ;load first input value (Prime the Pump)
                MANT    AC1, AC3                  ;calculate normalization of 1st value (Prime the Pump)
              ::NEXP    AC1, T1                   ; (Prime the Pump)
                NEG     T1                        ;exponent value for the offset pointer (Prime the Pump)
                ADD     #1, T1                    ;offset pointer to exponent (Prime the Pump)
              ||SFTS    AC3, #-1, AC2             ;shift right by one for 1st approximation (Prime the Pump)
                XOR     #0x1FFF << #16, AC2       ;estimate the first Ym value (Prime the Pump)
;
; Start of outer loop
;----------------------------------------------------------------
     || RPTBLOCAL OuterLoopEnd-1                  ;start the outer loop 
                MOV     HI(AC2), *AR4             ;store first Ym

; First two iterations      Calculate Ym = 2*Ym - Ym^2*X
                ||RPTBLOCAL InnerLoopEnd-1
                        MOV     *AR4 << #15, AC0
                     || MPYM    T3 = *AR4, AC3, AC2
                        MAS     T3, AC2, AC0
                        MOV     HI(saturate(AC0 << #2)), *AR4
InnerLoopEnd:

;-------------------------------------------------------------------------
; Check if value is in range 8000h <= Ym <= 7fffh, Adjust sign of result
;-------------------------------------------------------------------------
                MOV     HI(saturate(AC0 << #3)), *AR4                
             || MOV     *y_ptr+ << #16, AC1       ;load first input value (for next iteration)
;-------------------------------------------------------------------------
; Multiply numerator by reciprocal of denominator
;-------------------------------------------------------------------------
                MPYM    *AR4, uns(*x_ptr-), AC2             ;numerator low  * denominator high; x_ptr = &x[i].Hi
                MACMR   *AR4, *(x_ptr+T0), AC2 >> #16, AC2  ;numerator high * denominator high; x_ptr = &x[i+1].Lo
                
                MANT    AC2, AC2
                ::NEXP  AC2, T2                   ;calculate normalization of 1st value
                ADD     T1, T2                    ;offset pointer to exponent values
             || MOV     #1, AC0
        
                MANT    AC1, AC3                  ;calculate normalization of 1st value (for next iteration)
              ::NEXP    AC1, T1                   ; (for next iteration)
             || XCCPART  T2 < #0
                       SFTS    AC2, T2, AC2
                    || MOV     #0, T2

                MOV     HI(AC2), *z_ptr+
             || NEG     T1                        ;exponent value for the offset pointer (for next iteration)
                ADD     #1, T1                    ;offset pointer to exponent (for next iteration)
             || SFTS    AC3, #-1, AC2             ;shift right by one for 1st approximation (for next iteration)
                XOR     #0x1FFF << #16, AC2       ;estimate the first Ym value (for next iteration)
             || SFTS    AC0, T2, AC0              ;calculate exponent value
                MOV     AC0, *zexp_ptr+           ;store exponent
                
OuterLoopEnd:                                     ;end of outer loop

;
; Restore status regs to expected C-convention values as needed
;----------------------------------------------------------------
;
; Restore any save-on-entry registers that are used
;----------------------------------------------------------------
; - nothing to restore for this function
;
; Deallocate the local frame and argument block
;----------------------------------------------------------------
;      SP = SP + #(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ)
; - not necessary for this function (the above is zero)
; Return to calling function
;----------------------------------------------------------------

        AADD    #+(2+1), SP
     || BCLR    FRCT               ; restore for C
        BCLR    M40                ; restore for C
        POP     T2, T3
     || BSET    ARMS               ; set ARMS for C
        BSET    SMUL               ; restore for C
     || RET                        ; return to calling function

        
;----------------------------------------------------------------
;End of file

log_10.asm/     1362765892  0     0     0       7016      `
;/*
; * Copyright (C) 2013 Texas Instruments Incorporated - http://www.ti.com/ 
; * 
; * 
; *  Redistribution and use in source and binary forms, with or without 
; *  modification, are permitted provided that the following conditions 
; *  are met:
; *
; *    Redistributions of source code must retain the above copyright 
; *    notice, this list of conditions and the following disclaimer.
; *
; *    Redistributions in binary form must reproduce the above copyright
; *    notice, this list of conditions and the following disclaimer in the 
; *    documentation and/or other materials provided with the   
; *    distribution.
; *
; *    Neither the name of Texas Instruments Incorporated nor the names of
; *    its contributors may be used to endorse or promote products derived
; *    from this software without specific prior written permission.
; *
; *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
; *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
; *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
; *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
; *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
; *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
; *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
; *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
; *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
; *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
; *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
; *
;*/

;***********************************************************
; Version 3.00.00                                           
;***********************************************************
;  Function:	log_10
;  Description: Calculate log base 10 of 16-bit Q15 number
;
;  Usage:  ushort log_10(DATA *x, LDATA *r, ushort nx);
;
; Benchmarks:
;   Cycles:       (21 * nx) + 24
;   Code Size (in bytes):  145
;
; History
;  3.00.00 - Craig Leeds 05/17/2012
;    Fix bug where overflow flag is not cleared at startup.
;    Optimized by about 40%.
;********************************************************************************

        .mmregs                ; assign Memory-Mapped Register names as global symbols
        .ARMS_off
        .def                _log_10

        .asg    #0x8000,  CST_8000
        .asg    #0xDC56,  LB6
        .asg    #0x54ad,  LB5
        .asg    #0x9e8a,  LB4
        .asg    #0x50d5,  LB3
        .asg    #0xc056,  LB2
        .asg    #0x3ffd,  LB1
        .asg    #0x062d,  LB0
        .asg    #0x58B9,  CST_ln2

        .text 
_log_10:            
        PSH     T3, T2
     || BCLR    ARMS
        AADD    #-9, SP
     || BCLR    ACOV0
        MOV     XSP, XAR2
;initialization for Logarithm calculation  

        SUB     #1, T0
        MOV     T0, BRC0
        MOV     #(1-9), T1

        MOV     LB5, *AR2+           ; SP[0] = LB5
        MOV     CST_8000, *AR2+      ; SP[1] = CST_8000
        MOV     LB4, *AR2+           ; SP[2] = LB4
        MOV     LB6, *AR2+           ; SP[3] = LB6
        MOV     LB3, *AR2+           ; SP[4] = LB3
        MOV     LB2, *AR2+           ; SP[5] = LB2
        MOV     LB1, *AR2+           ; SP[6] = LB1
        MOV     LB0, *AR2+           ; SP[7] = LB0
        MOV     CST_ln2, *(AR2+T1)   ; SP[8] = CST_ln2; AR2 = &SP[0]
        MOV     #0x3797, T2          ; 
        MOV     #0x7fff, AR3         ; AR3 = 0x7fff

     || RPTBLOCAL LoopEnd - 1                
**************
* Normalize x
**************
                MOV     *AR0+ << #16, AC0     ;A = x << 16
                MANT    AC0, AC0
                ::NEXP  AC0, T0               ;T = negative number of leading bits
             || MOV     *AR2+ << #16, AC1     ;B5 load    *SP[0] = LB5

***************************
* Polynomial approximation 
***************************
   
                SFTS    AC0, #-15, AC0        ;A <- 2*M
                SUB     uns(*AR2+), AC0       ;A <- (2*M-1) Q15    *SP[1] = CST_8000
             || SUB     #1, T0                ;T0 <- P-1    

                MOV     AC0, T3               ;U <- (2*M-1) Q15 (between 0.0 and 1.0)
             || MOV     *AR2+ << #16, AC2     ;B4 load    *SP[2] = LB4
             
                MACMR   *AR2+, T3, AC1, AC0   ;A(32-16) <- B6*U + B5  *SP[3] = LB6
                                              ;Q34 + Q18 << 16 = Q34
        
                MOV     *AR2+ << #16, AC1     ;B3 load    *SP[4] = LB3
             || MACR    AC0, T3, AC2, AC0     ;A <- (B6*U + B5)*U + B4
                                              ;Q33 + Q17 << 16 = Q33

                MOV     *AR2+ << #16, AC1     ;B2 load    *SP[5] = LB2
             || MACR    AC0, T3, AC1, AC0     ;A <- ((B6*U+B5)*U+B4)*U+B3
                                              ;Q32 + Q16 << 16 = Q32
        
                MOV     *AR2+ << #16, AC1     ;B1 load    *SP[6] = LB1
             || MACR    AC0, T3, AC1, AC0     ;A <- (((B6*U+B5)*U+B4)*U+B3)*U+B2
                                              ;Q31 + Q15 << 16 = Q31

                MACR    AC0, T3, AC1, AC0     ;A <- ((((B6*U+B5)*U+B4)*U+B3)*U+B2)*U+B1
             || MOV     *AR2+, AC1            ; AC1 = *SP[7] = LB0
                                              ;Q30 + Q14 << 16 = Q30
                SFTS    AC0, #1                                
             || MOV     AR3, AC2              ; AC2 = 0x00007ffff   
                MAC     AC0, T3, AC1, AC0     ; A <- (((((B6*U + B5)*U + B4)*U + B3)*U + B2)*U + B1)*U + B0   *SP[7] = LB0
                                              ;Q30 + Q30 = Q30
*******************
* Process exponent
*******************
                MPYM    *(AR2+T1), T0, AC1    ;AC1 <- ln2 * (P-1); AR2 = &SP[0]     *SP[8] = CST_ln2,  AR2 = &SP[0]
             || SFTS    AC0, #-15

*************************
* Add both contributions
*************************

                 ADD    AC1, AC0              ; AC0 = <- f(2*M(x)-1) + (P(x)-1)*ln(2)
                 AND    AC0, AC2              ;store low word of AC0
              || SFTS   AC0, #1               ;shift for 17 mpy 
                 MPY    T2, AC0
              || SFTS   AC2, #16              ;process low word 
                 MPY    T2, AC2
                 ADD    AC2 << #-15, AC0      ;add words together
                 MOV    AC0, dbl(*AR1+)
LoopEnd:

************************
* Return overflow flag
************************

        AADD    #+9, SP

     || MOV     #0, T0
        XCCPART overflow(AC0)
             ||MOV    #1, T0

        POP     T3, T2
     || BSET    ARMS
        RET

;end of file. please do not remove. it is left here to ensure that no lines of code are removed by any editor
        
log_2.asm/      1362765892  0     0     0       7111      `
;/*
; * Copyright (C) 2013 Texas Instruments Incorporated - http://www.ti.com/ 
; * 
; * 
; *  Redistribution and use in source and binary forms, with or without 
; *  modification, are permitted provided that the following conditions 
; *  are met:
; *
; *    Redistributions of source code must retain the above copyright 
; *    notice, this list of conditions and the following disclaimer.
; *
; *    Redistributions in binary form must reproduce the above copyright
; *    notice, this list of conditions and the following disclaimer in the 
; *    documentation and/or other materials provided with the   
; *    distribution.
; *
; *    Neither the name of Texas Instruments Incorporated nor the names of
; *    its contributors may be used to endorse or promote products derived
; *    from this software without specific prior written permission.
; *
; *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
; *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
; *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
; *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
; *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
; *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
; *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
; *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
; *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
; *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
; *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
; *
;*/

;***********************************************************
; Version 3.00.00                                           
;***********************************************************
;  Function:	log_2
;  Description: Calculate log base 2 of 16-bit Q15 number
;
;  Usage:  ushort log_2(DATA *x, LDATA *r, ushort nx);
;
; Benchmarks:
;   Cycles:       (22 * nx) + 25
;   Code Size (in bytes):  144
;
; History
; 3.00.00 - Craig Leeds 05/17/2012
;   Fix bug where overflow flag is not cleared at startup.
;   Optimized by about 40%.
;                
;********************************************************************************

        .mmregs                ; assign Memory-Mapped Register names as global symbols
        .ARMS_off
        .def                _log_2

        .asg    #0x8000,  CST_8000
        .asg    #0xDC56,  LB6
        .asg    #0x54ad,  LB5
        .asg    #0x9e8a,  LB4
        .asg    #0x50d5,  LB3
        .asg    #0xc056,  LB2
        .asg    #0x3ffd,  LB1
        .asg    #0x062d,  LB0
        .asg    #0x58B9,  CST_ln2
;;;     .asg    #0xD8B9,  NCST_ln2

        .text
_log_2:            
        PSH     T3, T2
     || BCLR    ARMS
        AADD    #-9, SP
     || BCLR    ACOV0
        MOV     XSP, XAR2
;initialization for Logarithm calculation  

        SUB     #1, T0
        MOV     T0, BRC0
        MOV     #(1-9), T1

        MOV     LB5, *AR2+           ; SP[0] = LB5
        MOV     CST_8000, *AR2+      ; SP[1] = CST_8000
        MOV     LB4, *AR2+           ; SP[2] = LB4
        MOV     LB6, *AR2+           ; SP[3] = LB6
        MOV     LB3, *AR2+           ; SP[4] = LB3
        MOV     LB2, *AR2+           ; SP[5] = LB2
        MOV     LB1, *AR2+           ; SP[6] = LB1
        MOV     LB0, *AR2+           ; SP[7] = LB0
        MOV     CST_ln2, *(AR2+T1)   ; SP[8] = CST_ln2; AR2 = &SP[0]
        MOV     #0x38AA, T2          ; 0.4427 in hex
        MOV     #0x7fff, AR3         ; AR3 = 0x7fff

     || RPTBLOCAL LoopEnd - 1                
**************
* Normalize x
**************
                MOV     *AR0+ << #16, AC0        ;A = x << 16
                MANT    AC0, AC0
                ::NEXP  AC0, T0                  ;T = negative number of leading bits
             || MOV     *AR2+ << #16, AC1        ;B5 load    *SP[0] = LB5

***************************
* Polynomial approximation 
***************************
   
                SFTS    AC0, #-15, AC0           ;A <- 2*M
                SUB     uns(*AR2+), AC0          ;A <- (2*M-1) Q15    *SP[1] = CST_8000
             || SUB     #1, T0                   ;T0 <- P-1    

                MOV     AC0, T3                  ;U <- (2*M-1) Q15 (between 0.0 and 1.0)
             || MOV     *AR2+ << #16, AC2        ;B4 load    *SP[2] = LB4
             
                MACMR   *AR2+, T3, AC1, AC0      ;A(32-16) <- B6*U + B5  *SP[3] = LB6
                                                 ;Q34 + Q18 << 16 = Q34
        
                MOV     *AR2+ << #16, AC1        ;B3 load    *SP[4] = LB3
             || MACR    AC0, T3, AC2, AC0        ;A <- (B6*U + B5)*U + B4
                                                 ;Q33 + Q17 << 16 = Q33

                MOV     *AR2+ << #16, AC1        ;B2 load    *SP[5] = LB2
             || MACR    AC0, T3, AC1, AC0        ;A <- ((B6*U+B5)*U+B4)*U+B3
                                                 ;Q32 + Q16 << 16 = Q32
        
                MOV     *AR2+ << #16, AC1        ;B1 load    *SP[6] = LB1
             || MACR    AC0, T3, AC1, AC0        ;A <- (((B6*U+B5)*U+B4)*U+B3)*U+B2
                                                 ;Q31 + Q15 << 16 = Q31

                MACR    AC0, T3, AC1, AC0        ;A <- ((((B6*U+B5)*U+B4)*U+B3)*U+B2)*U+B1
             || MOV     *AR2+, AC1               ; AC1 = *SP[7] = LB0
                                                 ;Q30 + Q14 << 16 = Q30
                SFTS    AC0, #1                                
             || MOV     AR3, HI(AC2)             ; AC2 = 0x007fff0000
                MAC     AC0, T3, AC1, AC0        ; A <- (((((B6*U + B5)*U + B4)*U + B3)*U + B2)*U + B1)*U + B0   *SP[7] = LB0
                                                 ;Q30 + Q30 = Q30
*******************
* Process exponent
*******************
                MPYM    *(AR2+T1), T0, AC1       ;AC1 <- ln2 * (P-1); AR2 = &SP[0]     *SP[8] = CST_ln2,  AR2 = &SP[0]

*************************
* Add both contributions
*************************

                ADD     AC0 << #-15, AC1         ; AC1 = <- f(2*M(x)-1) + (P(x)-1)*ln(2)
                SFTS    AC1, #1, AC0             ;shift for 17 mpy ; 
                MPY     T2, AC0
             || AND     AC1 << #16, AC2          ;take out low word from old AC0
                ADD     AC1, AC0
                MPY     T2, AC2
                ADD     AC2 << #-15, AC0         ;add words together
                MOV     AC0, dbl(*AR1+)
LoopEnd:

************************
* Return overflow flag
************************

        AADD    #+9, SP
     || MOV     #0, T0
        XCCPART overflow(AC0)
              ||MOV     #1, T0

        POP     T3, T2
     || BSET    ARMS
        RET

;end of file. please do not remove. it is left here to ensure that no lines of code are removed by any editor


        

logn.asm/       1362765892  0     0     0       6350      `
;/*
; * Copyright (C) 2013 Texas Instruments Incorporated - http://www.ti.com/ 
; * 
; * 
; *  Redistribution and use in source and binary forms, with or without 
; *  modification, are permitted provided that the following conditions 
; *  are met:
; *
; *    Redistributions of source code must retain the above copyright 
; *    notice, this list of conditions and the following disclaimer.
; *
; *    Redistributions in binary form must reproduce the above copyright
; *    notice, this list of conditions and the following disclaimer in the 
; *    documentation and/or other materials provided with the   
; *    distribution.
; *
; *    Neither the name of Texas Instruments Incorporated nor the names of
; *    its contributors may be used to endorse or promote products derived
; *    from this software without specific prior written permission.
; *
; *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
; *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
; *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
; *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
; *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
; *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
; *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
; *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
; *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
; *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
; *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
; *
;*/

;***********************************************************
; Version 3.00.00                                           
;***********************************************************
; Function: log_n
; Description: Calculate natural log of 16-bit Q15 number
;
; Usage:  ushort logn(DATA *x, LDATA *r, ushort nx);
;
; Benchmarks:
;   Cycles:       (16 * nx) + 24
;   Code Size (in bytes):  117
;
; History
; 3.00.00 - Craig Leeds 05/17/2012
;   Fix bug where overflow flag is not cleared at startup.
;   Optimized by about 40%.
;********************************************************************************

        .mmregs                ; assign Memory-Mapped Register names as global symbols
        .ARMS_off
        .def                _logn

        .asg    #0x8000,  CST_8000
        .asg    #0xDC56,  LB6
        .asg    #0x54ad,  LB5
        .asg    #0x9e8a,  LB4
        .asg    #0x50d5,  LB3
        .asg    #0xc056,  LB2
        .asg    #0x3ffd,  LB1
        .asg    #0x062d,  LB0
        .asg    #0x58B9,  CST_ln2

        .text
        
_logn:            
        PSH     T3
     || BCLR    ARMS
        AADD    #-8, SP
     || BCLR    ACOV0
        MOV     XSP, XAR2
;initialization for Logarithm calculation  

        SUB     #1, T0
        MOV     T0, BRC0
        MOV     #(1-8), T1

        MOV     LB5, *AR2+           ; SP[0] = LB5
        MOV     CST_8000, *AR2+      ; SP[1] = CST_8000
        MOV     LB4, *AR2+           ; SP[2] = LB4
        MOV     LB6, *AR2+           ; SP[3] = LB6
        MOV     LB3, *AR2+           ; SP[4] = LB3
        MOV     LB2, *AR2+           ; SP[5] = LB2
        MOV     LB1, *AR2+           ; SP[6] = LB1
        MOV     CST_ln2, *(AR2+T1)   ; SP[7] = CST_ln2; AR2 = &SP[0]
        MOV     LB0, AC3             ; AC3 = LB0

     || RPTBLOCAL EndLoop - 1                
**************
* Normalize x
**************
                MOV     *AR0+ << #16, AC0    ;A = x << 16
                MANT    AC0, AC0
              ::NEXP    AC0, T0              ;T0 = negative number of leading bits
             || MOV     *AR2+ << #16, AC1    ;B5 load    *SP[0] = LB5

***************************
* Polynomial approximation 
***************************
   
                SFTS    AC0, #-15, AC0       ;A <- 2*M
                SUB     uns(*AR2+), AC0      ;A <- (2*M-1) Q15    *SP[1] = CST_8000
             || SUB     #1, T0               ;T0 <- P-1    
                MOV     AC0, T3              ;U <- (2*M-1) Q15 (between 0.0 and 1.0)
             || MOV     *AR2+ << #16, AC2    ;B4 load    *SP[2] = LB4
                MACMR   *AR2+, T3, AC1, AC0  ;A(32-16) <- B6*U + B5  *SP[3] = LB6
                                             ;Q34 + Q18 << 16 = Q34
                MOV     *AR2+ << #16, AC1    ;B3 load    *SP[4] = LB3
             || MACR    AC0, T3, AC2, AC0    ;A <- (B6*U + B5)*U + B4
                                             ;Q33 + Q17 << 16 = Q33
                MOV     *AR2+ << #16, AC1    ;B2 load    *SP[5] = LB2
             || MACR    AC0, T3, AC1, AC0    ;A <- ((B6*U+B5)*U+B4)*U+B3
                                             ;Q32 + Q16 << 16 = Q32
                MOV     *AR2+ << #16, AC1    ;B1 load    *SP[6] = LB1
             || MACR    AC0, T3, AC1, AC0    ;A <- (((B6*U+B5)*U+B4)*U+B3)*U+B2
                                             ;Q31 + Q15 << 16 = Q31
                MAC     AC0, T3, AC1, AC0    ;A <- ((((B6*U+B5)*U+B4)*U+B3)*U+B2)*U+B1
                                             ;Q30 + Q14 << 16 = Q30
                SFTS    AC0, #1                                
*******************
* Process exponent
*******************
             || MPYM    *(AR2+T1), T0, AC1   ;AC1 <- ln2 * (P-1); AR2 = &SP[0]     *SP[8] = CST_ln2,  AR2 = &SP[0]
                MAC     AC0, T3, AC3, AC0    ; A <- (((((B6*U + B5)*U + B4)*U + B3)*U + B2)*U + B1)*U + B0   *SP[7] = LB0
                                             ;Q30 + Q30 = Q30
*************************
* Add both contributions
*************************
                ADD     AC0 << #-15, AC1     ; AC0 = <- f(2*M(x)-1) + (P(x)-1)*ln(2)
                MOV     AC1, dbl(*AR1+)
EndLoop:

************************
* Return overflow flag
************************

        AADD    #+8, SP

     || MOV     #0, T0
        XCCPART overflow(AC0)
              ||MOV     #1, T0

        POP     T3
     || BSET    ARMS
        RET

;end of file. please do not remove. it is left here to ensure that no lines of code are removed by any editor
 
        
        


maxidx.asm/     1362776398  0     0     0       10473     `
;/*
; * Copyright (C) 2013 Texas Instruments Incorporated - http://www.ti.com/ 
; * 
; * 
; *  Redistribution and use in source and binary forms, with or without 
; *  modification, are permitted provided that the following conditions 
; *  are met:
; *
; *    Redistributions of source code must retain the above copyright 
; *    notice, this list of conditions and the following disclaimer.
; *
; *    Redistributions in binary form must reproduce the above copyright
; *    notice, this list of conditions and the following disclaimer in the 
; *    documentation and/or other materials provided with the   
; *    distribution.
; *
; *    Neither the name of Texas Instruments Incorporated nor the names of
; *    its contributors may be used to endorse or promote products derived
; *    from this software without specific prior written permission.
; *
; *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
; *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
; *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
; *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
; *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
; *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
; *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
; *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
; *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
; *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
; *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
; *
;*/

;***********************************************************
; Version 3.00.00                                           
;***********************************************************
;****************************************************************
; Function:    maxidx
; Processor:   C55xx
; Description: Description: Returns the index of the maximum element of a vector x. In case
;       of multiple maximum elements, r contains the index of the last maximum
;       element found
; Usage:    short r = maxidx (DATA *x, ushort ng, ushort ng_size)
;       Arguments:
;          *x        Pointer to input vector of size nx  (where nx = ng * ng_size)
;          ng        Number of groups forming the x[nx] array
;          ng_size   Size of the group  
;          r         Index for vector element with maximum value
;
;       State of the registers on entry:
;          XAR0 contains *x
;          T0   contains ng
;          T1   contains ng_size
;       On exit:
;          T0   index of maximum value (from 0 to nx-1)
;
; Benchmarks:
;   Cycles:       (ng * 14) + (ng * ng_size / 2) + 29
;   Code Size (in bytes):  141
;
; History:
;  2.10 Cesar I. optimized code for benchmark purpose. 08/03/01
;  2.11 Li Yuan fixed code to work when the first element is the max 07/11/02
;  3.00 Craig Leeds 06/15/2012:
;   - Fixed bug where AR5 and AR6 pointed to TRN0 and TRN1 but AR5H and AR6H not set
;   - Fixed bug where TRN0 not set to 0 before first iteration of loop
;   - Fixed bug where T2 not set to 0 before first iteration of loop
;   - Fixed bug where DP is used, but DPH is never set
;   - .bss usage removed
;
;****************************************************************

      .ARMS_off                     ;enable assembler for ARMS=0
      .mmregs                       ;enable mem mapped register names 
      .noremark   5555, 5584, 5573, 5572       
      
; Local variable
;----------------

; Stack frame
; -----------
RET_ADDR_SZ       .set 1            ;return address
REG_SAVE_SZ       .set 5            ;save-on-entry registers saved (T3, T2, AR5, AR6, DP)
FRAME_SZ          .set 0            ;local variables
ARG_BLK_SZ        .set 0            ;argument block

PARAM_OFFSET      .set ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ + RET_ADDR_SZ         

;----------------------------------------------------------------
; Assign auxiliary registers for temporaries and address
; calculations.
;----------------------------------------------------------------
      .asg     AR0, x_ptr           ;linear pointer                    
      .asg     AR5, trn0_ptr        ; linear pointer
      .asg     AR6, trn1_ptr        ; linear pointer
      .asg     AC3, maxv
      .asg     BRC0, outer_cnt      ;outer loop count

        .global _maxidx    

        .text                                                           
_maxidx:   

;
; Save any save-on-entry registers that are used
; Allocate the local frame and argument block
; Copy arguments to local locations and set registers
;----------------------------------------------------------------

        PSH     T3, T2
     || BCLR    #ARMS, ST2_55
        PSHBOTH XAR5
     || BCLR    #CPL, ST1_55              ;DP relative addressing
        PSHBOTH XAR6
     || SUB  #1, T0                    ;T0 = ng-1
        PSHBOTH XDP

        AMOV #0, XDP                   ;set DP=0 for mmreg accesses
          .dp 0       
;
;-----------------------------------------------------------------------
; x pointer - passed in its destination register, need do nothing
          
;
; Setup loop counts
;----------------------------------------------------------------
      
        MOV  T0, outer_cnt             ;outer loop executes ng times
     || MOV  #0, AR1                  ; AR1 = #0 used to initialize TRN0,1

        MOV  T1, T3                    ; T3 = ng_size
     || MOV  *x_ptr, maxv              ; maxValue = x[0]    

        SFTL T1, #-1
        AMOV #TRN1_L, XAR6             ; trn1_ptr = &TRN1 
           
        SUB  #2, T1

        MOV  T1, CSR                   ;CSR = NG_SIZE/2 - 2
        AMOV #TRN0_L, XAR5             ; trn0_ptr = &TRN0

        MOV  T1, AR3                   ;init position of leading zero 
    
        XOR  T1, T1                    ; T1 = 0
     || MOV  #0ffh, AR2

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        MOV  T1, *AR5                  ; TRN0 = 0
     || MOV  #0, T2                    ; T2 = 0
        MOV  T1, AR4                   ; AR4 = 0 (save base index of max value initially)

;BENCHMARK KERNEL ******************************************************
;Data values are processed via the outer loop N_GROUP values at a time.
;The outer loop is therefore executed N_INPUT/N_GROUP times.
;
;  Register usage during loop:
;    T1    ng_size * index
;    T3    ng_size
;    AR0   &x[ng_size * index] (aligned)
;    AR1   0
;    AR2   0xff
;    AR3   ng_size/2 - 2
;    AR4   base index of max value (ng_size * index) + odd
;    AR5   &TRN0
;    AR6   &TRN1
;    AC3   maximum value
;    CSR   ng_size/2 - 2
;    BRC0  ng - 1
;

      ||RPTBLOCAL outer_loop-1                  ;START OF OUTER LOOP *******************

              MOV  AR1, *AR6                    ; init TRN1 = #0 
           || MOV  dbl(*AR0+), AC1              ;AC1_H = x[ng_size * index + 0],  AC1_L = x[ng_size * index + 1]

              MOV  dbl(*AR0+), AC0              ;AC0_H = x[ng_size * index + 2],  AC0_L = x[ng_size * index + 3]
           || RPT  CSR                          ;repeat( #( (N_GROUP/2 - 1) - 1) )
                    MAXDIFF AC0, AC1, AC1, AC2  ;AC1_H/L contain max's
                 || MOV  dbl(*AR0+), AC0

              MOV  maxv, AC0                    ;AC0 = old max value   
            ||SUB  #2, AR0 
      
              MOV  AC1, T0                      ; T0    = odd max value
           || SFTS AC1, #-16                    ; AC1_L = even max value 
       
    ;test max(odd max value, even max value), Carry bit affected
              MAX  T0, AC1                      ;AC1 = max(odd max value, even max value) (affects CARRY for XCCPART!)
      
    ;test max(old max value, new max value)
              CMP  AC1 > AC0, TC1               ;TC1 set if max(odd,even) value > old max value
     
    ;assume even max value > odd max value
              MOV  T1, T0                       ;T0=ng_size * index  setup for even max index computation
           || MOV  *AR5 << #16, AC0             ;AC0_H = TRN0 (setup for even max index) 
   
              XCCPART  !CARRY                   ;if Carry=0 then odd max value > even max value
                    MOV  *AR6 << #16, AC0       ;AC0_H = TRN1 (setup for odd max index) 
                 || ADD  #1, T0                 ;T0 = (ng_size * index) + 1   modified for odd max index computation
   
    ;PERFORM IN_LOOP NECESSARY PORTION OF INDEX COMPUTATION **********

;  if TC1=1 or TC2=1, then a new max value is > old max value
              MOV AR1, *AR5                     ; TRN0 = #0 (for next iteration)
            ||XCCPART TC1
                    MOV  AR2, @AC0_G            ;AC0_G = 0xff, to isolate leading zero
                 || MOV  T0, AR4                ;save base index of max value
      
              ADD  T3, T1                       ; T1 = ng_size * index   (T3 = ng_size)
           || XCC TC1
                    EXP  AC0, T2                ; T2 = position of leading zero in AC0 
                 || MOV  AC1, maxv              ;update maxValue
outer_loop:                                     ;end outer loop
          
        SUB  T2,  AR3                           ;subtract lead zero position from index seed
        SFTL AR3, #1                            ;mult by 2 since 2 values tested per iteration
        ADD  AR4, AR3                           ;AR3 = index of max value
        MOV  AR3, T0                            ; return value
;
; Deallocate the local frame and argument block
;----------------------------------------------------------------
;
; Restore status regs to expected C-convention values as needed
; Restore any save-on-entry registers that are used
;----------------------------------------------------------------

        POPBOTH XDP
        POPBOTH XAR6
     || BSET    #ARMS, ST2_55
        POPBOTH XAR5
     || BSET    #CPL, ST1_55                       ;SP relative addressing
        POP     T3, T2
; - not necessary for this function (the above is zero)

        RET        
    .end
        
        
        
        
        
        
        
        
        
        
maxidx34.asm/   1362765892  0     0     0       8024      `
;/*
; * Copyright (C) 2013 Texas Instruments Incorporated - http://www.ti.com/ 
; * 
; * 
; *  Redistribution and use in source and binary forms, with or without 
; *  modification, are permitted provided that the following conditions 
; *  are met:
; *
; *    Redistributions of source code must retain the above copyright 
; *    notice, this list of conditions and the following disclaimer.
; *
; *    Redistributions in binary form must reproduce the above copyright
; *    notice, this list of conditions and the following disclaimer in the 
; *    documentation and/or other materials provided with the   
; *    distribution.
; *
; *    Neither the name of Texas Instruments Incorporated nor the names of
; *    its contributors may be used to endorse or promote products derived
; *    from this software without specific prior written permission.
; *
; *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
; *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
; *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
; *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
; *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
; *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
; *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
; *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
; *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
; *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
; *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
; *
;*/

;***********************************************************
; Version 3.00.00                                           
;***********************************************************
;****************************************************************
; Function:    maxidx34
; Processor:   C55xx
; Description: Description: Returns the index of the maximum element of a vector x. In case
;        of multiple maximum elements, r contains the index of the last maximum
;        element found
;
; Usage:    short r = maxidx34 (DATA *x, ushort nx)
;     Arguments:
;        *x  Pointer to input vector of size nx 
;        nx  Number of elements in the x[NX] array  
;        r   Index for vector element with maximum value
;
;     State of the registers on entry:
;        XAR0 contains *x
;        T0   contains nx
;     State of the registers on exit:
;        T0   contains r
;
; Limitations:
;     x[] is aligned on an even word boundary
;     nx is a multiple of 2 
;     6 <= nx <= 34
;
; Benchmarks:
;   Cycles:       (nx / 2) + 26
;   Code Size (in bytes):  87
;
; History:
;  2.10 Cesar I. original code. 08/03/01
;  3.00 Craig Leeds 06/15/2012:
;   - Fixed bug where DP is used, but DPH is never set
;   - Optimized overhead by 16 cycles
;
;****************************************************************

      .ARMS_off                     ;enable assembler for ARMS=0
      .mmregs                       ;enable mem mapped register names 
      .noremark   5555, 5584, 5573, 5572       
      
      
; Stack frame
; -----------
RET_ADDR_SZ       .set 1            ;return address
REG_SAVE_SZ       .set 4            ;save-on-entry registers saved
FRAME_SZ          .set 0            ;local variables
ARG_BLK_SZ        .set 0            ;argument block

PARAM_OFFSET      .set ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ + RET_ADDR_SZ         


;----------------------------------------------------------------
; Assign auxiliary registers for temporaries and address
; calculations.
;----------------------------------------------------------------
        .asg    AR0, x_ptr           ;linear pointer                    
               
        .global _maxidx34    
        
        .text                                                           
_maxidx34:   

;
; Allocate the local frame and argument block
;----------------------------------------------------------------
;       AADD        #-(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ), SP
; - not necessary for this function (the above is zero)
;
; Save any save-on-entry registers that are used
;----------------------------------------------------------------

;
; Configure the status registers as needed.
;----------------------------------------------------------------

        PSHBOTH XDP
     || BCLR    #ARMS, ST2_55
        PSH     T2, T3   
     || BCLR    #CPL, ST1_55               ;DP relative addressing
        AMOV    #0, XDP                    ;set DP=0 for mmreg accesses
        .dp 0    
;
;-----------------------------------------------------------------------
; Copy arguments to local locations and set registers
;
;-----------------------------------------------------------------------
; x pointer - passed in its destination register, need do nothing

; Setup loop counts
;----------------------------------------------------------------
        SFTL    T0, #-1                    ;restore original value 
     || MOV     #0, AC3

        SUB     #2, T0  
        MOV     T0, CSR                    ;CSR = NG_SIZE/2 - 2
   
        XOR     T1,T1 
     || MOV     @AC3_L,TRN0                ; TRN0 = #0
        MOV     T0, AR3
     || MOV     @AC3_L,TRN1                ; TRN1 = #0  

; start benchmark
           
        MOV     dbl(*AR0+), AC1            ;AC1_H = Aaddr[0],  AC1_L = Aaddr[1]
    
       ; 1 stall
        MOV     dbl(*AR0+), AC0            ;AC0_H = Aaddr[2],  AC0_L = Aaddr[3]
     || RPT     CSR                        ;repeat( #( (NX/2 - 1) - 1) )
                MAXDIFF AC0, AC1, AC1, AC2   ;AC1_H/L contain max's
             || MOV     dbl(*AR0+), AC0

        ; 1 stall
        MOV     AC1, T2                    ; T0 = odd max value
     || MOV     @AC1_H, AC1                ; AC1_L = even max value
        ;assume even max value > odd max value
        MOV     T1, T0                     ;T0 setup for even max index computation
     || MOV     @TRN0_L << #16, AC0        ;AC0_H = TRN0 (setup for even max index)

        ;test max(odd max value, even max value), Carry bit affected
        MAX     T2, AC1                    ;AC1 = max(odd max value, even max value) 
     
        MOV     AR3, T3                    ; AR3  = #(NX/2 - 2)  ;index seed value
    || XCCPART  !CARRY                  ;if Carry=0 then odd max value > even max value
                MOV     @TRN1_L << #16, AC0  ;AC0_H = TRN1 (setup for odd max index)
             || ADD     #1, T0               ;T0 modified for odd max index computation
 
        MOV     #0ffh, @AC0_G              ;AC0_G = 0xff, to isolate leading zero
        ; 1 stall
        EXP     AC0, T2                    ;T2 = position of leading zero in AC0 
  
        SUB     T2, T3                     ;subtract lead zero position from index seed
        SFTL    T3, #1                     ;mult by 2 since 2 values tested per iteration
;   
; Restore status regs to expected C-convention values as needed
;----------------------------------------------------------------
;
; Restore any save-on-entry registers that are used
;----------------------------------------------------------------
;    
        POP     T2, T3
     || ADD     T3, T0                     ;T0 = index of max value (return value)
        POPBOTH XDP
     || BSET    #CPL, ST1_55               ;SP relative addressing
;
; Deallocate the local frame and argument block
;----------------------------------------------------------------
;      AADD        #+(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ), SP
; - not necessary for this function (the above is zero)

        RET        
     || BSET    #ARMS, ST2_55
    .end

        
        
        
        
        
        
        
        
        
        maxval.asm/     1362765892  0     0     0       5497      `
;/*
; * Copyright (C) 2013 Texas Instruments Incorporated - http://www.ti.com/ 
; * 
; * 
; *  Redistribution and use in source and binary forms, with or without 
; *  modification, are permitted provided that the following conditions 
; *  are met:
; *
; *    Redistributions of source code must retain the above copyright 
; *    notice, this list of conditions and the following disclaimer.
; *
; *    Redistributions in binary form must reproduce the above copyright
; *    notice, this list of conditions and the following disclaimer in the 
; *    documentation and/or other materials provided with the   
; *    distribution.
; *
; *    Neither the name of Texas Instruments Incorporated nor the names of
; *    its contributors may be used to endorse or promote products derived
; *    from this software without specific prior written permission.
; *
; *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
; *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
; *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
; *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
; *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
; *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
; *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
; *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
; *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
; *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
; *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
; *
;*/

;***********************************************************
; Version 3.00.00                                           
;***********************************************************
; Function:    maxval
; Processor:   C55xx
; Description: Description: Returns the value of the maximum element of a vector x
; Usage:    short r = maxval (DATA *x, ushort nx)
;	Arguments:
;         *x     Pointer to input vector of size nx 
;         nx     number of elements in the x[nx] array  
;         r      maximum value
;
;	State of the registers after the call:
;
;	XAR0 contains *x
;	T0   contains nx
;
; Benchmarks:
;   Cycles:       (nx / 2) + 15
;   Code Size (in bytes):  28
;
; History:
;  2.10 Cesar I. optimized code for benchmark purpose. 08/03/01
;  3.0.0 Craig Leeds  - 05/17/2012
;     Fixed bug where DP is used to access memory-mapped registers, but DPH is never set.
;     Optimized.
;****************************************************************
      .ARMS_on                      ;enable assembler for ARMS=1
      .mmregs                       ;enable mem mapped register names 
      .noremark   5555, 5584, 5573, 5572       
      

      
; Stack frame
; -----------
RET_ADDR_SZ       .set 1            ;return address
REG_SAVE_SZ       .set 0            ;save-on-entry registers saved
FRAME_SZ          .set 0            ;local variables
ARG_BLK_SZ        .set 0            ;argument block

PARAM_OFFSET      .set ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ + RET_ADDR_SZ         


;----------------------------------------------------------------
; Assign auxiliary registers for temporaries and address
; calculations.
;----------------------------------------------------------------

        .global _maxval   
	
        .text                                                           
_maxval:   

;
; Allocate the local frame and argument block
;----------------------------------------------------------------
;      AADD	#-(ARG_BLK_SZ + FRAME_SZ), SP
; - not necessary for this function (the above is zero)
;
; Configure the status registers as needed.
;----------------------------------------------------------------

;-----------------------------------------------------------------------
; Copy arguments to local locations and set registers
;
;-----------------------------------------------------------------------
; x pointer - passed in its destination register, need do nothing
	

; Setup loop counts
;----------------------------------------------------------------  

     SFTL  T0, #-1  			;divide by 2 
     SUB  #2, T0
     MOV T0, CSR			;CSR = NX/2 - 2

     MOV dbl(*AR0+), AC1 		;AC1_H = Aaddr[0],  AC1_L = Aaddr[1]
     MOV dbl(*AR0+), AC0		;AC0_H = Aaddr[2],  AC0_L = Aaddr[3]

  || RPT CSR  
          MOV dbl(*AR0+), AC0
       || MAXDIFF AC0, AC1, AC1, AC2	;AC1_H/L contain max's
    
     MOV AC1, T0			;T0 = odd max value
     MOV HI(AC1), T1 		        ;T1 = even max value
      
  ;test max(odd max value, even max value), Carry bit affected
     MAX T1, T0                         ;AC3 = max(odd max value, even max value) 
; return value in T0
;
; Restore status regs to expected C-convention values as needed
;----------------------------------------------------------------
;
; Restore any save-on-entry registers that are used
;----------------------------------------------------------------
;
; Deallocate the local frame and argument block
;----------------------------------------------------------------
;      AADD	#+(ARG_BLK_SZ + FRAME_SZ), SP
; - not necessary for this function (the above is zero)

    RET        
        
        
        
        
        
        
        
        
        
        
maxvec.asm/     1362765892  0     0     0       2837      `
;/*
; * Copyright (C) 2013 Texas Instruments Incorporated - http://www.ti.com/ 
; * 
; * 
; *  Redistribution and use in source and binary forms, with or without 
; *  modification, are permitted provided that the following conditions 
; *  are met:
; *
; *    Redistributions of source code must retain the above copyright 
; *    notice, this list of conditions and the following disclaimer.
; *
; *    Redistributions in binary form must reproduce the above copyright
; *    notice, this list of conditions and the following disclaimer in the 
; *    documentation and/or other materials provided with the   
; *    distribution.
; *
; *    Neither the name of Texas Instruments Incorporated nor the names of
; *    its contributors may be used to endorse or promote products derived
; *    from this software without specific prior written permission.
; *
; *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
; *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
; *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
; *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
; *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
; *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
; *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
; *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
; *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
; *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
; *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
; *
;*/

;***********************************************************
; Version 3.00.00                                           
;***********************************************************
; Function:  MAXVEC
; Processor:   C55xx
; Description: maxvec: Value and Index of the maximum element of a vector
;
; Usage:	void maxvec (DATA *x, ushort nx, DATA *r_val, DATA *r_idx)
;
; Benchmarks:
;   Cycles:       (3 * nx) + 11
;   Code Size (in bytes):  30
;
; History:
;   05/26/12  Craig Leeds:   Optimized 
;********************************************************************************

        .global        _maxvec
        .text
_maxvec:
        MOV     *AR0+, AC1
     || SUB     #(1+1),T0

        MOV     T0, BRC0
     || MOV     #0, AR3

        MOV     #0, T0
        
        MOV     #0, T1
     || RPTBLOCAL LoopEnd-1
                MOV     *AR0+, AC0
             || ADD     #1, AR3
                MAX     AC0, AC1
                XCCPART end_block, !CARRY
                     || MOV     AR3, T1
LoopEnd:
        MOV     AC1,*AR1
        MOV     T1, *AR2
     || RET


minidx.asm/     1362776422  0     0     0       10419     `
;/*
; * Copyright (C) 2013 Texas Instruments Incorporated - http://www.ti.com/ 
; * 
; * 
; *  Redistribution and use in source and binary forms, with or without 
; *  modification, are permitted provided that the following conditions 
; *  are met:
; *
; *    Redistributions of source code must retain the above copyright 
; *    notice, this list of conditions and the following disclaimer.
; *
; *    Redistributions in binary form must reproduce the above copyright
; *    notice, this list of conditions and the following disclaimer in the 
; *    documentation and/or other materials provided with the   
; *    distribution.
; *
; *    Neither the name of Texas Instruments Incorporated nor the names of
; *    its contributors may be used to endorse or promote products derived
; *    from this software without specific prior written permission.
; *
; *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
; *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
; *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
; *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
; *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
; *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
; *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
; *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
; *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
; *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
; *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
; *
;*/

;***********************************************************
; Version 3.00.00                                           
;***********************************************************
;****************************************************************
; Function:    minidx
; Processor:   C55xx
; Description: Description: Returns the index of the minimum element of a vector x. In case
;	of multiple minimum elements, r contains the index of the last minimum
;	element found
; Usage:    short r = minidx (DATA *x, ushort ng, ushort ng_size)
;      Arguments:

;          *x        Pointer to input vector of size nx  (where nx = ng * ng_size)
;         ng         Number of groups forming the x[nx] array
;         ng_size    Size of the group  
;         r          Index for vector element with minimum value
;
;      State of the registers on entry:
;          XAR0 contains *x
;          T0   contains ng
;          T1   contains ng_size
;       On exit:
;          T0   index of minimum value (from 0 to nx-1)
;
; Benchmarks:
;   Cycles:       (ng * 14) + (ng * ng_size / 2) + 29
;   Code Size (in bytes):  141
;
; History:
;  2.10 Li Yuan optimized code for benchmark purpose. 07/11/02
;               also fixed bug to make code works when the first element is min.
;  3.00 Craig Leeds 06/15/2012:
;   - Fixed bug where AR5 and AR6 pointed to TRN0 and TRN1 but AR5H and AR6H not set
;   - Fixed bug where TRN0 not set to 0 before first iteration of loop
;   - Fixed bug where T2 not set to 0 before first iteration of loop
;   - Fixed bug where DP is used, but DPH is never set
;   - .bss usage removed
;
;****************************************************************

      .ARMS_off                     ;enable assembler for ARMS=0
      .mmregs                       ;enable mem mapped register names 
      .noremark   5555, 5584, 5573, 5572       
      
; Local variable
;----------------

      
; Stack frame
; -----------
RET_ADDR_SZ       .set 1            ;return address
REG_SAVE_SZ       .set 5            ;save-on-entry registers saved (T3, T2, AR5, AR6, DP)
FRAME_SZ          .set 0            ;local variables
ARG_BLK_SZ        .set 0            ;argument block

PARAM_OFFSET      .set ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ + RET_ADDR_SZ         


;----------------------------------------------------------------
; Assign auxiliary registers for temporaries and address
; calculations.
;----------------------------------------------------------------
      .asg     AR0, x_ptr           ;linear pointer                    
      .asg     AR5, trn0_ptr        ; linear pointer
      .asg     AR6, trn1_ptr        ; linear pointer
      .asg     AC3, minv
      .asg     BRC0, outer_cnt      ;outer loop count

    
        .global _minidx    
        
        .text                                                           
_minidx:   

;
; Save any save-on-entry registers that are used
; Allocate the local frame and argument block
; Copy arguments to local locations and set registers
;----------------------------------------------------------------

        PSH     T3, T2
     || BCLR    #ARMS, ST2_55
        PSHBOTH XAR5
     || BCLR    #CPL, ST1_55              ;DP relative addressing
        PSHBOTH XAR6
     || SUB  #1, T0                    ;T0 = ng-1
        PSHBOTH XDP

        AMOV #0, XDP                   ;set DP=0 for mmreg accesses
          .dp 0       
;
;-----------------------------------------------------------------------
; x pointer - passed in its destination register, need do nothing
      
;
; Setup loop counts
;----------------------------------------------------------------
      
        MOV  T0, outer_cnt       ;outer loop executes ng times
     || MOV  #0, AR1             ; AR1 = #0 used to initialize TRN0,1

        MOV  T1, T3              ; T3 = ng_size
     || MOV  *x_ptr, minv        ; minValue = x[0]    

        SFTL T1, #-1
        AMOV #TRN1_L, XAR6       ; trn1_ptr = &TRN1 
           
        SUB  #2, T1

        MOV  T1, CSR             ;CSR = NG_SIZE/2 - 2
        AMOV #TRN0_L, XAR5       ; trn0_ptr = &TRN0

        MOV  T1, AR3             ;init position of leading zero 
    
        XOR  T1, T1              ; T1 = 0
     || MOV  #0ffh, AR2

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        MOV  T1, *AR5            ; TRN0 = 0
     || MOV  #0, T2              ; T2 = 0
        MOV  T1, AR4             ; AR4 = 0 (save base index of min value initially)

;BENCHMARK KERNEL ******************************************************
;Data values are processed via the outer loop N_GROUP values at a time.
;The outer loop is therefore executed N_INPUT/N_GROUP times.
;
;  Register usage during loop:
;    T1    ng_size * index
;    T3    ng_size
;    AR0   &x[ng_size * index] (aligned)
;    AR1   0
;    AR2   0xff
;    AR3   ng_size/2 - 2
;    AR4   base index of min value (ng_size * index) + odd
;    AR5   &TRN0
;    AR6   &TRN1
;    AC3   minimum value
;    CSR   ng_size/2 - 2
;    BRC0  ng - 1
;

      ||RPTBLOCAL outer_loop-1                  ;START OF OUTER LOOP *******************

              MOV  AR1, *AR6                    ; init TRN1 = #0 
           || MOV  dbl(*AR0+), AC1              ;AC1_H = x[ng_size * index + 0],  AC1_L = x[ng_size * index + 1]

              MOV  dbl(*AR0+), AC0              ;AC0_H = x[ng_size * index + 2],  AC0_L = x[ng_size * index + 3]
           || RPT  CSR                          ;repeat( #( (N_GROUP/2 - 1) - 1) )
                    MINDIFF AC0, AC1, AC1, AC2  ;AC1_H/L contain min's
                 || MOV  dbl(*AR0+), AC0

              MOV  minv, AC0                    ;AC0 = old min value   
            ||SUB  #2, AR0 
      
              MOV  AC1, T0                      ; T0    = odd min value
           || SFTS AC1, #-16                    ; AC1_L = even min value 
       
    ;test min(odd min value, even min value), Carry bit affected
              MIN  T0, AC1                      ;AC1 = min(odd min value, even min value) (affects CARRY for XCCPART!)
      
    ;test min(old min value, new min value)
              CMP  AC0 >= AC1, TC1              ;TC1 set if min(odd,even) value > old min value
     
    ;assume even min value > odd min value
              MOV  T1, T0                       ;T0=ng_size * index  setup for even min index computation
           || MOV  *AR5 << #16, AC0             ;AC0_H = TRN0 (setup for even min index) 
   
              XCCPART  !CARRY                   ;if Carry=0 then odd min value > even min value
                    MOV  *AR6 << #16, AC0       ;AC0_H = TRN1 (setup for odd min index) 
                 || ADD  #1, T0                 ;T0 = (ng_size * index) + 1   modified for odd min index computation
   
    ;PERFORM IN_LOOP NECESSARY PORTION OF INDEX COMPUTATION **********

;  if TC1=1 or TC2=1, then a new min value is > old min value
              MOV AR1, *AR5                     ; TRN0 = #0 (for next iteration)
            ||XCCPART TC1
                    MOV  AR2, @AC0_G            ;AC0_G = 0xff, to isolate leading zero
                 || MOV  T0, AR4                ;save base index of min value
      
              ADD  T3, T1                       ; T1 = ng_size * index   (T3 = ng_size)
           || XCC TC1
                    EXP  AC0, T2                ;T2 = position of leading zero in AC0 
                 || MOV  AC1, minv              ;update minValue
outer_loop:                                     ;end outer loop
          
        SUB  T2,  AR3                           ;subtract lead zero position from index seed
        SFTL AR3, #1                            ;mult by 2 since 2 values tested per iteration
        ADD  AR4, AR3                           ;AR3 = index of min value
        MOV  AR3, T0                            ; return value
;
; Deallocate the local frame and argument block
;----------------------------------------------------------------
;
; Restore status regs to expected C-convention values as needed
; Restore any save-on-entry registers that are used
;----------------------------------------------------------------

        POPBOTH XDP
        POPBOTH XAR6
     || BSET    #ARMS, ST2_55
        POPBOTH XAR5
     || BSET    #CPL, ST1_55         ;SP relative addressing
        POP     T3, T2
; - not necessary for this function (the above is zero)

        RET        
      .end
          
          
          
          
          
          
          
          
          
          
minval.asm/     1362765892  0     0     0       5329      `
;/*
; * Copyright (C) 2013 Texas Instruments Incorporated - http://www.ti.com/ 
; * 
; * 
; *  Redistribution and use in source and binary forms, with or without 
; *  modification, are permitted provided that the following conditions 
; *  are met:
; *
; *    Redistributions of source code must retain the above copyright 
; *    notice, this list of conditions and the following disclaimer.
; *
; *    Redistributions in binary form must reproduce the above copyright
; *    notice, this list of conditions and the following disclaimer in the 
; *    documentation and/or other materials provided with the   
; *    distribution.
; *
; *    Neither the name of Texas Instruments Incorporated nor the names of
; *    its contributors may be used to endorse or promote products derived
; *    from this software without specific prior written permission.
; *
; *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
; *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
; *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
; *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
; *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
; *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
; *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
; *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
; *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
; *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
; *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
; *
;*/

;***********************************************************
; Version 3.00.00                                           
;***********************************************************
; Function:    minval
; Processor:   C55xx
; Description: Description: Returns the value of the minimum element of a vector x
; Usage:    short r = minval (DATA *x, ushort nx)
;	Arguments:
;         *x     Pointer to input vector of size nx 
;         nx     number of elements in the x[nx] array  
;         r      minimum value
;
;	State of the registers after the call:
;
;	XAR0 contains *x
;	T0   contains nx
;
; Benchmarks:
;   Cycles:       (nx / 2) + 15
;   Code Size (in bytes):  28
;
; History:
;  2.10.04 Li Yuan optimized code for benchmark purpose. 08/03/01
;  3.0.0 Craig Leeds  - 05/17/2012
;     Fixed bug where DP is used to access memory-mapped registers, but DPH is never set.
;     Optimized.
;****************************************************************
    .ARMS_on                     ;enable assembler for ARMS=1
    .mmregs                       ;enable mem mapped register names 
    .noremark   5555, 5584, 5573, 5572       


; Stack frame
; -----------
RET_ADDR_SZ       .set 1            ;return address
REG_SAVE_SZ       .set 0            ;save-on-entry registers saved
FRAME_SZ          .set 0            ;local variables
ARG_BLK_SZ        .set 0            ;argument block

PARAM_OFFSET      .set ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ + RET_ADDR_SZ         


;----------------------------------------------------------------
; Assign auxiliary registers for temporaries and address
; calculations.
;----------------------------------------------------------------
    .global _minval

    .text
_minval:

;
; Allocate the local frame and argument block
;----------------------------------------------------------------
;      AADD	#-(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ), SP
; - not necessary for this function (the above is zero)
;
; Configure the status registers as needed.
;----------------------------------------------------------------
;-----------------------------------------------------------------------
; Copy arguments to local locations and set registers
;
;-----------------------------------------------------------------------
; x pointer - passed in its destination register, need do nothing

; Setup loop counts
;----------------------------------------------------------------  

     SFTL  T0, #-1  			;divide by 2 
     SUB  #2, T0
     MOV T0, CSR			;CSR = NX/2 - 2

     MOV dbl(*AR0+), AC1 		;AC1_H = Aaddr[0],  AC1_L = Aaddr[1]
     MOV dbl(*AR0+), AC0		;AC0_H = Aaddr[2],  AC0_L = Aaddr[3]

  || RPT CSR  
          MOV dbl(*AR0+), AC0
       || MINDIFF AC0, AC1, AC1, AC2	;AC1_H/L contain min's
    
     MOV AC1, T0			;T0 = odd min value
     MOV HI(AC1), T1 		        ;T1 = even min value
      
  ;test min(odd min value, even min value), Carry bit affected
     MIN T1, T0                         ;AC3 = min(odd min value, even min value) 
; return value in T0
;
; Restore status regs to expected C-convention values as needed
;----------------------------------------------------------------
;
; Restore any save-on-entry registers that are used
;----------------------------------------------------------------
;
; Deallocate the local frame and argument block
;----------------------------------------------------------------
;      AADD	#+(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ), SP
; - not necessary for this function (the above is zero)

    RET        


minvec.asm/     1362765892  0     0     0       2823      `
;/*
; * Copyright (C) 2013 Texas Instruments Incorporated - http://www.ti.com/ 
; * 
; * 
; *  Redistribution and use in source and binary forms, with or without 
; *  modification, are permitted provided that the following conditions 
; *  are met:
; *
; *    Redistributions of source code must retain the above copyright 
; *    notice, this list of conditions and the following disclaimer.
; *
; *    Redistributions in binary form must reproduce the above copyright
; *    notice, this list of conditions and the following disclaimer in the 
; *    documentation and/or other materials provided with the   
; *    distribution.
; *
; *    Neither the name of Texas Instruments Incorporated nor the names of
; *    its contributors may be used to endorse or promote products derived
; *    from this software without specific prior written permission.
; *
; *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
; *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
; *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
; *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
; *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
; *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
; *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
; *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
; *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
; *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
; *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
; *
;*/

;***********************************************************
; Version 3.00.00                                           
;***********************************************************
; Function:  MINVEC
; Processor:   C55xx
; Description: minimum Value and Index of the minimum element of a vector
;
; Usage:	void minvec (DATA *x, ushort nx, DATA *val, DATA *idx)
;
; Benchmarks:
;   Cycles:       (3 * nx) + 11
;   Code Size (in bytes):  30
;
; History:
;   05/26/12  Craig Leeds:   Optimized 
;********************************************************************************

        .text
        .global	_minvec
	
_minvec:
        MOV     *AR0+,AC1
     || SUB     #(1+1),T0

        MOV     T0,BRC0
     || MOV     #0,AR3

        MOV     #0,T0
        
        MOV     #0, T1
     || RPTBLOCAL LoopEnd-1
                MOV     *AR0+,AC0
             || ADD     #1, AR3
                MIN     AC0,AC1
                XCCPART end_block, !CARRY
                     || MOV     AR3, T1
LoopEnd:
        MOV     AC1,*AR1
        MOV     T1, *AR2
     || RET


mmul.asm/       1362765892  0     0     0       11234     `
;/*
; * Copyright (C) 2013 Texas Instruments Incorporated - http://www.ti.com/ 
; * 
; * 
; *  Redistribution and use in source and binary forms, with or without 
; *  modification, are permitted provided that the following conditions 
; *  are met:
; *
; *    Redistributions of source code must retain the above copyright 
; *    notice, this list of conditions and the following disclaimer.
; *
; *    Redistributions in binary form must reproduce the above copyright
; *    notice, this list of conditions and the following disclaimer in the 
; *    documentation and/or other materials provided with the   
; *    distribution.
; *
; *    Neither the name of Texas Instruments Incorporated nor the names of
; *    its contributors may be used to endorse or promote products derived
; *    from this software without specific prior written permission.
; *
; *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
; *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
; *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
; *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
; *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
; *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
; *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
; *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
; *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
; *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
; *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
; *
;*/

;***********************************************************
; Version 3.00.00                                           
;***********************************************************
;  Function:	mmul
;  Description: matrix multiply implementation
;  Usage:   short mmul(	DATA *x1,	XAR0
;			short row1,	T0
;			short col1,	T1
;			DATA *x2,	XAR1
;			short row2,	AR2
;			short col2,	AR3
;			DATA *r);	XAR4
;
; Benchmarks:
;   Cycles:       
;   Code Size (in bytes):  202
;
; History
;  2.10.1 - clear C54CM bit at the begining. Li Yuan 08/08/01
;  3.00.00 - Craig Leeds 05/17/2012
;    Fix bug where T2 and T3 were used but not restored.
;    Optimize.
;                
;****************************************************************
        .mmregs
        .noremark 5684
        .ARMS_off

        .def _mmul
        .text
_mmul:
        PSH     T3,T2
     || BSET    FRCT                    ;fractional mode set
        PSHBOTH XAR5        
     || MOV     T0, T2                  ;T2 = row1
        PSHBOTH XAR6                                
     || MOV     T1, T0                  ;T0 = col1
                                        ;XAR0 = x1
                                        ;T0 = row1
                                        ;T1 = col1
                                        ;XAR1 = x2
                                        ;AR2 = row2
                                        ;AR3 = col2
                                        ;XAR4 = r                                          

;---------------------------------------------------                                        
; Verify that the dimensions of the input matrices are legal, i.e. input1 
; row size = input2 column size; else return input1 as output
;---------------------------------------------------                                        
        SUB     AR2, T0                 ;T0 = col1 - row2
        SUB     #3, T1, T3
        SUB     #4, T2, AR5
        OR      AR5, T3                 ; if col1 < 3 or row1 < 4 then T3 < 0
     || BCC     mmulend, T0 != #0       ;return value FALSE (i.e. T0 != 0)

; Setup temps
	BCLR    ARMS
        MOV     AR3, T0                 ;T0 = col2
                                        ;T1 = col1
                                        ;T2 = row1
        BCLR    ACOV0

; test if usage of Dual-MAC or Single-MAC

        BCLR    ACOV1                   ; Not really necessary since result is Success/Failure and not overflow
     || BCC     mmul_single_mac, T3<#0

;---------------------------------------------------                                        
; Dual-MAC implementation for large matrices
; col1>=3 && row1>=4
;---------------------------------------------------
mmul_dual_mac:
                                        ;---- pointers ----
        MOV     XAR0, XAR3              ;XAR0 = &x1(1,1) (reload reg for XAR2, XAR3)
        MOV     XAR0, XAR2              ;XAR2 = &x1(1,1)
        AADD    T1, AR3                 ;XAR3 = &x1(2,1)
        MOV     XAR1, XCDP              ;XCDP = &x2(1,1)
        MOV     XAR4, XAR5              ;XAR5 = &r(1,1)
        MOV     XAR1, XAR4              ;XAR4 = &x2(1,1) (reload reg for XCDP)
        MOV     XAR5, XAR6              ;XAR6 = &r(1,1) (reload reg for XAR5)

                                        ;---- loop counters ----
        SUB     #1, T0, T3              ;
        MOV     T3, BRC0                ;outer loop count: BRC0 = col2-1
        BTST    #0, mmap(T2), TC1        ;if(row1==even) TC0=0 else TC0=1
        SUB     #3, T1, T3              ;
        MOV     T3, CSR                 ;inner loop count: CSR = col1-3
        SFTL    T2, #-1
        SUB     #1, T2                  ;
        MOV     T2, BRC1                ;mid loop count: BRS1 = (row1>>1)-1
        
        MOV	AR0, T2
        ADD	T1, T2                  ; T2 = &x1[2,1]
        
        ADD	#1, T1

; Perform Matrix Multiply
     || BCC     DualOddOuterLoop, TC1
        

        RPTBLOCAL DualEvenOuterLoopEnd-1
                AMOV    AR0, AR2           ; AR2 points to x1(1,1)
             || RPTBLOCAL DualEvenInnerLoopEnd-1
                        MPY     *AR2+, *(CDP+T0), AC0         ;first iteration
                        ::MPY   *AR3+, *(CDP+T0), AC1         ;
                      ||RPT     CSR                      
                                MAC     *AR2+, *(CDP+T0), AC0
                                ::MAC   *AR3+, *(CDP+T0), AC1
                        MACR    *(AR2+T1), *CDP, AC0          ; last iteration ; AR2 points to next row of x1
                        ::MACR  *(AR3+T1), *CDP, AC1                           ; AR3 points to next row of x1
                        MOV     HI(AC0), *(AR5+T0)            ;store to r
                      ||AMAR    *AR4, XCDP                    ;CDP points to same column of x2 
                        MOV     HI(AC1), *(AR5+T0)            ;store to r
DualEvenInnerLoopEnd:

                AMAR    *AR4+,*AR6+,*CDP+  ; AR4 points to next column of x2
                                           ; AR6 points to next column of r
                                           ; CDP points to next column of x2
                AMOV    T2, AR3            ; AR3 points to x1(2,2)                                        
             || MOV     AR6, AR5           ; AR5 points to next column of r
DualEvenOuterLoopEnd:

        B       mmulret

DualOddOuterLoop:
        ADD     T1, T2
        SUB     #1, T2
     || RPTBLOCAL DualOddOuterLoopEnd-1

                ;----- if(row1==odd) do first row of x using single MAC, then go to Dual MAC
                MPYM    *AR2+, *(CDP+T0), AC0
              ||RPT     CSR                        
                        MACM    *AR2+, *(CDP+T0), AC0
                MACMR   *AR2+, *CDP, AC0
              ||MOV     AR4, CDP                       ;CDP points to same column of x2
                MOV     HI(AC0), *(AR5+T0)             ;store to r
              ||AMOV    T2, AR3                        ;|| AR3 points to next row of x1

                RPTBLOCAL DualOddInnerLoopEnd-1
                        MPY     *AR2+, *(CDP+T0), AC0         ;first iteration
                        ::MPY   *AR3+, *(CDP+T0), AC1         ;
                      ||RPT     CSR                      
                                MAC     *AR2+, *(CDP+T0), AC0
                                ::MAC   *AR3+, *(CDP+T0), AC1
                        MACR    *(AR2+T1), *CDP, AC0          ; last iteration ; AR2 points to next row of x1
                        ::MACR  *(AR3+T1), *CDP, AC1                           ; AR3 points to next row of x1
                        MOV     HI(AC0), *(AR5+T0)            ;store to r
                      ||AMAR    *AR4, XCDP                    ;CDP points to same column of x2 
                        MOV     HI(AC1), *(AR5+T0)            ;store to r
DualOddInnerLoopEnd:

                AMAR    *AR4+,*AR6+,*CDP+  ; AR4 points to next column of x2
                                           ; AR6 points to next column of r
                                           ; CDP points to next column of x2
                AMOV    AR0, AR2           ; AR2 points to x1(1,1)
              ||MOV     AR6, AR5           ; AR5 points to next column of r
DualOddOuterLoopEnd:

        B       mmulret
;---------------------------------------------------                                        
; Single-MAC implementation for small matrices
; col1<3 || row1<4
;---------------------------------------------------
mmul_single_mac:
                                 ;---- pointers ----
        MOV     XAR0, XAR2       ;XAR2 = &x1(1,1)  XAR0 = &x1(1,1) for reload
        MOV     XAR1, XAR3       ;XAR3 = &x2(1,1)  XAR1 = &x2(1,1) for reload
        MOV     XAR4, XAR5       ;XAR5 = &r(1,1)   XAR4 = &r(1,1) for reload

                                 ;---- loop counters ----
        SUB     #1, T0, T3       ;
        MOV     T3, BRC0         ;outer loop count: BRC0 = col2-1
        SUB     #1, T2
        MOV     T2, BRC1         ;mid loop count: BRC1 = row1-1
        SUB     #1, T1
        MOV     T1, CSR          ;inner loop count: CSR = col1-1

; Perform Matrix Multiply

        RPTBLOCAL        SingleOuterLoopEnd-1
                AMAR    *AR4+                   ;AR4 points to next column of r
            ||  RPTBLOCAL SingleInnerLoopEnd-1
                        MOV     #0, AC0                        ;clear AC0
                      ||RPT     CSR                            ;
                                MACM    *AR2+, *(AR3+T0), AC0
                        MOV     RND(HI(AC0)), *(AR5+T0)        ;store rounded result to r        
                      ||AMOV    AR1, AR3                       ;AR3 points back to beginning of same column of x2
SingleInnerLoopEnd:

                AMAR    *AR1+          ;AR1 points to next column of x2
              ||MOV     AR0, AR2       ;AR2 points to x1(1,1)
                AMOV    AR1, AR3       ;AR3 points to next column of x2
              ||MOV     AR4, AR5       ;AR5 points to next column of r                                        
SingleOuterLoopEnd:

mmulret:        
        MOV     #0, T0              ;return value TRUE
      ||BSET    ARMS

mmulend:
        POPBOTH XAR6
      ||BCLR    FRCT
        POPBOTH XAR5
        POP     T3,T2
        RET

mtrans.asm/     1362765892  0     0     0       3833      `
;/*
; * Copyright (C) 2013 Texas Instruments Incorporated - http://www.ti.com/ 
; * 
; * 
; *  Redistribution and use in source and binary forms, with or without 
; *  modification, are permitted provided that the following conditions 
; *  are met:
; *
; *    Redistributions of source code must retain the above copyright 
; *    notice, this list of conditions and the following disclaimer.
; *
; *    Redistributions in binary form must reproduce the above copyright
; *    notice, this list of conditions and the following disclaimer in the 
; *    documentation and/or other materials provided with the   
; *    distribution.
; *
; *    Neither the name of Texas Instruments Incorporated nor the names of
; *    its contributors may be used to endorse or promote products derived
; *    from this software without specific prior written permission.
; *
; *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
; *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
; *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
; *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
; *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
; *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
; *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
; *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
; *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
; *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
; *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
; *
;*/

;***********************************************************
; Version 3.00.00                                           
;***********************************************************
; Function:	mtrans
; Description: matrix multiply implementation
; Usage: short mtrans(	DATA *x1,	AR0
;			short row1,	T0
;			short col1,	T1
;			DATA *r);	AR1
;
;          Always returns 0 in T0
;
; Benchmarks:
;   Cycles:       (row1 * (col1 + 1)) + 19
;   Code Size (in bytes):  56
;
; History:
;   05/26/12  Craig Leeds:   
;          - Fixed bug where T2 was modified but not restored
;          - Optimized 
;****************************************************************
	.mmregs
	.def _mtrans
				;XAR0 = x1
				;T0 = row1
				;T1 = col1
				;XAR1 = r
	
	.text
_mtrans:
        MOV     T0, HI(AC0)
     || BSET    AR0LC
        MPY     T1, AC0, AC1                ;AC1 = row1*col1
     || MOV     XAR1, XAR2                  ;XAR2 = r to ensure MDP

        MOV     AR0, mmap(@BSA01)           ;BSA01 = x1
        MOV     AR1, mmap(@BSA23)           ;BSA23 = r
        MOV     AC1, mmap(@BK03)            ;init block size
        BSET    AR2LC
        SUB     #1, T0, AR3
        MOV     AR3, BRC0                   ;outer loop BRC0 = row-1 (Note; for CPU_117, this must be > 2 cycles prior to RPTBLOCAL)
        SUB     #1, T1, AR3
        MOV     AR3, CSR                    ;inner loop CSR = col-1
        AMOV    #0, AR2                     ;AR2 = 0
        AMOV    #0, AR0                     ;AR0 = 0
        AMAR    *AR2-                       ;  next col of r        
	
     || RPTBLOCAL  EndLoop-1                ;for every row of x1
                AMAR    *AR2+               ;  next col of r        
             || RPT     CSR                 ;  for every col of x1
                        MOV     *AR0+, *(AR2+T0)
EndLoop:

        BCLR    AR0LC                       ; restore AR0 to linear for C
     || MOV     #0, T0                      ; return value is OK
        BCLR    AR2LC                       ; restore AR2 to linear for C
     || RET


mul32.asm/      1362765892  0     0     0       4706      `
;/*
; * Copyright (C) 2013 Texas Instruments Incorporated - http://www.ti.com/ 
; * 
; * 
; *  Redistribution and use in source and binary forms, with or without 
; *  modification, are permitted provided that the following conditions 
; *  are met:
; *
; *    Redistributions of source code must retain the above copyright 
; *    notice, this list of conditions and the following disclaimer.
; *
; *    Redistributions in binary form must reproduce the above copyright
; *    notice, this list of conditions and the following disclaimer in the 
; *    documentation and/or other materials provided with the   
; *    distribution.
; *
; *    Neither the name of Texas Instruments Incorporated nor the names of
; *    its contributors may be used to endorse or promote products derived
; *    from this software without specific prior written permission.
; *
; *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
; *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
; *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
; *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
; *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
; *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
; *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
; *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
; *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
; *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
; *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
; *
;*/

;***********************************************************
; Version 3.00.00                                           
;***********************************************************
; Function:    mul32
; Processor:   C55xx
; Description: Implements a vector add using a single-MAC 
;              approach.  This routine is C-callable.
;
; Usage:   ushort mul32(LDATA *x, LDATA *y,  LDATA *r, ushort nx);
;
; Benchmarks:
;   Cycles:       (4 * nx) + 17
;   Code Size (in bytes):  47
;
; History:
;  Craig Leeds 05/28/2012: 
;    - Fixed bug where AR5 was modified but not restored.
;    - Fixed bug where T3 was modified but not restored.
;****************************************************************

        .mmregs
        .ARMS_off

                                    ; register usage
                                    ; ar0: addr. idx
      .asg      ar0, ar_x  ; used for mul32
      .asg      ar1, ar_y
      .asg      ar2, ar_z

      .asg     T0, oflag            ;returned value

;*****************************************************************************
      .ARMS_off                     ;enable assembler for ARMS=0
      .CPL_on                       ;enable assembler for CPL=1
      .mmregs                       ;enable mem mapped register names

      .def      _mul32
      .text

_mul32:

;
; Configure the status registers as needed.
;----------------------------------------------------------------

      BCLR      ARMS
      BSET      FRCT
      BCLR      ACOV0

  ; Setup passed parameters in their destination registers
; Setup circular/linear CDP/ARx behavior
;----------------------------------------------------------------

; x pointer - passed in its destination register, need do nothing

; y pointer - - passed in its destination register, need do nothing

; r/z pointer - passed in its destination register, need do nothing

      SUB   #1, T0
   || MAR   *ar_x+          ; ar_x = &X[0].Lo
      MOV   T0, BRC0              

      AMOV  #2,T0           ; for indexing
      AMOV  #3,T1           ; for indexing


      ; long data are stored in XH[0],XL[0], XH[1],XL[1], XH[2],XL[2], ... 
   || RPTBLOCAL LoopEnd-1        
            MPYM40 uns(*ar_x-), *ar_y+, AC0 
            MACM40 *ar_x, uns(*ar_y-), AC0 
            MACM40 *(ar_x+T1), *(ar_y+T0), AC0 >> #16
            MOV    saturate(AC0), dbl(*ar_z+)
LoopEnd:                                 ; Total loop cycles = 4 

; Return
;--------
;
; Check if overflow occurred, and setup return value
;----------------------------------------------------------------

      MOV       #0, oflag              ;clear oflag
   || BCLR      FRCT
      XCCPART   overflow(AC0)          ;clears ACOV0
            ||MOV    #1, oflag         ;overflow occurred

      BSET      ARMS
   || RET

;end of file. please do not remove. it is left here to ensure that no lines of code are removed by any editor
neg.asm/        1362765892  0     0     0       3861      `
;/*
; * Copyright (C) 2013 Texas Instruments Incorporated - http://www.ti.com/ 
; * 
; * 
; *  Redistribution and use in source and binary forms, with or without 
; *  modification, are permitted provided that the following conditions 
; *  are met:
; *
; *    Redistributions of source code must retain the above copyright 
; *    notice, this list of conditions and the following disclaimer.
; *
; *    Redistributions in binary form must reproduce the above copyright
; *    notice, this list of conditions and the following disclaimer in the 
; *    documentation and/or other materials provided with the   
; *    distribution.
; *
; *    Neither the name of Texas Instruments Incorporated nor the names of
; *    its contributors may be used to endorse or promote products derived
; *    from this software without specific prior written permission.
; *
; *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
; *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
; *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
; *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
; *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
; *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
; *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
; *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
; *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
; *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
; *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
; *
;*/

;***********************************************************
; Version 3.00.00                                           
;***********************************************************
; Function:    NEG
; Processor:   C55xx
; Description: Implements 2's complement of an input vector.
;              This routine is C-callable.
;
; Algorithm:   for(i=0, i<nx, i++)
;	             x(i) = - x(i); 
;
; Usage: ushort oflag =  neg (DATA *x,
;                              DATA *r,
;                               ushort nx)
;
;
; Benchmarks:
;   Cycles:       (1 * nx) + 12
;   Code Size (in bytes):  26
;
;        Craig Leeds  - 05/17/2012
;   AR1 no longer set to a circular buffer.
;   Optimized both loop and housekeeping.
;****************************************************************

	.ARMS_off		;enable assembler for ARMS=0
	.CPL_on			;enable assembler for CPL=1
	.mmregs			;enable mem mapped register names

; ---------------------------------------------------------------
; Stack Frame Setup
; ---------------------------------------------------------------

RET_ADDR_SZ	.set 1		;return address
REG_SAVE_SZ	.set 0		;save-on-entry registers saved
FRAME_SZ	.set 0		;local variables
ARG_BLK_SZ	.set 0		;argument block

PARAM_OFFSET	.set ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ + RET_ADDR_SZ

; ---------------------------------------------------------------
; Register usage and definitions
; ---------------------------------------------------------------
	.asg	AR0, x_ptr	;linear pointer for first input vector
	.asg	AR1, r_ptr	;linear pointer for result vector

	.asg	BRC0, outer_cnt	;outer loop count
	.asg	T0, oflag	;returned value

	.def _neg
	.text
_neg:
	SUB	#1, T0			;T0=nx-1
	MOV	T0, CSR
 	MOV	#0, AC1
	||BCLR	ACOV0
	MOV	#0, oflag		;clear oflag
	SUB	*x_ptr+ << #16, AC1, AC0	; (Prime the Pump)
 	||RPT	CSR
 		MOV	HI(AC0), *r_ptr+
		||SUB	*x_ptr+ << #16, AC1, AC0
		
	XCCPART	overflow(AC0)	;clears AC0V0
		||MOV 	#1, oflag		;overflow occured

	RET				;return to calling function

;----------------------------------------------------------------
;End of file


neg32.asm/      1362765892  0     0     0       6914      `
;/*
; * Copyright (C) 2013 Texas Instruments Incorporated - http://www.ti.com/ 
; * 
; * 
; *  Redistribution and use in source and binary forms, with or without 
; *  modification, are permitted provided that the following conditions 
; *  are met:
; *
; *    Redistributions of source code must retain the above copyright 
; *    notice, this list of conditions and the following disclaimer.
; *
; *    Redistributions in binary form must reproduce the above copyright
; *    notice, this list of conditions and the following disclaimer in the 
; *    documentation and/or other materials provided with the   
; *    distribution.
; *
; *    Neither the name of Texas Instruments Incorporated nor the names of
; *    its contributors may be used to endorse or promote products derived
; *    from this software without specific prior written permission.
; *
; *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
; *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
; *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
; *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
; *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
; *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
; *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
; *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
; *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
; *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
; *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
; *
;*/

;***********************************************************
; Version 3.00.00                                           
;***********************************************************
; Function:    NEG32 
; Processor:   C55xx
; Description: Implements a 32-bit 2'complement of an input
;              vector.  This routine is C-callable.
;
; Algorithm:   for(i=0, i<nx, i++)
;	              r(i) =  - x(i); 
;
; Usage: ushort oflag = neg32 (LDATA *x,
;                              LDATA *r,
;                              ushort nx)
;
; Benchmarks:
;   Cycles:       (1 * nx) + 12
;   Code Size (in bytes):  31
;
; History:
; 1. Corrected loop lable
;           ------Li Yuan 10/31/2000
; 2. Corrected SATD bit setting from clear to set.
;           ------Li Yuan 01/19/2001
; 3. SATD cleared on exit.
;    AR1 no longer set to circular buffer.
;    Loop and housekeeping optimized by 67%.
;           ------Craig Leeds 05/17/2012
;****************************************************************

      .ARMS_on                     ;enable assembler for ARMS=1
      .CPL_on                       ;enable assembler for CPL=1
      .mmregs                       ;enable mem mapped register names

; -----------
; Stack frame
; -----------

RET_ADDR_SZ       .set 1            ;return address
REG_SAVE_SZ       .set 0            ;save-on-entry registers saved
FRAME_SZ          .set 0            ;local variables
ARG_BLK_SZ        .set 0            ;argument block

PARAM_OFFSET      .set ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ + RET_ADDR_SZ

; ------------------------------
; Register usage and definitions
; ------------------------------
	.asg     AR0, x_ptr           	;linear pointer for first input vector
	.asg     AR1, r_ptr           	;linear pointer for result vector

	.asg     T0, oflag           	;returned value

	.def _neg32
	.text

_neg32:

; ---------------------------------------------------------------
; Allocate the local frame and argument block
; ---------------------------------------------------------------
;      SP = SP - #(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ)
; - not necessary for this function (the above is zero)

; ---------------------------------------------------------------
; Save any save-on-entry registers that are used
; ---------------------------------------------------------------
; - nothing to save for this function

; ---------------------------------------------------------------
; Setup loop counts
; --------------------------------------------------------------

	SUB	#1, T0			;T0 = nx - 1
	MOV	T0, CSR 		;outer loop executes nx times
        MOV     #0, AC1

; ---------------------------------------------------------------
; Configure the status registers as needed.
; ---------------------------------------------------------------

     || BSET	SATD			
	BCLR	ACOV0			; clear overflow bit 
	MOV	#0, oflag		;cler oflag

; ---------------------------------------------------------------
; Setup passed parameters in their destination registers
; Setup linear CDP/ARx behavior
; ---------------------------------------------------------------
; x pointer - passed in its destination register
; y pointer - passed in its destination register
; r pointer - passed in its destination register
; ---------------------------------------------------------------

; ---------------------------------------------------------------
; Start of outer loop 
; for (i=0; iP<nx; i++)
;    R(i) = - X(i);
; ---------------------------------------------------------------

	SUB	dbl(*AR0+), AC1, AC0	;AC0=32-bit value (input vector) (Prime the Pump)

     || RPT     CSR
	        MOV	AC0, dbl(*AR1+)		;storing 32-bit ACC to mem
	     || SUB	dbl(*AR0+), AC1, AC0	;AC0=32-bit value (input vector) (for next iteration)

; ---------------------------------------------------------------
; Check if overflow occurred, and setup return value
; ---------------------------------------------------------------

	XCCPART	overflow(AC0)	;clears AC0V0
	    ||MOV	#1, oflag		;overflow occured

; ---------------------------------------------------------------
; Restore status regs to expected C-convention values as needed
; ---------------------------------------------------------------

; ----------------------------------------------------------------
; Restore any save-on-entry registers that are used
; ----------------------------------------------------------------
; - nothing to restore for this function

; ---------------------------------------------------------------
; Deallocate the local frame and argument block
; ---------------------------------------------------------------
;      SP = SP + #(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ)
; - not necessary for this function (the above is zero)

; ---------------------------------------------------------------
; Return to calling function
; ---------------------------------------------------------------
      BCLR	SATD
    ||RET                      ;return to calling function

;----------------------------------------------------------------
;End of file


power.asm/      1362765892  0     0     0       6904      `
;/*
; * Copyright (C) 2013 Texas Instruments Incorporated - http://www.ti.com/ 
; * 
; * 
; *  Redistribution and use in source and binary forms, with or without 
; *  modification, are permitted provided that the following conditions 
; *  are met:
; *
; *    Redistributions of source code must retain the above copyright 
; *    notice, this list of conditions and the following disclaimer.
; *
; *    Redistributions in binary form must reproduce the above copyright
; *    notice, this list of conditions and the following disclaimer in the 
; *    documentation and/or other materials provided with the   
; *    distribution.
; *
; *    Neither the name of Texas Instruments Incorporated nor the names of
; *    its contributors may be used to endorse or promote products derived
; *    from this software without specific prior written permission.
; *
; *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
; *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
; *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
; *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
; *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
; *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
; *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
; *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
; *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
; *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
; *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
; *
;*/

;***********************************************************
; Version 3.00.00                                           
;***********************************************************
; Function:    POWER
; Processor:   C55xx
; Description: Implements a vector power using a single-MAC 
;              approach.  This routine is C-callable.
;
; Algorithm:   for(i=0, i<nx, i++)
;                r(i) += x(i) * x(i); 
;
; Usage: ushort oflag = power (DATA *x,
;                             LDATA *r,
;                             ushort nx,
;
; Limitations:
;    nx >= 2
;
; Benchmarks:
;   Cycles:       (1 * nx) + 13
;   Code Size (in bytes):  29
;
; History:
; - Corrected return register from AR2 to AR1.
;               ---- Li Yuan    01/17/01
;
; - Return overflow value is in T0 instead of AC0. 
;   Output vector is pointed by AR3 and returned.
;      Zhengting He - 10/25/2006
;
;  - Fixed bug where corruption occured if AR1H != AR3H
;    Optimized overhead
;      Craig Leeds - 05/26/12  
;****************************************************************

      .ARMS_on                      ;enable assembler for ARMS=1
      .CPL_on                       ;enable assembler for CPL=1
      .mmregs                       ;enable mem mapped register names

; -----------
; Stack frame
; -----------

RET_ADDR_SZ       .set 1            ;return address
REG_SAVE_SZ       .set 0            ;save-on-entry registers saved 
FRAME_SZ          .set 0            ;local variables
ARG_BLK_SZ        .set 0            ;argument block

PARAM_OFFSET      .set ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ + RET_ADDR_SZ

; ------------------------------
; Register usage and definitions
; ------------------------------
	.asg     AR0, x_ptr           	;linear pointer for first input vector
	.asg     AR1, r_ptr           	;linear pointer for result vector

ST2mask	.set  0000000000010010b 	;circular/linear pointers


        .def _power
	.text

_power:


; ---------------------------------------------------------------
; Allocate the local frame and argument block
; ---------------------------------------------------------------
;      SP = SP - #(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ)
; - not necessary for this function (the above is zero)

; ---------------------------------------------------------------
; Save any save-on-entry registers that are used
; ---------------------------------------------------------------
; - nothing to save for this function
; ---------------------------------------------------------------
; Configure the status registers as needed.
; ---------------------------------------------------------------

; ---------------------------------------------------------------
; Setup loop counts
; ---------------------------------------------------------------

	SUB	#(1+1), T0	;T0 = nx - 1 
	MOV	T0, CSR		;outer loop executes nx times 

        BSET    FRCT
        BCLR    ACOV0

; ---------------------------------------------------------------
; Setup passed parameters in their destination registers
; Setup linear CDP/ARx behavior
; ---------------------------------------------------------------
; x pointer - passed in its destination register
; y pointer - passed in its destination register
; r pointer - passed in its destination register
; Set circular/linear ARx behavior                               
; ---------------------------------------------------------------


; ---------------------------------------------------------------
; Start of outer loop 
; for (i=0; iP<nx; i++)
;    R(i) = X(i) * X(i);
; ---------------------------------------------------------------
; ----------------------------------------------------
; AC0 = m40(rnd(AC1 + uns(*x_ptr+)) * uns(*y_ptr+))))
; ----------------------------------------------------

	SQRM	*x_ptr+, AC0			;zero out the ACC and the first mpy
	||RPT	CSR
	       SQAM	*x_ptr+, AC0		;vector MAC of two inputs

	MOV AC0, dbl(*AR1)  

; ADDED CODE TO CHECK THE OVERFLOW
; Check if overflow occurred, and setup return value
;----------------------------------------------------------------
	||MOV #0, T0
	XCCPART overflow(AC0)
               ||MOV #1, T0 		; 


; ---------------------------------------------------------------
; Restore status regs to expected C-convention values as needed
; ---------------------------------------------------------------
; ----------------------------------------------------------------
; Restore any save-on-entry registers that are used
; ----------------------------------------------------------------
; - nothing to restore for this function
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
;
; Deallocate the local frame and argument block
;----------------------------------------------------------------
; ---------------------------------------------------------------
; Return to calling function
; ---------------------------------------------------------------
      RET					;return to calling function
    ||BCLR	FRCT				;clear FRCT

;----------------------------------------------------------------
;End of file

q15tofl.asm/    1362765892  0     0     0       6001      `
;/*
; * Copyright (C) 2013 Texas Instruments Incorporated - http://www.ti.com/ 
; * 
; * 
; *  Redistribution and use in source and binary forms, with or without 
; *  modification, are permitted provided that the following conditions 
; *  are met:
; *
; *    Redistributions of source code must retain the above copyright 
; *    notice, this list of conditions and the following disclaimer.
; *
; *    Redistributions in binary form must reproduce the above copyright
; *    notice, this list of conditions and the following disclaimer in the 
; *    documentation and/or other materials provided with the   
; *    distribution.
; *
; *    Neither the name of Texas Instruments Incorporated nor the names of
; *    its contributors may be used to endorse or promote products derived
; *    from this software without specific prior written permission.
; *
; *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
; *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
; *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
; *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
; *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
; *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
; *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
; *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
; *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
; *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
; *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
; *
;*/

;***********************************************************
; Version 3.00.00                                           
;***********************************************************
; Function:	q15tofl
; Description: converts Q15 to IEEE floating point
;
; Usage:  ushort q15tofl(DATA *x, float *r, ushort nx);
;
; Notes:
;    The 32-bit single precision IEEE Floating Point is stored as follows:
;      Bit 31:      sign:  0 => positive, 1 => negative
;      Bits 23-30:  exponent: 2's complement from -128 to +127
;      Bits 0-22:   mantissa: 23-bits unsigned
;    The mantissa also includes an implied bit at bit 23 equal to 1 unless the exponent is 0.
;
; Benchmarks:
;   Cycles:       (15 * nx) + 15
;   Code Size (in bytes):  83
;
; History:
;    Craig Leeds 05/22/2012:
;       - Fixes bug where T3 was used and not restored
;       - Fixes bug where overflow flag bit was not cleared on entry
;       - Optimized by 50%
;****************************************************************

        .ARMS_on                      ;enable assembler for ARMS=0
        .CPL_on                       ;enable assembler for CPL=1
        .mmregs

;----------------------------------------------------------------
; Function definition:
;----------------------------------------------------------------

        .global        _q15tofl

        .text
_q15tofl:

;----------------------------------------------------------------
; Prologue: establish local frame, reset sign extension mode
;----------------------------------------------------------------

        BCLR    ACOV0                   ; clear overflow bit
        SUB     #1, T0
        MOV     T0, BRC0

;----------------------------------------------------------------
; Store function constants
;----------------------------------------------------------------

        MOV     #127, AR2               ; AR2 = 127
        MOV     #0x3fff << #16, AC3
        OR      #0xffff, AC3            ; AC3 = 0x3fffffff
        MOV     #0x7fff << #16, AC2     ; AC2 = 0x7fff0000
        
        MOV     *AR0+ << #16, AC0       ; (Prime the Pump)

;----------------------------------------------------------------
; Convert each element of vector A, to Q15 format
; Pre-Load first vector element
;----------------------------------------------------------------
        
        ||RPTBLOCAL end_loop-1
                CMP     AC0 == AC2, TC2                ; TC2 set if AC0_H == 0x7fff
                AND     #32768 << #16, AC0, AC1        ; AC1 = bit-31 of AC0 (i.e. sign bit)
                SFTL    AC1, #-31, AC1                 ; Put sign in LSB
             || MOV     HI(AC0), AR3
        
                XCCPART TC2 
                      ||MOV        #0, AC0
 
                ABS     AC0
             || SFTL    AC1, #31, AC1

;----------------------------------------------------------------
; Shift right by one, since exp and norm never count shift into
; upper most bit (bit 31)
;----------------------------------------------------------------

                SFTS    AC0, #-1                       ; 
                MANT    AC0, AC0
                ::NEXP  AC0, T1
                ADD     AR2, T1                        ; T1 += 127

;----------------------------------------------------------------
; Remove upper most bit as this becomes an implicit 1
; 2^exp * (1.f) where f is mantissa
;----------------------------------------------------------------

             || AND     AC3, AC0                       ; remove sign bit from AC0
                ADD     mmap(T1) << #(16+7), AC1
                SFTS    AC0, #-7, AC0                        ; 
                OR      AC1, AC0

		XCCPART AR3 == #0                      ; check for input value being zero
                     || MOV     #0, AC0
                     
                MOV     AC0, dbl(*AR1+)
             || MOV     *AR0+ << #16, AC0

end_loop:

;----------------------------------------------------------------
; Return to calling program.
;----------------------------------------------------------------
        
        MOV    #0, T0
        XCCPART overflow(AC0)
             || MOV     #1, T0

        RET        




rand16.asm/     1362765892  0     0     0       4629      `
;/*
; * Copyright (C) 2013 Texas Instruments Incorporated - http://www.ti.com/ 
; * 
; * 
; *  Redistribution and use in source and binary forms, with or without 
; *  modification, are permitted provided that the following conditions 
; *  are met:
; *
; *    Redistributions of source code must retain the above copyright 
; *    notice, this list of conditions and the following disclaimer.
; *
; *    Redistributions in binary form must reproduce the above copyright
; *    notice, this list of conditions and the following disclaimer in the 
; *    documentation and/or other materials provided with the   
; *    distribution.
; *
; *    Neither the name of Texas Instruments Incorporated nor the names of
; *    its contributors may be used to endorse or promote products derived
; *    from this software without specific prior written permission.
; *
; *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
; *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
; *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
; *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
; *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
; *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
; *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
; *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
; *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
; *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
; *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
; *
;*/

;***********************************************************
; Version 3.00.00                                           
;***********************************************************
; Filename:	rand16.asm
; Processor:   C55xx
; Description: Generates 16 bit random numbers
;
; Usage: ushort oflag= rand16(DATA *r, ushort nr)
;                                                              
; Benchmarks:
;   Cycles:       (2 * nx) + 17
;   Code Size (in bytes):  54
;
;        Craig Leeds  - 05/17/2012 3.00.00
;   Fix bug where T3 was not being restored.
;   Fix bug where abs16(#rndseed) was used without DPH being set to 0.
;   Optimize main loop. 
;**************************************************************** 		
;
; Use memory mapped register mnemonics
;-----------------------------------------------------------------------------
			.mmregs

;-----------------------------------------------------------------------------
; Define constants used in the random number generation algorithm
;-----------------------------------------------------------------------------
                                    
RNDMULT		.set	31821					; Multiplier value
RNDINC		.set	13849					; Increment value     
			
;-----------------------------------------------------------------------------
; Initialize Random Number Generator -	Load the SEED value
;-----------------------------------------------------------------------------
        	.ref	rndseed         ; Global variable initialized in randinit()
		.def	_rand16

		.text
_rand16: 
      PSH       T3
   || BCLR	SMUL,ST3_55	  	; Clear SMUL bit  
      BCLR	ACOV0,ST0_55          	; Clear AC0 overflow flag 

      SUB	#1,T0                	; Set up count to 'nr-1'	
      MOV	T0,CSR		    	; Store number of vector  elements in repeat cntr  

      MOV	#RNDMULT,T1		; Initialize register with  constant	    	     						               		      			
      AMOV	#rndseed,XAR1
      AMOV      #AC0_L, XAR2
      MOV	#RNDINC,AC1		; Initialize register with constant  

      MACM	*AR1,T1,AC1,AC0	        ; (Prime the Pump)
*
* Note: AR2 access of AC0_L causes one delay cycle in the repeat loop.
*
   || RPT       CSR
            MOV	    AC0, *AR0+		      	; Store random number in array
         || MACM    T3=*AR2,T1,AC1,AC0	  	; Generate new random number  

      MOV	T3,*AR1           	; Store final result as random seed 
	        
      MOV	#0,T0                 	; Clear flag for returning overflow status              									  		 
   || POP       T3
      XCCPART    overflow(AC0)           ; Test AC0 overflow flag
          || MOV    #1,T0                ; If overflow, set return flag		

      BSET	SMUL,ST3_55	  	; set SMUL bit on exit
   || RET                    
;end of file. please do not remove. it is left here to ensure that no lines of code are removed by any editor
    


rand16i.asm/    1362765892  0     0     0       3314      `
;/*
; * Copyright (C) 2013 Texas Instruments Incorporated - http://www.ti.com/ 
; * 
; * 
; *  Redistribution and use in source and binary forms, with or without 
; *  modification, are permitted provided that the following conditions 
; *  are met:
; *
; *    Redistributions of source code must retain the above copyright 
; *    notice, this list of conditions and the following disclaimer.
; *
; *    Redistributions in binary form must reproduce the above copyright
; *    notice, this list of conditions and the following disclaimer in the 
; *    documentation and/or other materials provided with the   
; *    distribution.
; *
; *    Neither the name of Texas Instruments Incorporated nor the names of
; *    its contributors may be used to endorse or promote products derived
; *    from this software without specific prior written permission.
; *
; *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
; *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
; *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
; *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
; *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
; *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
; *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
; *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
; *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
; *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
; *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
; *
;*/

;***********************************************************
; Version 2.40.00                                           
;***********************************************************
; Filename:	rand16init.asm
; Processor:   C55xx
; Description: Initializes seed for 16 bit random number generation routine
; Usage: void rand16init(void)
;****************************************************************
;-----------------------------------------------------------------------------
; Use memory mapped register mnemonics
;-----------------------------------------------------------------------------

			.mmregs

;-----------------------------------------------------------------------------
; Reserve space in DATA memory for seed 
;-----------------------------------------------------------------------------
 			.def rndseed

	 		.bss rndseed,1 
		
;-----------------------------------------------------------------------------
; Define constants used in the random number generation algorithm
;-----------------------------------------------------------------------------

RNDSEED 	.set  1     			; seed value (i.e. rndnum(1) = 21845)

;-----------------------------------------------------------------------------
; Initialize Random Number Generator -	Load the SEED value
;-----------------------------------------------------------------------------

			.def	_rand16init
			.text

_rand16init:

		MOV		#RNDSEED, *(rndseed)
		RET

;end of file. please do not remove. it is left here to ensure that no lines of code are removed by any editor

	
recip16.asm/    1362765892  0     0     0       8809      `
;/*
; * Copyright (C) 2013 Texas Instruments Incorporated - http://www.ti.com/ 
; * 
; * 
; *  Redistribution and use in source and binary forms, with or without 
; *  modification, are permitted provided that the following conditions 
; *  are met:
; *
; *    Redistributions of source code must retain the above copyright 
; *    notice, this list of conditions and the following disclaimer.
; *
; *    Redistributions in binary form must reproduce the above copyright
; *    notice, this list of conditions and the following disclaimer in the 
; *    documentation and/or other materials provided with the   
; *    distribution.
; *
; *    Neither the name of Texas Instruments Incorporated nor the names of
; *    its contributors may be used to endorse or promote products derived
; *    from this software without specific prior written permission.
; *
; *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
; *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
; *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
; *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
; *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
; *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
; *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
; *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
; *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
; *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
; *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
; *
;*/

;***********************************************************
; Version 3.00.00                                           
;***********************************************************
; Function:    recip16
; Processor:   C55xx
; Description: Calculates reciprocal of Q15 number. C-callable.
;
; Usage: void recip16 (DATA *x, DATA *z, DATA *zexp, ushort nx)
;                                                              
; Benchmarks:
;   Cycles:       (18 * nx) + 14
;   Code Size (in bytes):  83
;
; History:
;   1.01  A. Jaffe  1/25/99 - Updated register usage using previous work 
;   by Alex Tessarolo and Jeff Axelrod.
;         07/07/2003 - fixed bug in range test 
;  05/22/2012 - Craig Leeds:
;      - Fixed bugs in ending of repeat blocks
;      - Optimized by 40%
;
;****************************************************************
;  Description:
;
;     This routine returns the fractional and exponential portion
;  of the reciprocal of a Q15 number. Since the reciprocal is always
;  greater than 1, it returns an exponent such that:
;          
;               z[i] * zexp[i] = reciprocal
;
;----------------------------------------------------------------
;  Algorithm:
;
;	     +--------------------------+
;	     |	Ym = 2*Ym - Ym^2*Xnorm 	| 		 
;	     +--------------------------+
;
;	If we start with an initial estimate of Ym, then equation
;	will converge to a solution very rapidly (typically
;	3 iterations for 16-bit resolution).
;
;	The initial estimate can either be obtained from a look up 
;	table, or from choosing a mid-point, or simply from linear 
;	interpolation. The method chosen for this problem is the
;	latter. This is simply accomplished by taking the complement
;	of the least significant bits of the Xnorm value.
;
;****************************************************************

      .ARMS_on                      ;enable assembler for ARMS=1
      .CPL_on                       ;enable assembler for CPL=1
      .mmregs                       ;enable mem mapped register names

; Stack frame
; -----------
RET_ADDR_SZ       .set 1            ;return address
REG_SAVE_SZ       .set 0            ;save-on-entry registers saved
FRAME_SZ          .set 0            ;local variables
ARG_BLK_SZ        .set 0            ;argument block

PARAM_OFFSET      .set ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ + RET_ADDR_SZ


; Register usage
; --------------
      .asg     AR0, x_ptr           ;linear pointer
      .asg     AR1, z_ptr           ;linear pointer
      .asg     AR2, zexp_ptr        ;linear pointer
      .asg     T2, ye_ptr           ;table linear pointer
      .asg     T0, norm_ptr         ;temp linear pointer
                   
      
      .global _recip16
      
      .text
_recip16:

; Allocate the local frame and argument block
;----------------------------------------------------------------
;      SP = SP - #(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ)
; - not necessary for this function (the above is zero)

;
; Save any save-on-entry registers that are used
;----------------------------------------------------------------
; - nothing to save for this function

;
; Configure the status registers as needed.
;----------------------------------------------------------------

        BSET    FRCT
     || AADD    #-1,SP
        BCLR    SMUL
;
; Setup passed parameters in their destination registers
; Setup circular/linear CDP/ARx behavior
;----------------------------------------------------------------

; x pointer - passed in its destination register, need do nothing
; z pointer - passed in its destination register, need do nothing
; zexp  pointer - passed in its destination register, need do nothing

; Set circular/linear ARx behavior

;
; Setup loop counts
;----------------------------------------------------------------

        SUB     #1, T0                        ;T0=n-1
        MOV     T0, BRC0                ;outer loop executes n times
;
        MOV     XSP, XAR3
        ;;;MOV     #1FFFh << #16, AC3        ;estimate the first Ym value
        MOV     #1, AC2
        
        MOV     *x_ptr+ <<#16, AC0        ;load first input value (prime the pump)
; Start of outer loop
;----------------------------------------------------------------

     || RPTBLOCAL OuterLoopEnd-1                   ;start the outer loop        
                MANT    AC0, AC0                   ;calculate normalization for 1st vlaue
              ::NEXP    AC0, T1
                MOV     HI(AC0), T0                ;store xnorm
             || SFTS    AC0 ,#-1                   ;shift right by 1 for 1st approximation
                XOR     #0x1fff << #16, AC0        ;estimate the first Ym value
                MOV     HI(AC0), *AR3              ;store first Ym
             || NEG     T1                         ;exponent value for offset pointer

; First iteration:  Calculate Ym = 2*Ym - Ym^2*X

                SFTS    AC0, #-1
             || ADD     #1, T1                     ;offset pointer to exponent
                MPYM    *AR3, T0, AC1
             || SFTL    AC2, T1, AC3               ;calculate exponent value
                MASM    *AR3, AC1, AC0
                MOV     HI(AC0 << #2), *AR3
                
; Second iteration:  Calculate Ym = 2*Ym - Ym^2*X
                
                SFTS    AC0, #1
             || MOV     AC3, *zexp_ptr+           ;store exponent
                MPYM    *AR3, T0, AC1
                MASM    *AR3, AC1, AC0
                MOV     HI(AC0 << #2), *AR3

; final iteration - same as previous two without final command
; Calculate Ym = 2*Ym - Ym^2*X

                SFTS    AC0, #1
             || MPYM    *AR3, T0, AC1
                MASM    *AR3, AC1, AC0
        
;-------------------------------------------------------------------------
; Check if value is in range 8000h <= Ym <= 7fffh, Adjust sign of result
;-------------------------------------------------------------------------
                MOV     HI(saturate(AC0 << #3)), *z_ptr+
             || MOV     *x_ptr+ << #16, AC0       ;load first input value (for next iteration)
OuterLoopEnd:                                     ;end of outer loop

;
; Restore status regs to expected C-convention values as needed
;----------------------------------------------------------------
; Restore any save-on-entry registers that are used
;----------------------------------------------------------------
; - nothing to restore for this function
;
; Deallocate the local frame and argument block
;----------------------------------------------------------------
;      SP = SP + #(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ)
; - not necessary for this function (the above is zero)
;
; Return to calling function
;----------------------------------------------------------------
        AADD    #+1,SP
     || BCLR    FRCT

        RET                                ;return to calling function
     || BSET    SMUL
        ;End of file

sine.asm/       1362765892  0     0     0       5892      `
;/*
; * Copyright (C) 2013 Texas Instruments Incorporated - http://www.ti.com/ 
; * 
; * 
; *  Redistribution and use in source and binary forms, with or without 
; *  modification, are permitted provided that the following conditions 
; *  are met:
; *
; *    Redistributions of source code must retain the above copyright 
; *    notice, this list of conditions and the following disclaimer.
; *
; *    Redistributions in binary form must reproduce the above copyright
; *    notice, this list of conditions and the following disclaimer in the 
; *    documentation and/or other materials provided with the   
; *    distribution.
; *
; *    Neither the name of Texas Instruments Incorporated nor the names of
; *    its contributors may be used to endorse or promote products derived
; *    from this software without specific prior written permission.
; *
; *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
; *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
; *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
; *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
; *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
; *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
; *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
; *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
; *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
; *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
; *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
; *
;*/

;***********************************************************
; Version 3.00.00                                           
;***********************************************************
; Function:    sine
; Processor:   C55x
; Description: Sine vector generation using polynomial evaluation.
;              C-callable
;
; Usage:  ushort sine(DATA *x, DATA *r, ushort nx);
;
; Benchmarks:
;   Cycles:       (11 * nx) + 20
;   Code Size (in bytes):     96
;
; History
;  07/07/2003 - d. elam fixed bug in q4.12 -> q1.15 conversion
;  3.00.00 - Craig Leeds 05/17/2012
;    Fix bug where overflow flag is not cleared at startup.
;    Optimized.
;****************************************************************

        .def        _sine
        
         .CPL_on
         .mmregs
        .asg        AR0, ar_x                    ;input vector
        .asg        AR1, ar_r                    ;output vector        

;****************************************************************
        
        .word        0x1CCE                        ;1.800293        (coeff for x^5 = c5)
        
        .text
_sine:

; Set status registers and get arguments 
; --------------------------------------
        
        PSH     T3, T2
     || BSET    FRCT                ;set FRCT
        BSET    SATD
        BCLR    ACOV0               ; clear overflow bit

        SUB     #1, T0              ;no: of inputs(AR2) - 1
        MOV     T0, BRC0            ;block repeat counter set to inputs -1
        MOV     #0xAACC << #16,AC2  ;AC2.Hi = -5.325196   (coeff for x^3 = c3)
        MOV     #0x0053, T0         ;T0 = 0.02026367      (coeff for x^2 = c2)
        MOV     #0x3240, T1         ;T1 = 3.140625        (coeff for x^1 = c1)
        
        MOV     #0x08B7 << #16, AC3 ; AC3.Hi = 0.5446778  (coeff for x^4 = c4)
        MOV     #0x1CCE, AR2        ; AR2 = 1.800293        (coeff for x^5 = c5)
        MOV     #0x7fff, AR3        ; AR3 = 0x7fff
        
        MOV     *ar_x+, T3          ; T3 = x[0] (Prime the Pump)
        MOV     #3, T2              ; T2 = 3
        ROL     TC2, T3, TC2, AR4   ; TC2 contains sign bit (Prime the Pump)
        
     || RPTBLOCAL LoopEnd-1

; If angle in 2nd and 4th quadrant then negate the result before removing
; sign bit
; -----------------------------------------------------------------------

                ROL     CARRY, AR4, CARRY, AR4  ; CARRY contains bit-14

                XCCPART CARRY                   ;if bit 14 is 1, negate and it in T3 
                      ||NEG     T3              ;T3 = -x
                      
                AND    AR3, T3                  ;T3 = x, remove sign bit from -x

; Start polynomial evaluation
; ---------------------------

             || MOV     AR2, HI(AC0)            ; AC0.Hi = c5
                MACR    AC0, T3, AC3, AC0
                MACR    AC0, T3, AC2, AC0       ; Note: AC2.Hi = c3
             || MOV     T0, HI(AC1)             ; AC1.Hi = c2
                MACR    AC0, T3, AC1, AC0
             || MOV     T1, HI(AC1)             ; AC1.Hi = c1
                MACR    AC0, T3, AC1, AC0
                MPYR    T3, AC0, AC0
             || MOV     *ar_x+, T3              ; T3 = x[i+1] (for next iteration) 
;changing the result from q4.12 to q1.15 format
; ---------------------------------------------                

; If angle in 3rd and 4th quadrant (negative angle), negate the result
; ---------------------------------------------------------------------

                XCCPART TC2
                      ||NEG     AC0
                MOV     HI(saturate(AC0 << T2)), *ar_r+
             || ROL     TC2, T3, TC2, AR4       ; TC2 contains sign bit (for next iteration)
LoopEnd:

; Return overflow flag
; --------------------

        MOV     #0, T0        
        XCCPART overflow(AC0)        ;clears ACOV0
             || MOV     #1, T0       ;overflow occured

; POP registers off stack and restore c environment
;--------------------------------------------------
        POP     T3, T2
     || BCLR    FRCT

        RET
     || BCLR    SATD

sqrtv.asm/      1362765892  0     0     0       7931      `
;/*
; * Copyright (C) 2013 Texas Instruments Incorporated - http://www.ti.com/ 
; * 
; * 
; *  Redistribution and use in source and binary forms, with or without 
; *  modification, are permitted provided that the following conditions 
; *  are met:
; *
; *    Redistributions of source code must retain the above copyright 
; *    notice, this list of conditions and the following disclaimer.
; *
; *    Redistributions in binary form must reproduce the above copyright
; *    notice, this list of conditions and the following disclaimer in the 
; *    documentation and/or other materials provided with the   
; *    distribution.
; *
; *    Neither the name of Texas Instruments Incorporated nor the names of
; *    its contributors may be used to endorse or promote products derived
; *    from this software without specific prior written permission.
; *
; *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
; *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
; *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
; *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
; *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
; *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
; *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
; *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
; *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
; *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
; *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
; *
;*/

;***********************************************************
; Version 3.00.00                                           
;***********************************************************
;***************************************************************
; Function :	sqrtv
; Processor:	C55x
; Description:   Square root of a 16-bit number
;		C-callable
;
; Usage: ushort sqrt_16(DATA *x, DATA *r, short nx);
;
; Benchmarks:
;   Cycles:       (22 * nx) + 24
;   Code Size:
;        .text     99 bytes
;        .const    32 bytes
;
; History:
;		- Li Yuan 01/30/2002
; 		  fixed the bug where NX should be stored in register T0 instead of AR2.
; 		  fixed code to work in large block memory by correct XAR loading.
; 3.00.00 - Craig Leeds 05/17/2012
;   Fixed bug where overflow flag is not cleared at startup.
;   Fixed bug in rounding method
;   Optimized by 40%.
;       
;****************************************************************

        .noremark  5684
        .mmregs 

; assign registers and set status bits
;-------------------------------------
        .asg AR0, AR_X                ;input vector
        .asg AR1, AR_R                ;output vector
        .asg AR4, AR_TBL
        .asg XAR4, XAR_TBL


        .asg 0, SP_TEMP
        
; Square root lookup table
;-------------------------------------------------
; Ytable = 1/sqrt(2^n) values:
;
           .sect ".const"
        .def SqrtTable
        .align
SqrtTable:                        
        .word        7FFFh                ; 1/sqrt(2^0)  = 0.99997 
        .word        5A82h                ; 1/sqrt(2^1)  = 0.70711 
        .word        4000h                ; 1/sqrt(2^2)  = 0.50000 
        .word        2D41h                ; 1/sqrt(2^3)  = 0.35355 
        .word        2000h                ; 1/sqrt(2^4)  = 0.25000 
        .word        16A1h                ; 1/sqrt(2^5)  = 0.17678
        .word        1000h                ; 1/sqrt(2^6)  = 0.12500 
        .word        0B50h                ; 1/sqrt(2^7)  = 0.08839
        .word        0800h                ; 1/sqrt(2^8)  = 0.06250 
        .word        05A8h                ; 1/sqrt(2^9)  = 0.04419 
        .word        0400h                ; 1/sqrt(2^10) = 0.03125 
        .word        02D4h                ; 1/sqrt(2^11) = 0.02210 
        .word        0200h                ; 1/sqrt(2^12) = 0.01563 
        .word        016Ah                ; 1/sqrt(2^13) = 0.01105 
        .word        0100h                ; 1/sqrt(2^14) = 0.00781 
        .word        0000h        
        
        
        .def    _sqrt_16
        .text
_sqrt_16:

        AADD    #-1, SP
     || BCLR    ACOV0
        BCLR    ACOV1

; N=N-1
;------
                                
        SUB     #1, T0               ;no: of inputs-1
        MOV     T0, BRC0             ;Block repeat counter set to no: of inputs-1

; Set Number Of Iterations of Sqrt Algorithm (N=5)
;------------------------------------------------
        MOV     #5-1, BRC1           ;inner loop counter set to no: of iterations-1
        
; Initialize constants
;---------------------
                                                   
        MOV     #0, BK03
        AMOV    #SqrtTable, XAR4     ;initialize square root lookup table XAR_TBL
        MOV     AR4,mmap(BSA45)
        BSET    AR4LC                ; Set up AR4 as a circular buffer
        MOV     #0x05E00, T1
        AMAR    *SP(SP_TEMP), XAR2
        MOV     #0x1 << #15, AC2     ; value to round the input
        ADD     *AR_X+ << #16, AC2, AC3  ;load the input to AC3, shift left by 16 bits (with round) (Prime the Pump)
      
     || RPTBLOCAL OuterLoopEnd-1                 

; Get next input value in array, x
; and round input value by adding 0x8000
;----------------------------------------------------------------

                ;;;ADD     *AR_X+ << #16, AC2, AC3        ;load the input to AC3, shift left by 16 bits (with round)
         
; Normalize input value
;----------------------
        
                MANT    AC3, AC3
                ::NEXP  AC3, T0                        ;normalize the input

             || MOV     T1, *AR2                       ; Initial value for Ynorm = 0x5e00

; Use lookup table to find SQRT of exponent
; lookup table index == exponent
;------------------------------------------
                NEG     T0, AR_TBL                     ;add the exponent to AR_TBL
             || SFTS    AC3, #-16, AC3
                MOV     T1, HI(AC0)                    ; Initial value for Ynorm = 0x5e00
             || SFTS    AC3, #15, AC3

; Load normalized estimate of square root
; Ynorm(new) = Ynorm(old) - (Ynorm(old)^2 - Xnorm)/2
;---------------------------------------------------
        
                MOV     AC3, AC1   
              ||RPTBLOCAL InnerLoopEnd-1               ; do 5 iterations
                        NOP_16                         ; added to avoid Remark 5682
                     || SQS     AC0, AC1
                        ADD     *AR2 << #16, AC1, AC0
                        MOV     HI(AC0), *AR2         
                     || MOV     AC3, AC1   
InnerLoopEnd:                                          ;inner loop ends here

; Multiply sqrt(Ynorm) * sqrt(normalized_exponent)
; And round the result
;-------------------------------------------------

                MPYM    *AR_TBL, AC0  
                MOV     RND(HI(AC0<<#1)), *AR_R+       ; Store result in AR_R
             || ADD     *AR_X+ << #16, AC2, AC3        ;load the input to AC3, shift left by 16 bits (with round) (for next iteration)
OuterLoopEnd:                                          ;outer loop ends here
        
;Return overflow flag
;---------------------
        MOV     #0, T0
        XCCPART overflow(AC0)
              ||MOV     #1, T0
        XCCPART overflow(AC1)
              ||MOV     #1, T0

; Pop off registers and restore c environment
;--------------------------------------------
        AADD    #+1, SP
        
;Return to calling function
;---------------------------        
        BCLR    AR4LC
     || RET
        



sub.asm/        1362765892  0     0     0       7308      `
;/*
; * Copyright (C) 2013 Texas Instruments Incorporated - http://www.ti.com/ 
; * 
; * 
; *  Redistribution and use in source and binary forms, with or without 
; *  modification, are permitted provided that the following conditions 
; *  are met:
; *
; *    Redistributions of source code must retain the above copyright 
; *    notice, this list of conditions and the following disclaimer.
; *
; *    Redistributions in binary form must reproduce the above copyright
; *    notice, this list of conditions and the following disclaimer in the 
; *    documentation and/or other materials provided with the   
; *    distribution.
; *
; *    Neither the name of Texas Instruments Incorporated nor the names of
; *    its contributors may be used to endorse or promote products derived
; *    from this software without specific prior written permission.
; *
; *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
; *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
; *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
; *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
; *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
; *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
; *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
; *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
; *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
; *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
; *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
; *
;*/

;***********************************************************
; Version 3.00.00                                           
;***********************************************************
; Function:    SUB
; Processor:   C55xx
; Description: Implements a vector sub using a single-MAC 
;              approach.  This routine is C-callable.
;
; Algorithm:   for(i=0; i<nx; i++)
;	             r(i) = x(i) - y(i); 
;
; Usage: ushort oflag = sub (DATA *x,
;                            DATA *y,
;                            DATA *r,
;                            ushort nx,
;                            ushort scale)
;
; Benchmarks:
;   Cycles:       (2 * nx) + 13
;   Code Size (in bytes):  31
;
;        Craig Leeds  - 05/17/2012
;   AR1 no longer set to a circular buffer.
;   Optimized both loop and housekeeping.
;****************************************************************

      .ARMS_on                     ;enable assembler for ARMS=1
      .CPL_on                      ;enable assembler for CPL=1
      .mmregs                      ;enable mem mapped register names

; -----------
; Stack frame
; -----------

RET_ADDR_SZ       .set 1            ;return address
REG_SAVE_SZ       .set 0            ;save-on-entry registers saved
FRAME_SZ          .set 0            ;local variables
ARG_BLK_SZ        .set 0            ;argument block

PARAM_OFFSET      .set ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ + RET_ADDR_SZ

; ------------------------------
; Register usage and definitions
; ------------------------------
        .asg     AR0, x_ptr                   ;linear pointer for first input vector
        .asg     AR1, y_ptr                   ;linear pointer for second input vector
        .asg     AR2, r_ptr                   ;linear pointer for result vector

        .asg     BRC0, outer_cnt              ;outer loop count
        .asg     T0, oflag                    ;returned value

        .def _sub
        .text
_sub:

; ---------------------------------------------------------------
; Allocate the local frame and argument block
; ---------------------------------------------------------------
;      SP = SP - #(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ)
; - not necessary for this function (the above is zero)

; ---------------------------------------------------------------
; Save any save-on-entry registers that are used
; ---------------------------------------------------------------
; - nothing to save for this function

; ---------------------------------------------------------------
; Configure the status registers as needed.
; ---------------------------------------------------------------

        BCLR    ACOV0

; ---------------------------------------------------------------
; Setup passed parameters in their destination registers
; Setup linear CDP/ARx behavior
; ---------------------------------------------------------------
; x pointer - passed in its destination register
; y pointer - passed in its destination register
; r pointer - passed in its destination register
; ---------------------------------------------------------------

; ---------------------------------------------------------------
; Setup loop counts
; ---------------------------------------------------------------

        SUB     #1, T0                       ;T0=nx-1
        MOV     T0, outer_cnt                ;outer loop executes nx times

; ---------------------------------------------------------------
; Setup output shift
; ---------------------------------------------------------------
        AMOV    #-1, T0
        XCC     T1 == #0                ;testing for scaling
             || AMOV    #0, T0

; ---------------------------------------------------------------
; Start of outer loop 
; for (i=0; iP<nx; i++)
;    R(i) = X(i) - Y(i);
; ---------------------------------------------------------------

        RPTBLOCAL LoopEnd-1                   ;start the outer loop
                SUB     *AR0+, *AR1+, AC0     ;vector subtract of two inputs
                MOV     HI(AC0 << T0), *AR2+  ; shift right by 0 or 1
LoopEnd:                                      ;end of outer loop

; ---------------------------------------------------------------
; Check if overflow occurred, and setup return value
; ---------------------------------------------------------------

        MOV     #0, oflag                ;clear oflag
        XCCPART overflow(AC0)
             || MOV     #1, oflag        ;overflow occured

; ---------------------------------------------------------------
; Restore status regs to expected C-convention values as needed
; ---------------------------------------------------------------

; ----------------------------------------------------------------
; Restore any save-on-entry registers that are used
; ----------------------------------------------------------------
; - nothing to restore for this function

; ---------------------------------------------------------------
; Deallocate the local frame and argument block
; ---------------------------------------------------------------
;      SP = SP + #(ARG_BLK_SZ + FRAME_SZ + REG_SAVE_SZ)
; - not necessary for this function (the above is zero)

; ---------------------------------------------------------------
; Return to calling function
; ---------------------------------------------------------------

      RET                 
                
;----------------------------------------------------------------
;End of file 
twiddle.asm/    1362765892  0     0     0       26708     `
;/*
; * Copyright (C) 2013 Texas Instruments Incorporated - http://www.ti.com/ 
; * 
; * 
; *  Redistribution and use in source and binary forms, with or without 
; *  modification, are permitted provided that the following conditions 
; *  are met:
; *
; *    Redistributions of source code must retain the above copyright 
; *    notice, this list of conditions and the following disclaimer.
; *
; *    Redistributions in binary form must reproduce the above copyright
; *    notice, this list of conditions and the following disclaimer in the 
; *    documentation and/or other materials provided with the   
; *    distribution.
; *
; *    Neither the name of Texas Instruments Incorporated nor the names of
; *    its contributors may be used to endorse or promote products derived
; *    from this software without specific prior written permission.
; *
; *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
; *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
; *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
; *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
; *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
; *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
; *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
; *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
; *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
; *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
; *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
; *
;*/

;***********************************************************
; Version 3.00.00                                           
;***********************************************************

	.def twiddle

	.sect ".const:twiddle" 

        .align  ; force the twiddle label to start on a longword boundary

twiddle:
        .word    32767		; cos(0)
        .word    0000		; sin(0)
        .word    0000		; cos(PI/2) 		
        .word    32767		; sin(PI/2)
        .word    23170		
        .word    23170		
        .word    -23170		
        .word    23170
        .word    30274
        .word    12540
        .word    -12540
        .word    30274
        .word    12540
        .word    30274
        .word    -30274
        .word    12540
        .word    32138
        .word    6393
        .word    -6393
        .word    32138
        .word    18205
        .word    27246
        .word    -27246
        .word    18205
        .word    27246
        .word    18205
        .word    -18205
        .word    27246
        .word    6393
        .word    32138
        .word    -32138
        .word    6393
        .word    32610
        .word    3212
        .word    -3212
        .word    32610
        .word    20788
        .word    25330
        .word    -25330
        .word    20788
        .word    28899
        .word    15447
        .word    -15447
        .word    28899
        .word    9512
        .word    31357
        .word    -31357
        .word    9512
        .word    31357
        .word    9512
        .word    -9512
        .word    31357
        .word    15447
        .word    28899
        .word    -28899
        .word    15447
        .word    25330
        .word    20788
        .word    -20788
        .word    25330
        .word    3212
        .word    32610
        .word    -32610
        .word    3212
        .word    32729
        .word    1608
        .word    -1608
        .word    32729
        .word    22006
        .word    24279
        .word    -24279
        .word    22006
        .word    29622
        .word    14010
        .word    -14010
        .word    29622
        .word    11039
        .word    30853
        .word    -30853
        .word    11039
        .word    31786
        .word    7962
        .word    -7962
        .word    31786
        .word    16846
        .word    28106
        .word    -28106
        .word    16846
        .word    26320
        .word    19520
        .word    -19520
        .word    26320
        .word    4808
        .word    32413
        .word    -32413
        .word    4808
        .word    32413
        .word    4808
        .word    -4808
        .word    32413
        .word    19520
        .word    26320
        .word    -26320
        .word    19520
        .word    28106
        .word    16846
        .word    -16846
        .word    28106
        .word    7962
        .word    31786
        .word    -31786
        .word    7962
        .word    30853
        .word    11039
        .word    -11039
        .word    30853
        .word    14010
        .word    29622
        .word    -29622
        .word    14010
        .word    24279
        .word    22006
        .word    -22006
        .word    24279
        .word    1608
        .word    32729
        .word    -32729
        .word    1608
        .word    32758
        .word    804
        .word    -804
        .word    32758
        .word    22595
        .word    23732
        .word    -23732
        .word    22595
        .word    29957
        .word    13279
        .word    -13279
        .word    29957
        .word    11793
        .word    30572
        .word    -30572
        .word    11793
        .word    31972
        .word    7180
        .word    -7180
        .word    31972
        .word    17531
        .word    27684
        .word    -27684
        .word    17531
        .word    26791
        .word    18868
        .word    -18868
        .word    26791
        .word    5602
        .word    32286
        .word    -32286
        .word    5602
        .word    32522
        .word    4011
        .word    -4011
        .word    32522
        .word    20160
        .word    25833
        .word    -25833
        .word    20160
        .word    28511
        .word    16151
        .word    -16151
        .word    28511
        .word    8740
        .word    31581
        .word    -31581
        .word    8740
        .word    31114
        .word    10279
        .word    -10279
        .word    31114
        .word    14733
        .word    29269
        .word    -29269
        .word    14733
        .word    24812
        .word    21403
        .word    -21403
        .word    24812
        .word    2411
        .word    32679
        .word    -32679
        .word    2411
        .word    32679
        .word    2411
        .word    -2411
        .word    32679
        .word    21403
        .word    24812
        .word    -24812
        .word    21403
        .word    29269
        .word    14733
        .word    -14733
        .word    29269
        .word    10279
        .word    31114
        .word    -31114
        .word    10279
        .word    31581
        .word    8740
        .word    -8740
        .word    31581
        .word    16151
        .word    28511
        .word    -28511
        .word    16151
        .word    25833
        .word    20160
        .word    -20160
        .word    25833
        .word    4011
        .word    32522
        .word    -32522
        .word    4011
        .word    32286
        .word    5602
        .word    -5602
        .word    32286
        .word    18868
        .word    26791
        .word    -26791
        .word    18868
        .word    27684
        .word    17531
        .word    -17531
        .word    27684
        .word    7180
        .word    31972
        .word    -31972
        .word    7180
        .word    30572
        .word    11793
        .word    -11793
        .word    30572
        .word    13279
        .word    29957
        .word    -29957
        .word    13279
        .word    23732
        .word    22595
        .word    -22595
        .word    23732
        .word    804
        .word    32758
        .word    -32758
        .word    804
        .word    32766
        .word    402
        .word    -402
        .word    32766
        .word    22884
        .word    23453
        .word    -23453
        .word    22884
        .word    30118
        .word    12910
        .word    -12910
        .word    30118
        .word    12167
        .word    30425
        .word    -30425
        .word    12167
        .word    32058
        .word    6787
        .word    -6787
        .word    32058
        .word    17869
        .word    27467
        .word    -27467
        .word    17869
        .word    27020
        .word    18538
        .word    -18538
        .word    27020
        .word    5998
        .word    32214
        .word    -32214
        .word    5998
        .word    32568
        .word    3612
        .word    -3612
        .word    32568
        .word    20475
        .word    25583
        .word    -25583
        .word    20475
        .word    28707
        .word    15800
        .word    -15800
        .word    28707
        .word    9127
        .word    31471
        .word    -31471
        .word    9127
        .word    31238
        .word    9896
        .word    -9896
        .word    31238
        .word    15091
        .word    29086
        .word    -29086
        .word    15091
        .word    25073
        .word    21097
        .word    -21097
        .word    25073
        .word    2811
        .word    32647
        .word    -32647
        .word    2811
        .word    32706
        .word    2009
        .word    -2009
        .word    32706
        .word    21706
        .word    24548
        .word    -24548
        .word    21706
        .word    29448
        .word    14373
        .word    -14373
        .word    29448
        .word    10660
        .word    30986
        .word    -30986
        .word    10660
        .word    31686
        .word    8351
        .word    -8351
        .word    31686
        .word    16500
        .word    28311
        .word    -28311
        .word    16500
        .word    26078
        .word    19841
        .word    -19841
        .word    26078
        .word    4410
        .word    32470
        .word    -32470
        .word    4410
        .word    32352
        .word    5205
        .word    -5205
        .word    32352
        .word    19195
        .word    26557
        .word    -26557
        .word    19195
        .word    27897
        .word    17190
        .word    -17190
        .word    27897
        .word    7571
        .word    31881
        .word    -31881
        .word    7571
        .word    30715
        .word    11417
        .word    -11417
        .word    30715
        .word    13646
        .word    29792
        .word    -29792
        .word    13646
        .word    24008
        .word    22302
        .word    -22302
        .word    24008
        .word    1206
        .word    32746
        .word    -32746
        .word    1206
        .word    32746
        .word    1206
        .word    -1206
        .word    32746
        .word    22302
        .word    24008
        .word    -24008
        .word    22302
        .word    29792
        .word    13646
        .word    -13646
        .word    29792
        .word    11417
        .word    30715
        .word    -30715
        .word    11417
        .word    31881
        .word    7571
        .word    -7571
        .word    31881
        .word    17190
        .word    27897
        .word    -27897
        .word    17190
        .word    26557
        .word    19195
        .word    -19195
        .word    26557
        .word    5205
        .word    32352
        .word    -32352
        .word    5205
        .word    32470
        .word    4410
        .word    -4410
        .word    32470
        .word    19841
        .word    26078
        .word    -26078
        .word    19841
        .word    28311
        .word    16500
        .word    -16500
        .word    28311
        .word    8351
        .word    31686
        .word    -31686
        .word    8351
        .word    30986
        .word    10660
        .word    -10660
        .word    30986
        .word    14373
        .word    29448
        .word    -29448
        .word    14373
        .word    24548
        .word    21706
        .word    -21706
        .word    24548
        .word    2009
        .word    32706
        .word    -32706
        .word    2009
        .word    32647
        .word    2811
        .word    -2811
        .word    32647
        .word    21097
        .word    25073
        .word    -25073
        .word    21097
        .word    29086
        .word    15091
        .word    -15091
        .word    29086
        .word    9896
        .word    31238
        .word    -31238
        .word    9896
        .word    31471
        .word    9127
        .word    -9127
        .word    31471
        .word    15800
        .word    28707
        .word    -28707
        .word    15800
        .word    25583
        .word    20475
        .word    -20475
        .word    25583
        .word    3612
        .word    32568
        .word    -32568
        .word    3612
        .word    32214
        .word    5998
        .word    -5998
        .word    32214
        .word    18538
        .word    27020
        .word    -27020
        .word    18538
        .word    27467
        .word    17869
        .word    -17869
        .word    27467
        .word    6787
        .word    32058
        .word    -32058
        .word    6787
        .word    30425
        .word    12167
        .word    -12167
        .word    30425
        .word    12910
        .word    30118
        .word    -30118
        .word    12910
        .word    23453
        .word    22884
        .word    -22884
        .word    23453
        .word    402
        .word    32766
        .word    -32766
        .word    402
        .word    32767
        .word    201
        .word    -201
        .word    32767
        .word    23028
        .word    23312
        .word    -23312
        .word    23028
        .word    30196
        .word    12725
        .word    -12725
        .word    30196
        .word    12354
        .word    30350
        .word    -30350
        .word    12354
        .word    32099
        .word    6590
        .word    -6590
        .word    32099
        .word    18037
        .word    27357
        .word    -27357
        .word    18037
        .word    27133
        .word    18372
        .word    -18372
        .word    27133
        .word    6195
        .word    32177
        .word    -32177
        .word    6195
        .word    32590
        .word    3412
        .word    -3412
        .word    32590
        .word    20632
        .word    25457
        .word    -25457
        .word    20632
        .word    28803
        .word    15624
        .word    -15624
        .word    28803
        .word    9319
        .word    31415
        .word    -31415
        .word    9319
        .word    31298
        .word    9704
        .word    -9704
        .word    31298
        .word    15269
        .word    28993
        .word    -28993
        .word    15269
        .word    25202
        .word    20943
        .word    -20943
        .word    25202
        .word    3012
        .word    32629
        .word    -32629
        .word    3012
        .word    32718
        .word    1809
        .word    -1809
        .word    32718
        .word    21856
        .word    24414
        .word    -24414
        .word    21856
        .word    29535
        .word    14192
        .word    -14192
        .word    29535
        .word    10850
        .word    30920
        .word    -30920
        .word    10850
        .word    31737
        .word    8157
        .word    -8157
        .word    31737
        .word    16673
        .word    28209
        .word    -28209
        .word    16673
        .word    26199
        .word    19681
        .word    -19681
        .word    26199
        .word    4609
        .word    32442
        .word    -32442
        .word    4609
        .word    32383
        .word    5007
        .word    -5007
        .word    32383
        .word    19358
        .word    26439
        .word    -26439
        .word    19358
        .word    28002
        .word    17018
        .word    -17018
        .word    28002
        .word    7767
        .word    31834
        .word    -31834
        .word    7767
        .word    30784
        .word    11228
        .word    -11228
        .word    30784
        .word    13828
        .word    29707
        .word    -29707
        .word    13828
        .word    24144
        .word    22154
        .word    -22154
        .word    24144
        .word    1407
        .word    32738
        .word    -32738
        .word    1407
        .word    32753
        .word    1005
        .word    -1005
        .word    32753
        .word    22449
        .word    23870
        .word    -23870
        .word    22449
        .word    29875
        .word    13463
        .word    -13463
        .word    29875
        .word    11605
        .word    30644
        .word    -30644
        .word    11605
        .word    31927
        .word    7376
        .word    -7376
        .word    31927
        .word    17361
        .word    27791
        .word    -27791
        .word    17361
        .word    26674
        .word    19032
        .word    -19032
        .word    26674
        .word    5404
        .word    32319
        .word    -32319
        .word    5404
        .word    32496
        .word    4211
        .word    -4211
        .word    32496
        .word    20001
        .word    25956
        .word    -25956
        .word    20001
        .word    28411
        .word    16326
        .word    -16326
        .word    28411
        .word    8546
        .word    31634
        .word    -31634
        .word    8546
        .word    31050
        .word    10469
        .word    -10469
        .word    31050
        .word    14553
        .word    29359
        .word    -29359
        .word    14553
        .word    24680
        .word    21555
        .word    -21555
        .word    24680
        .word    2210
        .word    32693
        .word    -32693
        .word    2210
        .word    32664
        .word    2611
        .word    -2611
        .word    32664
        .word    21251
        .word    24943
        .word    -24943
        .word    21251
        .word    29178
        .word    14912
        .word    -14912
        .word    29178
        .word    10088
        .word    31177
        .word    -31177
        .word    10088
        .word    31527
        .word    8933
        .word    -8933
        .word    31527
        .word    15976
        .word    28610
        .word    -28610
        .word    15976
        .word    25708
        .word    20318
        .word    -20318
        .word    25708
        .word    3812
        .word    32546
        .word    -32546
        .word    3812
        .word    32251
        .word    5800
        .word    -5800
        .word    32251
        .word    18703
        .word    26906
        .word    -26906
        .word    18703
        .word    27576
        .word    17700
        .word    -17700
        .word    27576
        .word    6983
        .word    32015
        .word    -32015
        .word    6983
        .word    30499
        .word    11980
        .word    -11980
        .word    30499
        .word    13095
        .word    30038
        .word    -30038
        .word    13095
        .word    23593
        .word    22740
        .word    -22740
        .word    23593
        .word    603
        .word    32762
        .word    -32762
        .word    603
        .word    32762
        .word    603
        .word    -603
        .word    32762
        .word    22740
        .word    23593
        .word    -23593
        .word    22740
        .word    30038
        .word    13095
        .word    -13095
        .word    30038
        .word    11980
        .word    30499
        .word    -30499
        .word    11980
        .word    32015
        .word    6983
        .word    -6983
        .word    32015
        .word    17700
        .word    27576
        .word    -27576
        .word    17700
        .word    26906
        .word    18703
        .word    -18703
        .word    26906
        .word    5800
        .word    32251
        .word    -32251
        .word    5800
        .word    32546
        .word    3812
        .word    -3812
        .word    32546
        .word    20318
        .word    25708
        .word    -25708
        .word    20318
        .word    28610
        .word    15976
        .word    -15976
        .word    28610
        .word    8933
        .word    31527
        .word    -31527
        .word    8933
        .word    31177
        .word    10088
        .word    -10088
        .word    31177
        .word    14912
        .word    29178
        .word    -29178
        .word    14912
        .word    24943
        .word    21251
        .word    -21251
        .word    24943
        .word    2611
        .word    32664
        .word    -32664
        .word    2611
        .word    32693
        .word    2210
        .word    -2210
        .word    32693
        .word    21555
        .word    24680
        .word    -24680
        .word    21555
        .word    29359
        .word    14553
        .word    -14553
        .word    29359
        .word    10469
        .word    31050
        .word    -31050
        .word    10469
        .word    31634
        .word    8546
        .word    -8546
        .word    31634
        .word    16326
        .word    28411
        .word    -28411
        .word    16326
        .word    25956
        .word    20001
        .word    -20001
        .word    25956
        .word    4211
        .word    32496
        .word    -32496
        .word    4211
        .word    32319
        .word    5404
        .word    -5404
        .word    32319
        .word    19032
        .word    26674
        .word    -26674
        .word    19032
        .word    27791
        .word    17361
        .word    -17361
        .word    27791
        .word    7376
        .word    31927
        .word    -31927
        .word    7376
        .word    30644
        .word    11605
        .word    -11605
        .word    30644
        .word    13463
        .word    29875
        .word    -29875
        .word    13463
        .word    23870
        .word    22449
        .word    -22449
        .word    23870
        .word    1005
        .word    32753
        .word    -32753
        .word    1005
        .word    32738
        .word    1407
        .word    -1407
        .word    32738
        .word    22154
        .word    24144
        .word    -24144
        .word    22154
        .word    29707
        .word    13828
        .word    -13828
        .word    29707
        .word    11228
        .word    30784
        .word    -30784
        .word    11228
        .word    31834
        .word    7767
        .word    -7767
        .word    31834
        .word    17018
        .word    28002
        .word    -28002
        .word    17018
        .word    26439
        .word    19358
        .word    -19358
        .word    26439
        .word    5007
        .word    32383
        .word    -32383
        .word    5007
        .word    32442
        .word    4609
        .word    -4609
        .word    32442
        .word    19681
        .word    26199
        .word    -26199
        .word    19681
        .word    28209
        .word    16673
        .word    -16673
        .word    28209
        .word    8157
        .word    31737
        .word    -31737
        .word    8157
        .word    30920
        .word    10850
        .word    -10850
        .word    30920
        .word    14192
        .word    29535
        .word    -29535
        .word    14192
        .word    24414
        .word    21856
        .word    -21856
        .word    24414
        .word    1809
        .word    32718
        .word    -32718
        .word    1809
        .word    32629
        .word    3012
        .word    -3012
        .word    32629
        .word    20943
        .word    25202
        .word    -25202
        .word    20943
        .word    28993
        .word    15269
        .word    -15269
        .word    28993
        .word    9704
        .word    31298
        .word    -31298
        .word    9704
        .word    31415
        .word    9319
        .word    -9319
        .word    31415
        .word    15624
        .word    28803
        .word    -28803
        .word    15624
        .word    25457
        .word    20632
        .word    -20632
        .word    25457
        .word    3412
        .word    32590
        .word    -32590
        .word    3412
        .word    32177
        .word    6195
        .word    -6195
        .word    32177
        .word    18372
        .word    27133
        .word    -27133
        .word    18372
        .word    27357
        .word    18037
        .word    -18037
        .word    27357
        .word    6590
        .word    32099
        .word    -32099
        .word    6590
        .word    30350
        .word    12354
        .word    -12354
        .word    30350
        .word    12725
        .word    30196
        .word    -30196
        .word    12725
        .word    23312
        .word    23028
        .word    -23028
        .word    23312
        .word    201
        .word    32767
        .word    -32767
        .word    201
twiddle32.asm/  1362765892  0     0     0       80237     `
;/*
; * Copyright (C) 2013 Texas Instruments Incorporated - http://www.ti.com/ 
; * 
; * 
; *  Redistribution and use in source and binary forms, with or without 
; *  modification, are permitted provided that the following conditions 
; *  are met:
; *
; *    Redistributions of source code must retain the above copyright 
; *    notice, this list of conditions and the following disclaimer.
; *
; *    Redistributions in binary form must reproduce the above copyright
; *    notice, this list of conditions and the following disclaimer in the 
; *    documentation and/or other materials provided with the   
; *    distribution.
; *
; *    Neither the name of Texas Instruments Incorporated nor the names of
; *    its contributors may be used to endorse or promote products derived
; *    from this software without specific prior written permission.
; *
; *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
; *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
; *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
; *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
; *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
; *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
; *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
; *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
; *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
; *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
; *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
; *
;*/

;***********************************************************
; Version 3.00.00                                           
;***********************************************************

	.def twiddle32

	.sect ".const:twiddle32" 

        .align  ; force the twiddle32 label to start on a longword boundary

twiddle32:

 .long 0x7fffffff  ; [0]; 1.000000
 .long 0x00000000  ; [0]; 0.000000
 .long 0x00000000  ; [512]; 0.000000
 .long 0x7fffffff  ; [512]; 1.000000
 .long 0x5a827999  ; [256]; 0.707107
 .long 0x5a827999  ; [256]; 0.707107
 .long 0xa57d8668  ; [768]; -0.707107
 .long 0x5a827999  ; [768]; 0.707107
 .long 0x7641af3c  ; [128]; 0.923880
 .long 0x30fbc54d  ; [128]; 0.382683
 .long 0xcf043ab4  ; [640]; -0.382683
 .long 0x7641af3c  ; [640]; 0.923880
 .long 0x30fbc54d  ; [384]; 0.382683
 .long 0x7641af3c  ; [384]; 0.923880
 .long 0x89be50c5  ; [896]; -0.923880
 .long 0x30fbc54d  ; [896]; 0.382683
 .long 0x7d8a5f3f  ; [64]; 0.980785
 .long 0x18f8b83c  ; [64]; 0.195090
 .long 0xe70747c5  ; [576]; -0.195090
 .long 0x7d8a5f3f  ; [576]; 0.980785
 .long 0x471cece6  ; [320]; 0.555570
 .long 0x6a6d98a3  ; [320]; 0.831470
 .long 0x9592675e  ; [832]; -0.831470
 .long 0x471cece6  ; [832]; 0.555570
 .long 0x6a6d98a3  ; [192]; 0.831470
 .long 0x471cece6  ; [192]; 0.555570
 .long 0xb8e3131b  ; [704]; -0.555570
 .long 0x6a6d98a3  ; [704]; 0.831470
 .long 0x18f8b83c  ; [448]; 0.195090
 .long 0x7d8a5f3f  ; [448]; 0.980785
 .long 0x8275a0c2  ; [960]; -0.980785
 .long 0x18f8b83c  ; [960]; 0.195090
 .long 0x7f62368e  ; [32]; 0.995185
 .long 0x0c8bd35e  ; [32]; 0.098017
 .long 0xf3742ca3  ; [544]; -0.098017
 .long 0x7f62368e  ; [544]; 0.995185
 .long 0x5133cc94  ; [288]; 0.634393
 .long 0x62f201ac  ; [288]; 0.773010
 .long 0x9d0dfe55  ; [800]; -0.773010
 .long 0x5133cc94  ; [800]; 0.634393
 .long 0x70e2cbc5  ; [160]; 0.881921
 .long 0x3c56ba70  ; [160]; 0.471397
 .long 0xc3a94591  ; [672]; -0.471397
 .long 0x70e2cbc5  ; [672]; 0.881921
 .long 0x25280c5d  ; [416]; 0.290285
 .long 0x7a7d055a  ; [416]; 0.956940
 .long 0x8582faa7  ; [928]; -0.956940
 .long 0x25280c5d  ; [928]; 0.290285
 .long 0x7a7d055a  ; [96]; 0.956940
 .long 0x25280c5d  ; [96]; 0.290285
 .long 0xdad7f3a4  ; [608]; -0.290285
 .long 0x7a7d055a  ; [608]; 0.956940
 .long 0x3c56ba70  ; [352]; 0.471397
 .long 0x70e2cbc5  ; [352]; 0.881921
 .long 0x8f1d343c  ; [864]; -0.881921
 .long 0x3c56ba70  ; [864]; 0.471397
 .long 0x62f201ac  ; [224]; 0.773010
 .long 0x5133cc94  ; [224]; 0.634393
 .long 0xaecc336d  ; [736]; -0.634393
 .long 0x62f201ac  ; [736]; 0.773010
 .long 0x0c8bd35e  ; [480]; 0.098017
 .long 0x7f62368e  ; [480]; 0.995185
 .long 0x809dc973  ; [992]; -0.995185
 .long 0x0c8bd35e  ; [992]; 0.098017
 .long 0x7fd8878d  ; [16]; 0.998795
 .long 0x0647d97c  ; [16]; 0.049068
 .long 0xf9b82685  ; [528]; -0.049068
 .long 0x7fd8878d  ; [528]; 0.998795
 .long 0x55f5a4d2  ; [272]; 0.671559
 .long 0x5ed77c89  ; [272]; 0.740951
 .long 0xa1288378  ; [784]; -0.740951
 .long 0x55f5a4d2  ; [784]; 0.671559
 .long 0x73b5ebd0  ; [144]; 0.903989
 .long 0x36ba2013  ; [144]; 0.427555
 .long 0xc945dfee  ; [656]; -0.427555
 .long 0x73b5ebd0  ; [656]; 0.903989
 .long 0x2b1f34eb  ; [400]; 0.336890
 .long 0x78848413  ; [400]; 0.941544
 .long 0x877b7bee  ; [912]; -0.941544
 .long 0x2b1f34eb  ; [912]; 0.336890
 .long 0x7c29fbed  ; [80]; 0.970031
 .long 0x1f19f97b  ; [80]; 0.242980
 .long 0xe0e60686  ; [592]; -0.242980
 .long 0x7c29fbed  ; [592]; 0.970031
 .long 0x41ce1e64  ; [336]; 0.514103
 .long 0x6dca0d14  ; [336]; 0.857729
 .long 0x9235f2ed  ; [848]; -0.857729
 .long 0x41ce1e64  ; [848]; 0.514103
 .long 0x66cf811f  ; [208]; 0.803208
 .long 0x4c3fdff3  ; [208]; 0.595699
 .long 0xb3c0200e  ; [720]; -0.595699
 .long 0x66cf811f  ; [720]; 0.803208
 .long 0x12c8106e  ; [464]; 0.146730
 .long 0x7e9d55fb  ; [464]; 0.989177
 .long 0x8162aa06  ; [976]; -0.989177
 .long 0x12c8106e  ; [976]; 0.146730
 .long 0x7e9d55fb  ; [48]; 0.989177
 .long 0x12c8106e  ; [48]; 0.146730
 .long 0xed37ef93  ; [560]; -0.146730
 .long 0x7e9d55fb  ; [560]; 0.989177
 .long 0x4c3fdff3  ; [304]; 0.595699
 .long 0x66cf811f  ; [304]; 0.803208
 .long 0x99307ee2  ; [816]; -0.803208
 .long 0x4c3fdff3  ; [816]; 0.595699
 .long 0x6dca0d14  ; [176]; 0.857729
 .long 0x41ce1e64  ; [176]; 0.514103
 .long 0xbe31e19d  ; [688]; -0.514103
 .long 0x6dca0d14  ; [688]; 0.857729
 .long 0x1f19f97b  ; [432]; 0.242980
 .long 0x7c29fbed  ; [432]; 0.970031
 .long 0x83d60414  ; [944]; -0.970031
 .long 0x1f19f97b  ; [944]; 0.242980
 .long 0x78848413  ; [112]; 0.941544
 .long 0x2b1f34eb  ; [112]; 0.336890
 .long 0xd4e0cb16  ; [624]; -0.336890
 .long 0x78848413  ; [624]; 0.941544
 .long 0x36ba2013  ; [368]; 0.427555
 .long 0x73b5ebd0  ; [368]; 0.903989
 .long 0x8c4a1431  ; [880]; -0.903989
 .long 0x36ba2013  ; [880]; 0.427555
 .long 0x5ed77c89  ; [240]; 0.740951
 .long 0x55f5a4d2  ; [240]; 0.671559
 .long 0xaa0a5b2f  ; [752]; -0.671559
 .long 0x5ed77c89  ; [752]; 0.740951
 .long 0x0647d97c  ; [496]; 0.049068
 .long 0x7fd8878d  ; [496]; 0.998795
 .long 0x80277874  ; [1008]; -0.998795
 .long 0x0647d97c  ; [1008]; 0.049068
 .long 0x7ff62181  ; [8]; 0.999699
 .long 0x03242abf  ; [8]; 0.024541
 .long 0xfcdbd542  ; [520]; -0.024541
 .long 0x7ff62181  ; [520]; 0.999699
 .long 0x5842dd54  ; [264]; 0.689541
 .long 0x5cb420df  ; [264]; 0.724247
 .long 0xa34bdf22  ; [776]; -0.724247
 .long 0x5842dd54  ; [776]; 0.689541
 .long 0x7504d344  ; [136]; 0.914210
 .long 0x33def287  ; [136]; 0.405241
 .long 0xcc210d7a  ; [648]; -0.405241
 .long 0x7504d344  ; [648]; 0.914210
 .long 0x2e110a62  ; [392]; 0.359895
 .long 0x776c4eda  ; [392]; 0.932993
 .long 0x8893b127  ; [904]; -0.932993
 .long 0x2e110a62  ; [904]; 0.359895
 .long 0x7ce3ceb1  ; [72]; 0.975702
 .long 0x1c0b826a  ; [72]; 0.219101
 .long 0xe3f47d97  ; [584]; -0.219101
 .long 0x7ce3ceb1  ; [584]; 0.975702
 .long 0x447acd50  ; [328]; 0.534998
 .long 0x6c24295f  ; [328]; 0.844854
 .long 0x93dbd6a2  ; [840]; -0.844854
 .long 0x447acd50  ; [840]; 0.534998
 .long 0x68a69e80  ; [200]; 0.817585
 .long 0x49b41533  ; [200]; 0.575808
 .long 0xb64beace  ; [712]; -0.575808
 .long 0x68a69e80  ; [712]; 0.817585
 .long 0x15e21444  ; [456]; 0.170962
 .long 0x7e1d93e9  ; [456]; 0.985278
 .long 0x81e26c18  ; [968]; -0.985278
 .long 0x15e21444  ; [968]; 0.170962
 .long 0x7f0991c3  ; [40]; 0.992480
 .long 0x0fab272b  ; [40]; 0.122411
 .long 0xf054d8d6  ; [552]; -0.122411
 .long 0x7f0991c3  ; [552]; 0.992480
 .long 0x4ebfe8a4  ; [296]; 0.615232
 .long 0x64e88925  ; [296]; 0.788346
 .long 0x9b1776dc  ; [808]; -0.788346
 .long 0x4ebfe8a4  ; [808]; 0.615232
 .long 0x6f5f02b1  ; [168]; 0.870087
 .long 0x3f1749b7  ; [168]; 0.492898
 .long 0xc0e8b64a  ; [680]; -0.492898
 .long 0x6f5f02b1  ; [680]; 0.870087
 .long 0x2223a4c5  ; [424]; 0.266713
 .long 0x7b5d039d  ; [424]; 0.963776
 .long 0x84a2fc64  ; [936]; -0.963776
 .long 0x2223a4c5  ; [936]; 0.266713
 .long 0x798a23b0  ; [104]; 0.949528
 .long 0x2826b928  ; [104]; 0.313682
 .long 0xd7d946d9  ; [616]; -0.313682
 .long 0x798a23b0  ; [616]; 0.949528
 .long 0x398cdd32  ; [360]; 0.449611
 .long 0x72552c84  ; [360]; 0.893224
 .long 0x8daad37d  ; [872]; -0.893224
 .long 0x398cdd32  ; [872]; 0.449611
 .long 0x60ec382f  ; [232]; 0.757209
 .long 0x539b2aef  ; [232]; 0.653173
 .long 0xac64d512  ; [744]; -0.653173
 .long 0x60ec382f  ; [744]; 0.757209
 .long 0x096a9049  ; [488]; 0.073565
 .long 0x7fa736b3  ; [488]; 0.997290
 .long 0x8058c94e  ; [1000]; -0.997290
 .long 0x096a9049  ; [1000]; 0.073565
 .long 0x7fa736b3  ; [24]; 0.997290
 .long 0x096a9049  ; [24]; 0.073565
 .long 0xf6956fb8  ; [536]; -0.073565
 .long 0x7fa736b3  ; [536]; 0.997290
 .long 0x539b2aef  ; [280]; 0.653173
 .long 0x60ec382f  ; [280]; 0.757209
 .long 0x9f13c7d2  ; [792]; -0.757209
 .long 0x539b2aef  ; [792]; 0.653173
 .long 0x72552c84  ; [152]; 0.893224
 .long 0x398cdd32  ; [152]; 0.449611
 .long 0xc67322cf  ; [664]; -0.449611
 .long 0x72552c84  ; [664]; 0.893224
 .long 0x2826b928  ; [408]; 0.313682
 .long 0x798a23b0  ; [408]; 0.949528
 .long 0x8675dc51  ; [920]; -0.949528
 .long 0x2826b928  ; [920]; 0.313682
 .long 0x7b5d039d  ; [88]; 0.963776
 .long 0x2223a4c5  ; [88]; 0.266713
 .long 0xdddc5b3c  ; [600]; -0.266713
 .long 0x7b5d039d  ; [600]; 0.963776
 .long 0x3f1749b7  ; [344]; 0.492898
 .long 0x6f5f02b1  ; [344]; 0.870087
 .long 0x90a0fd50  ; [856]; -0.870087
 .long 0x3f1749b7  ; [856]; 0.492898
 .long 0x64e88925  ; [216]; 0.788346
 .long 0x4ebfe8a4  ; [216]; 0.615232
 .long 0xb140175d  ; [728]; -0.615232
 .long 0x64e88925  ; [728]; 0.788346
 .long 0x0fab272b  ; [472]; 0.122411
 .long 0x7f0991c3  ; [472]; 0.992480
 .long 0x80f66e3e  ; [984]; -0.992480
 .long 0x0fab272b  ; [984]; 0.122411
 .long 0x7e1d93e9  ; [56]; 0.985278
 .long 0x15e21444  ; [56]; 0.170962
 .long 0xea1debbd  ; [568]; -0.170962
 .long 0x7e1d93e9  ; [568]; 0.985278
 .long 0x49b41533  ; [312]; 0.575808
 .long 0x68a69e80  ; [312]; 0.817585
 .long 0x97596181  ; [824]; -0.817585
 .long 0x49b41533  ; [824]; 0.575808
 .long 0x6c24295f  ; [184]; 0.844854
 .long 0x447acd50  ; [184]; 0.534998
 .long 0xbb8532b1  ; [696]; -0.534998
 .long 0x6c24295f  ; [696]; 0.844854
 .long 0x1c0b826a  ; [440]; 0.219101
 .long 0x7ce3ceb1  ; [440]; 0.975702
 .long 0x831c3150  ; [952]; -0.975702
 .long 0x1c0b826a  ; [952]; 0.219101
 .long 0x776c4eda  ; [120]; 0.932993
 .long 0x2e110a62  ; [120]; 0.359895
 .long 0xd1eef59f  ; [632]; -0.359895
 .long 0x776c4eda  ; [632]; 0.932993
 .long 0x33def287  ; [376]; 0.405241
 .long 0x7504d344  ; [376]; 0.914210
 .long 0x8afb2cbd  ; [888]; -0.914210
 .long 0x33def287  ; [888]; 0.405241
 .long 0x5cb420df  ; [248]; 0.724247
 .long 0x5842dd54  ; [248]; 0.689541
 .long 0xa7bd22ad  ; [760]; -0.689541
 .long 0x5cb420df  ; [760]; 0.724247
 .long 0x03242abf  ; [504]; 0.024541
 .long 0x7ff62181  ; [504]; 0.999699
 .long 0x8009de80  ; [1016]; -0.999699
 .long 0x03242abf  ; [1016]; 0.024541
 .long 0x7ffd8859  ; [4]; 0.999925
 .long 0x01921d20  ; [4]; 0.012272
 .long 0xfe6de2e1  ; [516]; -0.012272
 .long 0x7ffd8859  ; [516]; 0.999925
 .long 0x59646497  ; [260]; 0.698376
 .long 0x5b9d1153  ; [260]; 0.715731
 .long 0xa462eeae  ; [772]; -0.715731
 .long 0x59646497  ; [772]; 0.698376
 .long 0x75a585ce  ; [132]; 0.919114
 .long 0x326e54c7  ; [132]; 0.393992
 .long 0xcd91ab3a  ; [644]; -0.393992
 .long 0x75a585ce  ; [644]; 0.919114
 .long 0x2f875262  ; [388]; 0.371317
 .long 0x76d94988  ; [388]; 0.928506
 .long 0x8926b679  ; [900]; -0.928506
 .long 0x2f875262  ; [900]; 0.371317
 .long 0x7d3980eb  ; [68]; 0.978317
 .long 0x1a82a025  ; [68]; 0.207111
 .long 0xe57d5fdc  ; [580]; -0.207111
 .long 0x7d3980eb  ; [580]; 0.978317
 .long 0x45cd358f  ; [324]; 0.545325
 .long 0x6b4af278  ; [324]; 0.838225
 .long 0x94b50d89  ; [836]; -0.838225
 .long 0x45cd358f  ; [836]; 0.545325
 .long 0x698c246b  ; [196]; 0.824589
 .long 0x4869e664  ; [196]; 0.565732
 .long 0xb796199d  ; [708]; -0.565732
 .long 0x698c246b  ; [708]; 0.824589
 .long 0x176dd9de  ; [452]; 0.183040
 .long 0x7dd6668e  ; [452]; 0.983105
 .long 0x82299973  ; [964]; -0.983105
 .long 0x176dd9de  ; [964]; 0.183040
 .long 0x7f3857f5  ; [36]; 0.993907
 .long 0x0e1bc2e4  ; [36]; 0.110222
 .long 0xf1e43d1d  ; [548]; -0.110222
 .long 0x7f3857f5  ; [548]; 0.993907
 .long 0x4ffb654c  ; [292]; 0.624859
 .long 0x63ef328f  ; [292]; 0.780737
 .long 0x9c10cd72  ; [804]; -0.780737
 .long 0x4ffb654c  ; [804]; 0.624859
 .long 0x70231099  ; [164]; 0.876070
 .long 0x3db832a5  ; [164]; 0.482184
 .long 0xc247cd5c  ; [676]; -0.482184
 .long 0x70231099  ; [676]; 0.876070
 .long 0x23a6887e  ; [420]; 0.278520
 .long 0x7aef6323  ; [420]; 0.960431
 .long 0x85109cde  ; [932]; -0.960431
 .long 0x23a6887e  ; [932]; 0.278520
 .long 0x7a05eeac  ; [100]; 0.953306
 .long 0x26a82185  ; [100]; 0.302006
 .long 0xd957de7c  ; [612]; -0.302006
 .long 0x7a05eeac  ; [612]; 0.953306
 .long 0x3af2eeb7  ; [356]; 0.460539
 .long 0x719e2cd1  ; [356]; 0.887640
 .long 0x8e61d330  ; [868]; -0.887640
 .long 0x3af2eeb7  ; [868]; 0.460539
 .long 0x61f1003e  ; [228]; 0.765167
 .long 0x5269126e  ; [228]; 0.643832
 .long 0xad96ed93  ; [740]; -0.643832
 .long 0x61f1003e  ; [740]; 0.765167
 .long 0x0afb6805  ; [484]; 0.085797
 .long 0x7f872bf2  ; [484]; 0.996313
 .long 0x8078d40f  ; [996]; -0.996313
 .long 0x0afb6805  ; [996]; 0.085797
 .long 0x7fc25595  ; [20]; 0.998118
 .long 0x07d95b9e  ; [20]; 0.061321
 .long 0xf826a463  ; [532]; -0.061321
 .long 0x7fc25595  ; [532]; 0.998118
 .long 0x54ca0a4a  ; [276]; 0.662416
 .long 0x5fe3b38d  ; [276]; 0.749136
 .long 0xa01c4c74  ; [788]; -0.749136
 .long 0x54ca0a4a  ; [788]; 0.662416
 .long 0x7307c3cf  ; [148]; 0.898674
 .long 0x382493b0  ; [148]; 0.438616
 .long 0xc7db6c51  ; [660]; -0.438616
 .long 0x7307c3cf  ; [660]; 0.898674
 .long 0x29a3c485  ; [404]; 0.325310
 .long 0x7909a92c  ; [404]; 0.945607
 .long 0x86f656d5  ; [916]; -0.945607
 .long 0x29a3c485  ; [916]; 0.325310
 .long 0x7bc5e28f  ; [84]; 0.966976
 .long 0x209f701c  ; [84]; 0.254866
 .long 0xdf608fe5  ; [596]; -0.254866
 .long 0x7bc5e28f  ; [596]; 0.966976
 .long 0x4073f21d  ; [340]; 0.503538
 .long 0x6e96a99c  ; [340]; 0.863973
 .long 0x91695665  ; [852]; -0.863973
 .long 0x4073f21d  ; [852]; 0.503538
 .long 0x65ddfbd2  ; [212]; 0.795837
 .long 0x4d8162c3  ; [212]; 0.605511
 .long 0xb27e9d3e  ; [724]; -0.605511
 .long 0x65ddfbd2  ; [724]; 0.795837
 .long 0x1139f0cf  ; [468]; 0.134581
 .long 0x7ed5e5c5  ; [468]; 0.990903
 .long 0x812a1a3c  ; [980]; -0.990903
 .long 0x1139f0cf  ; [980]; 0.134581
 .long 0x7e5fe492  ; [52]; 0.987301
 .long 0x145576b1  ; [52]; 0.158858
 .long 0xebaa8950  ; [564]; -0.158858
 .long 0x7e5fe492  ; [564]; 0.987301
 .long 0x4afb6c97  ; [308]; 0.585798
 .long 0x67bd0fbc  ; [308]; 0.810457
 .long 0x9842f045  ; [820]; -0.810457
 .long 0x4afb6c97  ; [820]; 0.585798
 .long 0x6cf934fb  ; [180]; 0.851355
 .long 0x4325c135  ; [180]; 0.524590
 .long 0xbcda3ecc  ; [692]; -0.524590
 .long 0x6cf934fb  ; [692]; 0.851355
 .long 0x1d934fe5  ; [436]; 0.231058
 .long 0x7c894bdd  ; [436]; 0.972940
 .long 0x8376b424  ; [948]; -0.972940
 .long 0x1d934fe5  ; [948]; 0.231058
 .long 0x77fab988  ; [116]; 0.937339
 .long 0x2c98fbba  ; [116]; 0.348419
 .long 0xd3670447  ; [628]; -0.348419
 .long 0x77fab988  ; [628]; 0.937339
 .long 0x354d9056  ; [372]; 0.416430
 .long 0x745f9dd0  ; [372]; 0.909168
 .long 0x8ba06231  ; [884]; -0.909168
 .long 0x354d9056  ; [884]; 0.416430
 .long 0x5dc79d7b  ; [244]; 0.732654
 .long 0x571deef9  ; [244]; 0.680601
 .long 0xa8e21108  ; [756]; -0.680601
 .long 0x5dc79d7b  ; [756]; 0.732654
 .long 0x04b6195d  ; [500]; 0.036807
 .long 0x7fe9cbbf  ; [500]; 0.999322
 .long 0x80163442  ; [1012]; -0.999322
 .long 0x04b6195d  ; [1012]; 0.036807
 .long 0x7fe9cbbf  ; [12]; 0.999322
 .long 0x04b6195d  ; [12]; 0.036807
 .long 0xfb49e6a4  ; [524]; -0.036807
 .long 0x7fe9cbbf  ; [524]; 0.999322
 .long 0x571deef9  ; [268]; 0.680601
 .long 0x5dc79d7b  ; [268]; 0.732654
 .long 0xa2386286  ; [780]; -0.732654
 .long 0x571deef9  ; [780]; 0.680601
 .long 0x745f9dd0  ; [140]; 0.909168
 .long 0x354d9056  ; [140]; 0.416430
 .long 0xcab26fab  ; [652]; -0.416430
 .long 0x745f9dd0  ; [652]; 0.909168
 .long 0x2c98fbba  ; [396]; 0.348419
 .long 0x77fab988  ; [396]; 0.937339
 .long 0x88054679  ; [908]; -0.937339
 .long 0x2c98fbba  ; [908]; 0.348419
 .long 0x7c894bdd  ; [76]; 0.972940
 .long 0x1d934fe5  ; [76]; 0.231058
 .long 0xe26cb01c  ; [588]; -0.231058
 .long 0x7c894bdd  ; [588]; 0.972940
 .long 0x4325c135  ; [332]; 0.524590
 .long 0x6cf934fb  ; [332]; 0.851355
 .long 0x9306cb06  ; [844]; -0.851355
 .long 0x4325c135  ; [844]; 0.524590
 .long 0x67bd0fbc  ; [204]; 0.810457
 .long 0x4afb6c97  ; [204]; 0.585798
 .long 0xb504936a  ; [716]; -0.585798
 .long 0x67bd0fbc  ; [716]; 0.810457
 .long 0x145576b1  ; [460]; 0.158858
 .long 0x7e5fe492  ; [460]; 0.987301
 .long 0x81a01b6f  ; [972]; -0.987301
 .long 0x145576b1  ; [972]; 0.158858
 .long 0x7ed5e5c5  ; [44]; 0.990903
 .long 0x1139f0cf  ; [44]; 0.134581
 .long 0xeec60f32  ; [556]; -0.134581
 .long 0x7ed5e5c5  ; [556]; 0.990903
 .long 0x4d8162c3  ; [300]; 0.605511
 .long 0x65ddfbd2  ; [300]; 0.795837
 .long 0x9a22042f  ; [812]; -0.795837
 .long 0x4d8162c3  ; [812]; 0.605511
 .long 0x6e96a99c  ; [172]; 0.863973
 .long 0x4073f21d  ; [172]; 0.503538
 .long 0xbf8c0de4  ; [684]; -0.503538
 .long 0x6e96a99c  ; [684]; 0.863973
 .long 0x209f701c  ; [428]; 0.254866
 .long 0x7bc5e28f  ; [428]; 0.966976
 .long 0x843a1d72  ; [940]; -0.966976
 .long 0x209f701c  ; [940]; 0.254866
 .long 0x7909a92c  ; [108]; 0.945607
 .long 0x29a3c485  ; [108]; 0.325310
 .long 0xd65c3b7c  ; [620]; -0.325310
 .long 0x7909a92c  ; [620]; 0.945607
 .long 0x382493b0  ; [364]; 0.438616
 .long 0x7307c3cf  ; [364]; 0.898674
 .long 0x8cf83c32  ; [876]; -0.898674
 .long 0x382493b0  ; [876]; 0.438616
 .long 0x5fe3b38d  ; [236]; 0.749136
 .long 0x54ca0a4a  ; [236]; 0.662416
 .long 0xab35f5b7  ; [748]; -0.662416
 .long 0x5fe3b38d  ; [748]; 0.749136
 .long 0x07d95b9e  ; [492]; 0.061321
 .long 0x7fc25595  ; [492]; 0.998118
 .long 0x803daa6c  ; [1004]; -0.998118
 .long 0x07d95b9e  ; [1004]; 0.061321
 .long 0x7f872bf2  ; [28]; 0.996313
 .long 0x0afb6805  ; [28]; 0.085797
 .long 0xf50497fc  ; [540]; -0.085797
 .long 0x7f872bf2  ; [540]; 0.996313
 .long 0x5269126e  ; [284]; 0.643832
 .long 0x61f1003e  ; [284]; 0.765167
 .long 0x9e0effc3  ; [796]; -0.765167
 .long 0x5269126e  ; [796]; 0.643832
 .long 0x719e2cd1  ; [156]; 0.887640
 .long 0x3af2eeb7  ; [156]; 0.460539
 .long 0xc50d114a  ; [668]; -0.460539
 .long 0x719e2cd1  ; [668]; 0.887640
 .long 0x26a82185  ; [412]; 0.302006
 .long 0x7a05eeac  ; [412]; 0.953306
 .long 0x85fa1155  ; [924]; -0.953306
 .long 0x26a82185  ; [924]; 0.302006
 .long 0x7aef6323  ; [92]; 0.960431
 .long 0x23a6887e  ; [92]; 0.278520
 .long 0xdc597783  ; [604]; -0.278520
 .long 0x7aef6323  ; [604]; 0.960431
 .long 0x3db832a5  ; [348]; 0.482184
 .long 0x70231099  ; [348]; 0.876070
 .long 0x8fdcef68  ; [860]; -0.876070
 .long 0x3db832a5  ; [860]; 0.482184
 .long 0x63ef328f  ; [220]; 0.780737
 .long 0x4ffb654c  ; [220]; 0.624859
 .long 0xb0049ab5  ; [732]; -0.624859
 .long 0x63ef328f  ; [732]; 0.780737
 .long 0x0e1bc2e4  ; [476]; 0.110222
 .long 0x7f3857f5  ; [476]; 0.993907
 .long 0x80c7a80c  ; [988]; -0.993907
 .long 0x0e1bc2e4  ; [988]; 0.110222
 .long 0x7dd6668e  ; [60]; 0.983105
 .long 0x176dd9de  ; [60]; 0.183040
 .long 0xe8922623  ; [572]; -0.183040
 .long 0x7dd6668e  ; [572]; 0.983105
 .long 0x4869e664  ; [316]; 0.565732
 .long 0x698c246b  ; [316]; 0.824589
 .long 0x9673db96  ; [828]; -0.824589
 .long 0x4869e664  ; [828]; 0.565732
 .long 0x6b4af278  ; [188]; 0.838225
 .long 0x45cd358f  ; [188]; 0.545325
 .long 0xba32ca72  ; [700]; -0.545325
 .long 0x6b4af278  ; [700]; 0.838225
 .long 0x1a82a025  ; [444]; 0.207111
 .long 0x7d3980eb  ; [444]; 0.978317
 .long 0x82c67f16  ; [956]; -0.978317
 .long 0x1a82a025  ; [956]; 0.207111
 .long 0x76d94988  ; [124]; 0.928506
 .long 0x2f875262  ; [124]; 0.371317
 .long 0xd078ad9f  ; [636]; -0.371317
 .long 0x76d94988  ; [636]; 0.928506
 .long 0x326e54c7  ; [380]; 0.393992
 .long 0x75a585ce  ; [380]; 0.919114
 .long 0x8a5a7a33  ; [892]; -0.919114
 .long 0x326e54c7  ; [892]; 0.393992
 .long 0x5b9d1153  ; [252]; 0.715731
 .long 0x59646497  ; [252]; 0.698376
 .long 0xa69b9b6a  ; [764]; -0.698376
 .long 0x5b9d1153  ; [764]; 0.715731
 .long 0x01921d20  ; [508]; 0.012272
 .long 0x7ffd8859  ; [508]; 0.999925
 .long 0x800277a8  ; [1020]; -0.999925
 .long 0x01921d20  ; [1020]; 0.012272
 .long 0x7fff6215  ; [2]; 0.999981
 .long 0x00c90f88  ; [2]; 0.006136
 .long 0xff36f079  ; [514]; -0.006136
 .long 0x7fff6215  ; [514]; 0.999981
 .long 0x59f3de12  ; [258]; 0.702755
 .long 0x5b1035ce  ; [258]; 0.711432
 .long 0xa4efca33  ; [770]; -0.711432
 .long 0x59f3de12  ; [770]; 0.702755
 .long 0x75f42c0a  ; [130]; 0.921514
 .long 0x31b54a5d  ; [130]; 0.388345
 .long 0xce4ab5a4  ; [642]; -0.388345
 .long 0x75f42c0a  ; [642]; 0.921514
 .long 0x3041c760  ; [386]; 0.377007
 .long 0x768e0ea5  ; [386]; 0.926210
 .long 0x8971f15c  ; [898]; -0.926210
 .long 0x3041c760  ; [898]; 0.377007
 .long 0x7d628ac5  ; [66]; 0.979570
 .long 0x19bdcbf3  ; [66]; 0.201105
 .long 0xe642340e  ; [578]; -0.201105
 .long 0x7d628ac5  ; [578]; 0.979570
 .long 0x46756827  ; [322]; 0.550458
 .long 0x6adcc964  ; [322]; 0.834863
 .long 0x9523369d  ; [834]; -0.834863
 .long 0x46756827  ; [834]; 0.550458
 .long 0x69fd614a  ; [194]; 0.828045
 .long 0x47c3c22e  ; [194]; 0.560662
 .long 0xb83c3dd3  ; [706]; -0.560662
 .long 0x69fd614a  ; [706]; 0.828045
 .long 0x183366e8  ; [450]; 0.189069
 .long 0x7db0fdf7  ; [450]; 0.981964
 .long 0x824f020a  ; [962]; -0.981964
 .long 0x183366e8  ; [962]; 0.189069
 .long 0x7f4de450  ; [34]; 0.994565
 .long 0x0d53db92  ; [34]; 0.104122
 .long 0xf2ac246f  ; [546]; -0.104122
 .long 0x7f4de450  ; [546]; 0.994565
 .long 0x5097fc5e  ; [290]; 0.629638
 .long 0x637114cc  ; [290]; 0.776888
 .long 0x9c8eeb35  ; [802]; -0.776888
 .long 0x5097fc5e  ; [802]; 0.629638
 .long 0x708378fe  ; [162]; 0.879012
 .long 0x3d07c1d5  ; [162]; 0.476799
 .long 0xc2f83e2c  ; [674]; -0.476799
 .long 0x708378fe  ; [674]; 0.879012
 .long 0x24677757  ; [418]; 0.284408
 .long 0x7ab6cba3  ; [418]; 0.958703
 .long 0x8549345e  ; [930]; -0.958703
 .long 0x24677757  ; [930]; 0.284408
 .long 0x7a4210d8  ; [98]; 0.955141
 .long 0x25e845b6  ; [98]; 0.296151
 .long 0xda17ba4b  ; [610]; -0.296151
 .long 0x7a4210d8  ; [610]; 0.955141
 .long 0x3ba51e29  ; [354]; 0.465976
 .long 0x71410804  ; [354]; 0.884797
 .long 0x8ebef7fd  ; [866]; -0.884797
 .long 0x3ba51e29  ; [866]; 0.465976
 .long 0x6271fa68  ; [226]; 0.769103
 .long 0x51ced46e  ; [226]; 0.639124
 .long 0xae312b93  ; [738]; -0.639124
 .long 0x6271fa68  ; [738]; 0.769103
 .long 0x0bc3ac35  ; [482]; 0.091909
 .long 0x7f754e7f  ; [482]; 0.995767
 .long 0x808ab182  ; [994]; -0.995767
 .long 0x0bc3ac35  ; [994]; 0.091909
 .long 0x7fce0c3d  ; [18]; 0.998476
 .long 0x0710a345  ; [18]; 0.055195
 .long 0xf8ef5cbc  ; [530]; -0.055195
 .long 0x7fce0c3d  ; [530]; 0.998476
 .long 0x556040e2  ; [274]; 0.667000
 .long 0x5f5e0db2  ; [274]; 0.745058
 .long 0xa0a1f24f  ; [786]; -0.745058
 .long 0x556040e2  ; [786]; 0.667000
 .long 0x735f6625  ; [146]; 0.901349
 .long 0x376f9e46  ; [146]; 0.433094
 .long 0xc89061bb  ; [658]; -0.433094
 .long 0x735f6625  ; [658]; 0.901349
 .long 0x2a61b101  ; [402]; 0.331106
 .long 0x78c7aba1  ; [402]; 0.943593
 .long 0x87385460  ; [914]; -0.943593
 .long 0x2a61b101  ; [914]; 0.331106
 .long 0x7bf8882f  ; [82]; 0.968522
 .long 0x1fdcdc1b  ; [82]; 0.248928
 .long 0xe02323e6  ; [594]; -0.248928
 .long 0x7bf8882f  ; [594]; 0.968522
 .long 0x4121589a  ; [338]; 0.508830
 .long 0x6e30e349  ; [338]; 0.860867
 .long 0x91cf1cb8  ; [850]; -0.860867
 .long 0x4121589a  ; [850]; 0.508830
 .long 0x66573cbb  ; [210]; 0.799537
 .long 0x4ce10034  ; [210]; 0.600616
 .long 0xb31effcd  ; [722]; -0.600616
 .long 0x66573cbb  ; [722]; 0.799537
 .long 0x120116d5  ; [466]; 0.140658
 .long 0x7eba3a38  ; [466]; 0.990058
 .long 0x8145c5c9  ; [978]; -0.990058
 .long 0x120116d5  ; [978]; 0.140658
 .long 0x7e7f3956  ; [50]; 0.988258
 .long 0x138edbb1  ; [50]; 0.152797
 .long 0xec712450  ; [562]; -0.152797
 .long 0x7e7f3956  ; [562]; 0.988258
 .long 0x4b9e038f  ; [306]; 0.590760
 .long 0x6746c7d7  ; [306]; 0.806848
 .long 0x98b9382a  ; [818]; -0.806848
 .long 0x4b9e038f  ; [818]; 0.590760
 .long 0x6d6227f9  ; [178]; 0.854558
 .long 0x427a41d0  ; [178]; 0.519356
 .long 0xbd85be31  ; [690]; -0.519356
 .long 0x6d6227f9  ; [690]; 0.854558
 .long 0x1e56ca1e  ; [434]; 0.237024
 .long 0x7c5a3d4f  ; [434]; 0.971504
 .long 0x83a5c2b2  ; [946]; -0.971504
 .long 0x1e56ca1e  ; [946]; 0.237024
 .long 0x78403328  ; [114]; 0.939459
 .long 0x2bdc4e6f  ; [114]; 0.342661
 .long 0xd423b192  ; [626]; -0.342661
 .long 0x78403328  ; [626]; 0.939459
 .long 0x36041ad9  ; [370]; 0.422000
 .long 0x740b53fa  ; [370]; 0.906596
 .long 0x8bf4ac07  ; [882]; -0.906596
 .long 0x36041ad9  ; [882]; 0.422000
 .long 0x5e50015d  ; [242]; 0.736817
 .long 0x568a34a9  ; [242]; 0.676093
 .long 0xa975cb58  ; [754]; -0.676093
 .long 0x5e50015d  ; [754]; 0.736817
 .long 0x057f0035  ; [498]; 0.042938
 .long 0x7fe1c76a  ; [498]; 0.999078
 .long 0x801e3897  ; [1010]; -0.999078
 .long 0x057f0035  ; [1010]; 0.042938
 .long 0x7ff09477  ; [10]; 0.999529
 .long 0x03ed26e6  ; [10]; 0.030675
 .long 0xfc12d91b  ; [522]; -0.030675
 .long 0x7ff09477  ; [522]; 0.999529
 .long 0x57b0d255  ; [266]; 0.685084
 .long 0x5d3e5236  ; [266]; 0.728464
 .long 0xa2c1adcb  ; [778]; -0.728464
 .long 0x57b0d255  ; [778]; 0.685084
 .long 0x74b2c883  ; [138]; 0.911706
 .long 0x3496824f  ; [138]; 0.410843
 .long 0xcb697db2  ; [650]; -0.410843
 .long 0x74b2c883  ; [650]; 0.911706
 .long 0x2d553afb  ; [394]; 0.354164
 .long 0x77b417df  ; [394]; 0.935184
 .long 0x884be822  ; [906]; -0.935184
 .long 0x2d553afb  ; [906]; 0.354164
 .long 0x7cb72723  ; [74]; 0.974339
 .long 0x1ccf8cb3  ; [74]; 0.225084
 .long 0xe330734e  ; [586]; -0.225084
 .long 0x7cb72723  ; [586]; 0.974339
 .long 0x43d09aec  ; [330]; 0.529804
 .long 0x6c8f351b  ; [330]; 0.848120
 .long 0x9370cae6  ; [842]; -0.848120
 .long 0x43d09aec  ; [842]; 0.529804
 .long 0x683257aa  ; [202]; 0.814036
 .long 0x4a581c9d  ; [202]; 0.580814
 .long 0xb5a7e364  ; [714]; -0.580814
 .long 0x683257aa  ; [714]; 0.814036
 .long 0x151bdf85  ; [458]; 0.164913
 .long 0x7e3f57fe  ; [458]; 0.986308
 .long 0x81c0a803  ; [970]; -0.986308
 .long 0x151bdf85  ; [970]; 0.164913
 .long 0x7ef0585f  ; [42]; 0.991710
 .long 0x1072a048  ; [42]; 0.128498
 .long 0xef8d5fb9  ; [554]; -0.128498
 .long 0x7ef0585f  ; [554]; 0.991710
 .long 0x4e210617  ; [298]; 0.610383
 .long 0x6563bf91  ; [298]; 0.792107
 .long 0x9a9c4070  ; [810]; -0.792107
 .long 0x4e210617  ; [810]; 0.610383
 .long 0x6efb5f11  ; [170]; 0.867046
 .long 0x3fc5ec97  ; [170]; 0.498228
 .long 0xc03a136a  ; [682]; -0.498228
 .long 0x6efb5f11  ; [682]; 0.867046
 .long 0x2161b39f  ; [426]; 0.260794
 .long 0x7b920b88  ; [426]; 0.965394
 .long 0x846df479  ; [938]; -0.965394
 .long 0x2161b39f  ; [938]; 0.260794
 .long 0x794a7c11  ; [106]; 0.947586
 .long 0x28e5714a  ; [106]; 0.319502
 .long 0xd71a8eb7  ; [618]; -0.319502
 .long 0x794a7c11  ; [618]; 0.947586
 .long 0x38d8fe93  ; [362]; 0.444122
 .long 0x72af05a6  ; [362]; 0.895966
 .long 0x8d50fa5b  ; [874]; -0.895966
 .long 0x38d8fe93  ; [874]; 0.444122
 .long 0x60686cce  ; [234]; 0.753187
 .long 0x5433027d  ; [234]; 0.657807
 .long 0xabccfd84  ; [746]; -0.657807
 .long 0x60686cce  ; [746]; 0.753187
 .long 0x08a2009a  ; [490]; 0.067444
 .long 0x7fb563b2  ; [490]; 0.997723
 .long 0x804a9c4f  ; [1002]; -0.997723
 .long 0x08a2009a  ; [1002]; 0.067444
 .long 0x7f97cebc  ; [26]; 0.996820
 .long 0x0a3308bc  ; [26]; 0.079682
 .long 0xf5ccf745  ; [538]; -0.079682
 .long 0x7f97cebc  ; [538]; 0.996820
 .long 0x53028517  ; [282]; 0.648514
 .long 0x616f146b  ; [282]; 0.761202
 .long 0x9e90eb96  ; [794]; -0.761202
 .long 0x53028517  ; [794]; 0.648514
 .long 0x71fa3948  ; [154]; 0.890449
 .long 0x3a402dd1  ; [154]; 0.455084
 .long 0xc5bfd230  ; [666]; -0.455084
 .long 0x71fa3948  ; [666]; 0.890449
 .long 0x27679df4  ; [410]; 0.307850
 .long 0x79c89f6d  ; [410]; 0.951435
 .long 0x86376094  ; [922]; -0.951435
 .long 0x27679df4  ; [922]; 0.307850
 .long 0x7b26cb4e  ; [90]; 0.962121
 .long 0x22e541af  ; [90]; 0.272621
 .long 0xdd1abe52  ; [602]; -0.272621
 .long 0x7b26cb4e  ; [602]; 0.962121
 .long 0x3e680b2c  ; [346]; 0.487550
 .long 0x6fc19384  ; [346]; 0.873095
 .long 0x903e6c7d  ; [858]; -0.873095
 .long 0x3e680b2c  ; [858]; 0.487550
 .long 0x646c59bf  ; [218]; 0.784557
 .long 0x4f5e08e2  ; [218]; 0.620057
 .long 0xb0a1f71f  ; [730]; -0.620057
 .long 0x646c59bf  ; [730]; 0.784557
 .long 0x0ee38766  ; [474]; 0.116319
 .long 0x7f2191b3  ; [474]; 0.993212
 .long 0x80de6e4e  ; [986]; -0.993212
 .long 0x0ee38766  ; [986]; 0.116319
 .long 0x7dfa98a7  ; [58]; 0.984210
 .long 0x16a81305  ; [58]; 0.177004
 .long 0xe957ecfc  ; [570]; -0.177004
 .long 0x7dfa98a7  ; [570]; 0.984210
 .long 0x490f57ee  ; [314]; 0.570781
 .long 0x6919e31f  ; [314]; 0.821103
 .long 0x96e61ce2  ; [826]; -0.821103
 .long 0x490f57ee  ; [826]; 0.570781
 .long 0x6bb812d0  ; [186]; 0.841555
 .long 0x452456bc  ; [186]; 0.540171
 .long 0xbadba945  ; [698]; -0.540171
 .long 0x6bb812d0  ; [698]; 0.841555
 .long 0x1b4732ef  ; [442]; 0.213110
 .long 0x7d0f4217  ; [442]; 0.977028
 .long 0x82f0bdea  ; [954]; -0.977028
 .long 0x1b4732ef  ; [954]; 0.213110
 .long 0x77235f2c  ; [122]; 0.930767
 .long 0x2ecc681e  ; [122]; 0.365613
 .long 0xd13397e3  ; [634]; -0.365613
 .long 0x77235f2c  ; [634]; 0.930767
 .long 0x3326e2c2  ; [378]; 0.399624
 .long 0x7555bd4b  ; [378]; 0.916679
 .long 0x8aaa42b6  ; [890]; -0.916679
 .long 0x3326e2c2  ; [890]; 0.399624
 .long 0x5c290acc  ; [250]; 0.720003
 .long 0x58d40e8c  ; [250]; 0.693971
 .long 0xa72bf175  ; [762]; -0.693971
 .long 0x5c290acc  ; [762]; 0.720003
 .long 0x025b26d7  ; [506]; 0.018407
 .long 0x7ffa72d0  ; [506]; 0.999831
 .long 0x80058d31  ; [1018]; -0.999831
 .long 0x025b26d7  ; [1018]; 0.018407
 .long 0x7ffa72d0  ; [6]; 0.999831
 .long 0x025b26d7  ; [6]; 0.018407
 .long 0xfda4d92a  ; [518]; -0.018407
 .long 0x7ffa72d0  ; [518]; 0.999831
 .long 0x58d40e8c  ; [262]; 0.693971
 .long 0x5c290acc  ; [262]; 0.720003
 .long 0xa3d6f535  ; [774]; -0.720003
 .long 0x58d40e8c  ; [774]; 0.693971
 .long 0x7555bd4b  ; [134]; 0.916679
 .long 0x3326e2c2  ; [134]; 0.399624
 .long 0xccd91d3f  ; [646]; -0.399624
 .long 0x7555bd4b  ; [646]; 0.916679
 .long 0x2ecc681e  ; [390]; 0.365613
 .long 0x77235f2c  ; [390]; 0.930767
 .long 0x88dca0d5  ; [902]; -0.930767
 .long 0x2ecc681e  ; [902]; 0.365613
 .long 0x7d0f4217  ; [70]; 0.977028
 .long 0x1b4732ef  ; [70]; 0.213110
 .long 0xe4b8cd12  ; [582]; -0.213110
 .long 0x7d0f4217  ; [582]; 0.977028
 .long 0x452456bc  ; [326]; 0.540171
 .long 0x6bb812d0  ; [326]; 0.841555
 .long 0x9447ed31  ; [838]; -0.841555
 .long 0x452456bc  ; [838]; 0.540171
 .long 0x6919e31f  ; [198]; 0.821103
 .long 0x490f57ee  ; [198]; 0.570781
 .long 0xb6f0a813  ; [710]; -0.570781
 .long 0x6919e31f  ; [710]; 0.821103
 .long 0x16a81305  ; [454]; 0.177004
 .long 0x7dfa98a7  ; [454]; 0.984210
 .long 0x8205675a  ; [966]; -0.984210
 .long 0x16a81305  ; [966]; 0.177004
 .long 0x7f2191b3  ; [38]; 0.993212
 .long 0x0ee38766  ; [38]; 0.116319
 .long 0xf11c789b  ; [550]; -0.116319
 .long 0x7f2191b3  ; [550]; 0.993212
 .long 0x4f5e08e2  ; [294]; 0.620057
 .long 0x646c59bf  ; [294]; 0.784557
 .long 0x9b93a642  ; [806]; -0.784557
 .long 0x4f5e08e2  ; [806]; 0.620057
 .long 0x6fc19384  ; [166]; 0.873095
 .long 0x3e680b2c  ; [166]; 0.487550
 .long 0xc197f4d5  ; [678]; -0.487550
 .long 0x6fc19384  ; [678]; 0.873095
 .long 0x22e541af  ; [422]; 0.272621
 .long 0x7b26cb4e  ; [422]; 0.962121
 .long 0x84d934b3  ; [934]; -0.962121
 .long 0x22e541af  ; [934]; 0.272621
 .long 0x79c89f6d  ; [102]; 0.951435
 .long 0x27679df4  ; [102]; 0.307850
 .long 0xd898620d  ; [614]; -0.307850
 .long 0x79c89f6d  ; [614]; 0.951435
 .long 0x3a402dd1  ; [358]; 0.455084
 .long 0x71fa3948  ; [358]; 0.890449
 .long 0x8e05c6b9  ; [870]; -0.890449
 .long 0x3a402dd1  ; [870]; 0.455084
 .long 0x616f146b  ; [230]; 0.761202
 .long 0x53028517  ; [230]; 0.648514
 .long 0xacfd7aea  ; [742]; -0.648514
 .long 0x616f146b  ; [742]; 0.761202
 .long 0x0a3308bc  ; [486]; 0.079682
 .long 0x7f97cebc  ; [486]; 0.996820
 .long 0x80683145  ; [998]; -0.996820
 .long 0x0a3308bc  ; [998]; 0.079682
 .long 0x7fb563b2  ; [22]; 0.997723
 .long 0x08a2009a  ; [22]; 0.067444
 .long 0xf75dff67  ; [534]; -0.067444
 .long 0x7fb563b2  ; [534]; 0.997723
 .long 0x5433027d  ; [278]; 0.657807
 .long 0x60686cce  ; [278]; 0.753187
 .long 0x9f979333  ; [790]; -0.753187
 .long 0x5433027d  ; [790]; 0.657807
 .long 0x72af05a6  ; [150]; 0.895966
 .long 0x38d8fe93  ; [150]; 0.444122
 .long 0xc727016e  ; [662]; -0.444122
 .long 0x72af05a6  ; [662]; 0.895966
 .long 0x28e5714a  ; [406]; 0.319502
 .long 0x794a7c11  ; [406]; 0.947586
 .long 0x86b583f0  ; [918]; -0.947586
 .long 0x28e5714a  ; [918]; 0.319502
 .long 0x7b920b88  ; [86]; 0.965394
 .long 0x2161b39f  ; [86]; 0.260794
 .long 0xde9e4c62  ; [598]; -0.260794
 .long 0x7b920b88  ; [598]; 0.965394
 .long 0x3fc5ec97  ; [342]; 0.498228
 .long 0x6efb5f11  ; [342]; 0.867046
 .long 0x9104a0f0  ; [854]; -0.867046
 .long 0x3fc5ec97  ; [854]; 0.498228
 .long 0x6563bf91  ; [214]; 0.792107
 .long 0x4e210617  ; [214]; 0.610383
 .long 0xb1def9ea  ; [726]; -0.610383
 .long 0x6563bf91  ; [726]; 0.792107
 .long 0x1072a048  ; [470]; 0.128498
 .long 0x7ef0585f  ; [470]; 0.991710
 .long 0x810fa7a2  ; [982]; -0.991710
 .long 0x1072a048  ; [982]; 0.128498
 .long 0x7e3f57fe  ; [54]; 0.986308
 .long 0x151bdf85  ; [54]; 0.164913
 .long 0xeae4207c  ; [566]; -0.164913
 .long 0x7e3f57fe  ; [566]; 0.986308
 .long 0x4a581c9d  ; [310]; 0.580814
 .long 0x683257aa  ; [310]; 0.814036
 .long 0x97cda857  ; [822]; -0.814036
 .long 0x4a581c9d  ; [822]; 0.580814
 .long 0x6c8f351b  ; [182]; 0.848120
 .long 0x43d09aec  ; [182]; 0.529804
 .long 0xbc2f6515  ; [694]; -0.529804
 .long 0x6c8f351b  ; [694]; 0.848120
 .long 0x1ccf8cb3  ; [438]; 0.225084
 .long 0x7cb72723  ; [438]; 0.974339
 .long 0x8348d8de  ; [950]; -0.974339
 .long 0x1ccf8cb3  ; [950]; 0.225084
 .long 0x77b417df  ; [118]; 0.935184
 .long 0x2d553afb  ; [118]; 0.354164
 .long 0xd2aac506  ; [630]; -0.354164
 .long 0x77b417df  ; [630]; 0.935184
 .long 0x3496824f  ; [374]; 0.410843
 .long 0x74b2c883  ; [374]; 0.911706
 .long 0x8b4d377e  ; [886]; -0.911706
 .long 0x3496824f  ; [886]; 0.410843
 .long 0x5d3e5236  ; [246]; 0.728464
 .long 0x57b0d255  ; [246]; 0.685084
 .long 0xa84f2dac  ; [758]; -0.685084
 .long 0x5d3e5236  ; [758]; 0.728464
 .long 0x03ed26e6  ; [502]; 0.030675
 .long 0x7ff09477  ; [502]; 0.999529
 .long 0x800f6b8a  ; [1014]; -0.999529
 .long 0x03ed26e6  ; [1014]; 0.030675
 .long 0x7fe1c76a  ; [14]; 0.999078
 .long 0x057f0035  ; [14]; 0.042938
 .long 0xfa80ffcc  ; [526]; -0.042938
 .long 0x7fe1c76a  ; [526]; 0.999078
 .long 0x568a34a9  ; [270]; 0.676093
 .long 0x5e50015d  ; [270]; 0.736817
 .long 0xa1affea4  ; [782]; -0.736817
 .long 0x568a34a9  ; [782]; 0.676093
 .long 0x740b53fa  ; [142]; 0.906596
 .long 0x36041ad9  ; [142]; 0.422000
 .long 0xc9fbe528  ; [654]; -0.422000
 .long 0x740b53fa  ; [654]; 0.906596
 .long 0x2bdc4e6f  ; [398]; 0.342661
 .long 0x78403328  ; [398]; 0.939459
 .long 0x87bfccd9  ; [910]; -0.939459
 .long 0x2bdc4e6f  ; [910]; 0.342661
 .long 0x7c5a3d4f  ; [78]; 0.971504
 .long 0x1e56ca1e  ; [78]; 0.237024
 .long 0xe1a935e3  ; [590]; -0.237024
 .long 0x7c5a3d4f  ; [590]; 0.971504
 .long 0x427a41d0  ; [334]; 0.519356
 .long 0x6d6227f9  ; [334]; 0.854558
 .long 0x929dd808  ; [846]; -0.854558
 .long 0x427a41d0  ; [846]; 0.519356
 .long 0x6746c7d7  ; [206]; 0.806848
 .long 0x4b9e038f  ; [206]; 0.590760
 .long 0xb461fc72  ; [718]; -0.590760
 .long 0x6746c7d7  ; [718]; 0.806848
 .long 0x138edbb1  ; [462]; 0.152797
 .long 0x7e7f3956  ; [462]; 0.988258
 .long 0x8180c6ab  ; [974]; -0.988258
 .long 0x138edbb1  ; [974]; 0.152797
 .long 0x7eba3a38  ; [46]; 0.990058
 .long 0x120116d5  ; [46]; 0.140658
 .long 0xedfee92c  ; [558]; -0.140658
 .long 0x7eba3a38  ; [558]; 0.990058
 .long 0x4ce10034  ; [302]; 0.600616
 .long 0x66573cbb  ; [302]; 0.799537
 .long 0x99a8c346  ; [814]; -0.799537
 .long 0x4ce10034  ; [814]; 0.600616
 .long 0x6e30e349  ; [174]; 0.860867
 .long 0x4121589a  ; [174]; 0.508830
 .long 0xbedea767  ; [686]; -0.508830
 .long 0x6e30e349  ; [686]; 0.860867
 .long 0x1fdcdc1b  ; [430]; 0.248928
 .long 0x7bf8882f  ; [430]; 0.968522
 .long 0x840777d2  ; [942]; -0.968522
 .long 0x1fdcdc1b  ; [942]; 0.248928
 .long 0x78c7aba1  ; [110]; 0.943593
 .long 0x2a61b101  ; [110]; 0.331106
 .long 0xd59e4f00  ; [622]; -0.331106
 .long 0x78c7aba1  ; [622]; 0.943593
 .long 0x376f9e46  ; [366]; 0.433094
 .long 0x735f6625  ; [366]; 0.901349
 .long 0x8ca099dc  ; [878]; -0.901349
 .long 0x376f9e46  ; [878]; 0.433094
 .long 0x5f5e0db2  ; [238]; 0.745058
 .long 0x556040e2  ; [238]; 0.667000
 .long 0xaa9fbf1f  ; [750]; -0.667000
 .long 0x5f5e0db2  ; [750]; 0.745058
 .long 0x0710a345  ; [494]; 0.055195
 .long 0x7fce0c3d  ; [494]; 0.998476
 .long 0x8031f3c4  ; [1006]; -0.998476
 .long 0x0710a345  ; [1006]; 0.055195
 .long 0x7f754e7f  ; [30]; 0.995767
 .long 0x0bc3ac35  ; [30]; 0.091909
 .long 0xf43c53cc  ; [542]; -0.091909
 .long 0x7f754e7f  ; [542]; 0.995767
 .long 0x51ced46e  ; [286]; 0.639124
 .long 0x6271fa68  ; [286]; 0.769103
 .long 0x9d8e0599  ; [798]; -0.769103
 .long 0x51ced46e  ; [798]; 0.639124
 .long 0x71410804  ; [158]; 0.884797
 .long 0x3ba51e29  ; [158]; 0.465976
 .long 0xc45ae1d8  ; [670]; -0.465976
 .long 0x71410804  ; [670]; 0.884797
 .long 0x25e845b6  ; [414]; 0.296151
 .long 0x7a4210d8  ; [414]; 0.955141
 .long 0x85bdef29  ; [926]; -0.955141
 .long 0x25e845b6  ; [926]; 0.296151
 .long 0x7ab6cba3  ; [94]; 0.958703
 .long 0x24677757  ; [94]; 0.284408
 .long 0xdb9888aa  ; [606]; -0.284408
 .long 0x7ab6cba3  ; [606]; 0.958703
 .long 0x3d07c1d5  ; [350]; 0.476799
 .long 0x708378fe  ; [350]; 0.879012
 .long 0x8f7c8703  ; [862]; -0.879012
 .long 0x3d07c1d5  ; [862]; 0.476799
 .long 0x637114cc  ; [222]; 0.776888
 .long 0x5097fc5e  ; [222]; 0.629638
 .long 0xaf6803a3  ; [734]; -0.629638
 .long 0x637114cc  ; [734]; 0.776888
 .long 0x0d53db92  ; [478]; 0.104122
 .long 0x7f4de450  ; [478]; 0.994565
 .long 0x80b21bb1  ; [990]; -0.994565
 .long 0x0d53db92  ; [990]; 0.104122
 .long 0x7db0fdf7  ; [62]; 0.981964
 .long 0x183366e8  ; [62]; 0.189069
 .long 0xe7cc9919  ; [574]; -0.189069
 .long 0x7db0fdf7  ; [574]; 0.981964
 .long 0x47c3c22e  ; [318]; 0.560662
 .long 0x69fd614a  ; [318]; 0.828045
 .long 0x96029eb7  ; [830]; -0.828045
 .long 0x47c3c22e  ; [830]; 0.560662
 .long 0x6adcc964  ; [190]; 0.834863
 .long 0x46756827  ; [190]; 0.550458
 .long 0xb98a97da  ; [702]; -0.550458
 .long 0x6adcc964  ; [702]; 0.834863
 .long 0x19bdcbf3  ; [446]; 0.201105
 .long 0x7d628ac5  ; [446]; 0.979570
 .long 0x829d753c  ; [958]; -0.979570
 .long 0x19bdcbf3  ; [958]; 0.201105
 .long 0x768e0ea5  ; [126]; 0.926210
 .long 0x3041c760  ; [126]; 0.377007
 .long 0xcfbe38a1  ; [638]; -0.377007
 .long 0x768e0ea5  ; [638]; 0.926210
 .long 0x31b54a5d  ; [382]; 0.388345
 .long 0x75f42c0a  ; [382]; 0.921514
 .long 0x8a0bd3f7  ; [894]; -0.921514
 .long 0x31b54a5d  ; [894]; 0.388345
 .long 0x5b1035ce  ; [254]; 0.711432
 .long 0x59f3de12  ; [254]; 0.702755
 .long 0xa60c21ef  ; [766]; -0.702755
 .long 0x5b1035ce  ; [766]; 0.711432
 .long 0x00c90f88  ; [510]; 0.006136
 .long 0x7fff6215  ; [510]; 0.999981
 .long 0x80009dec  ; [1022]; -0.999981
 .long 0x00c90f88  ; [1022]; 0.006136
 .long 0x7fffd885  ; [1]; 0.999995
 .long 0x006487e3  ; [1]; 0.003068
 .long 0xff9b781e  ; [513]; -0.003068
 .long 0x7fffd885  ; [513]; 0.999995
 .long 0x5a3b47aa  ; [257]; 0.704934
 .long 0x5ac973b4  ; [257]; 0.709273
 .long 0xa5368c4d  ; [769]; -0.709273
 .long 0x5a3b47aa  ; [769]; 0.704934
 .long 0x761b1210  ; [129]; 0.922701
 .long 0x3158970d  ; [129]; 0.385516
 .long 0xcea768f4  ; [641]; -0.385516
 .long 0x761b1210  ; [641]; 0.922701
 .long 0x309ed556  ; [385]; 0.379847
 .long 0x76680375  ; [385]; 0.925049
 .long 0x8997fc8c  ; [897]; -0.925049
 .long 0x309ed556  ; [897]; 0.379847
 .long 0x7d769bb4  ; [65]; 0.980182
 .long 0x195b49ea  ; [65]; 0.198098
 .long 0xe6a4b617  ; [577]; -0.198098
 .long 0x7d769bb4  ; [577]; 0.980182
 .long 0x46c9405c  ; [321]; 0.553017
 .long 0x6aa551e8  ; [321]; 0.833170
 .long 0x955aae19  ; [833]; -0.833170
 .long 0x46c9405c  ; [833]; 0.553017
 .long 0x6a359db8  ; [193]; 0.829761
 .long 0x47706d93  ; [193]; 0.558119
 .long 0xb88f926e  ; [705]; -0.558119
 .long 0x6a359db8  ; [705]; 0.829761
 .long 0x18961728  ; [449]; 0.192080
 .long 0x7d9dd559  ; [449]; 0.981379
 .long 0x82622aa8  ; [961]; -0.981379
 .long 0x18961728  ; [961]; 0.192080
 .long 0x7f5834b6  ; [33]; 0.994879
 .long 0x0cefdb75  ; [33]; 0.101070
 .long 0xf310248c  ; [545]; -0.101070
 .long 0x7f5834b6  ; [545]; 0.994879
 .long 0x50e5fd6c  ; [289]; 0.632019
 .long 0x6331a9d4  ; [289]; 0.774953
 .long 0x9cce562d  ; [801]; -0.774953
 .long 0x50e5fd6c  ; [801]; 0.632019
 .long 0x70b34524  ; [161]; 0.880471
 .long 0x3caf50da  ; [161]; 0.474100
 .long 0xc350af27  ; [673]; -0.474100
 .long 0x70b34524  ; [673]; 0.880471
 .long 0x24c7cd32  ; [417]; 0.287347
 .long 0x7a9a0e4f  ; [417]; 0.957826
 .long 0x8565f1b2  ; [929]; -0.957826
 .long 0x24c7cd32  ; [929]; 0.287347
 .long 0x7a5fb0d7  ; [97]; 0.956045
 .long 0x2588349d  ; [97]; 0.293219
 .long 0xda77cb64  ; [609]; -0.293219
 .long 0x7a5fb0d7  ; [609]; 0.956045
 .long 0x3bfdfecd  ; [353]; 0.468689
 .long 0x71120cc4  ; [353]; 0.883363
 .long 0x8eedf33d  ; [865]; -0.883363
 .long 0x3bfdfecd  ; [865]; 0.468689
 .long 0x62b21c7b  ; [225]; 0.771061
 .long 0x518169a4  ; [225]; 0.636762
 .long 0xae7e965d  ; [737]; -0.636762
 .long 0x62b21c7b  ; [737]; 0.771061
 .long 0x0c27c389  ; [481]; 0.094963
 .long 0x7f6be9d3  ; [481]; 0.995481
 .long 0x8094162e  ; [993]; -0.995481
 .long 0x0c27c389  ; [993]; 0.094963
 .long 0x7fd37152  ; [17]; 0.998640
 .long 0x06ac406f  ; [17]; 0.052132
 .long 0xf953bf92  ; [529]; -0.052132
 .long 0x7fd37152  ; [529]; 0.998640
 .long 0x55ab0d46  ; [273]; 0.669283
 .long 0x5f1ae273  ; [273]; 0.743008
 .long 0xa0e51d8e  ; [785]; -0.743008
 .long 0x55ab0d46  ; [785]; 0.669283
 .long 0x738acc9d  ; [145]; 0.902673
 .long 0x3714f02a  ; [145]; 0.430326
 .long 0xc8eb0fd7  ; [657]; -0.430326
 .long 0x738acc9d  ; [657]; 0.902673
 .long 0x2ac08026  ; [401]; 0.334000
 .long 0x78a63d10  ; [401]; 0.942573
 .long 0x8759c2f1  ; [913]; -0.942573
 .long 0x2ac08026  ; [913]; 0.334000
 .long 0x7c116852  ; [81]; 0.969281
 .long 0x1f7b7480  ; [81]; 0.245955
 .long 0xe0848b81  ; [593]; -0.245955
 .long 0x7c116852  ; [593]; 0.969281
 .long 0x4177cfb0  ; [337]; 0.511469
 .long 0x6dfd9a1b  ; [337]; 0.859302
 .long 0x920265e6  ; [849]; -0.859302
 .long 0x4177cfb0  ; [849]; 0.511469
 .long 0x66937e90  ; [209]; 0.801376
 .long 0x4c9087b1  ; [209]; 0.598161
 .long 0xb36f7850  ; [721]; -0.598161
 .long 0x66937e90  ; [721]; 0.801376
 .long 0x1264994e  ; [465]; 0.143695
 .long 0x7eabef2b  ; [465]; 0.989622
 .long 0x815410d6  ; [977]; -0.989622
 .long 0x1264994e  ; [977]; 0.143695
 .long 0x7e8e6eb1  ; [49]; 0.988722
 .long 0x132b7bf9  ; [49]; 0.149765
 .long 0xecd48408  ; [561]; -0.149765
 .long 0x7e8e6eb1  ; [561]; 0.988722
 .long 0x4bef092c  ; [305]; 0.593232
 .long 0x670b4443  ; [305]; 0.805031
 .long 0x98f4bbbe  ; [817]; -0.805031
 .long 0x4bef092c  ; [817]; 0.593232
 .long 0x6d963c53  ; [177]; 0.856147
 .long 0x42244480  ; [177]; 0.516732
 .long 0xbddbbb81  ; [689]; -0.516732
 .long 0x6d963c53  ; [689]; 0.856147
 .long 0x1eb86b46  ; [433]; 0.240003
 .long 0x7c4242f1  ; [433]; 0.970772
 .long 0x83bdbd10  ; [945]; -0.970772
 .long 0x1eb86b46  ; [945]; 0.240003
 .long 0x786280bf  ; [113]; 0.940506
 .long 0x2b7dcf17  ; [113]; 0.339777
 .long 0xd48230ea  ; [625]; -0.339777
 .long 0x786280bf  ; [625]; 0.940506
 .long 0x365f2e3b  ; [369]; 0.424780
 .long 0x73e0c3a2  ; [369]; 0.905297
 .long 0x8c1f3c5f  ; [881]; -0.905297
 .long 0x365f2e3b  ; [881]; 0.424780
 .long 0x5e93dc1e  ; [241]; 0.738887
 .long 0x56400757  ; [241]; 0.673829
 .long 0xa9bff8aa  ; [753]; -0.673829
 .long 0x5e93dc1e  ; [753]; 0.738887
 .long 0x05e36ea9  ; [497]; 0.046003
 .long 0x7fdd4eeb  ; [497]; 0.998941
 .long 0x8022b116  ; [1009]; -0.998941
 .long 0x05e36ea9  ; [1009]; 0.046003
 .long 0x7ff38273  ; [9]; 0.999619
 .long 0x0388a9ea  ; [9]; 0.027608
 .long 0xfc775617  ; [521]; -0.027608
 .long 0x7ff38273  ; [521]; 0.999619
 .long 0x57f9f2f7  ; [265]; 0.687315
 .long 0x5cf95637  ; [265]; 0.726359
 .long 0xa306a9ca  ; [777]; -0.726359
 .long 0x57f9f2f7  ; [777]; 0.687315
 .long 0x74dbf1ee  ; [137]; 0.912962
 .long 0x343aca87  ; [137]; 0.408044
 .long 0xcbc5357a  ; [649]; -0.408044
 .long 0x74dbf1ee  ; [649]; 0.912962
 .long 0x2db330c7  ; [393]; 0.357031
 .long 0x7790583d  ; [393]; 0.934093
 .long 0x886fa7c4  ; [905]; -0.934093
 .long 0x2db330c7  ; [905]; 0.357031
 .long 0x7ccda168  ; [73]; 0.975025
 .long 0x1c6d9053  ; [73]; 0.222094
 .long 0xe3926fae  ; [585]; -0.222094
 .long 0x7ccda168  ; [585]; 0.975025
 .long 0x4425c923  ; [329]; 0.532403
 .long 0x6c59d0a8  ; [329]; 0.846491
 .long 0x93a62f59  ; [841]; -0.846491
 .long 0x4425c923  ; [841]; 0.532403
 .long 0x686c9b4a  ; [201]; 0.815814
 .long 0x4a062fbd  ; [201]; 0.578314
 .long 0xb5f9d044  ; [713]; -0.578314
 .long 0x686c9b4a  ; [713]; 0.815814
 .long 0x157f0086  ; [457]; 0.167938
 .long 0x7e2e9cde  ; [457]; 0.985798
 .long 0x81d16323  ; [969]; -0.985798
 .long 0x157f0086  ; [969]; 0.167938
 .long 0x7efd1c3b  ; [41]; 0.992099
 .long 0x100ee8ad  ; [41]; 0.125455
 .long 0xeff11754  ; [553]; -0.125455
 .long 0x7efd1c3b  ; [553]; 0.992099
 .long 0x4e708f8f  ; [297]; 0.612810
 .long 0x6526438e  ; [297]; 0.790230
 .long 0x9ad9bc73  ; [809]; -0.790230
 .long 0x4e708f8f  ; [809]; 0.612810
 .long 0x6f2d532b  ; [169]; 0.868571
 .long 0x3f6eaeb8  ; [169]; 0.495565
 .long 0xc0915149  ; [681]; -0.495565
 .long 0x6f2d532b  ; [681]; 0.868571
 .long 0x21c2b69c  ; [425]; 0.263755
 .long 0x7b77ada7  ; [425]; 0.964590
 .long 0x8488525a  ; [937]; -0.964590
 .long 0x21c2b69c  ; [937]; 0.263755
 .long 0x796a7553  ; [105]; 0.948561
 .long 0x288621b9  ; [105]; 0.316593
 .long 0xd779de48  ; [617]; -0.316593
 .long 0x796a7553  ; [617]; 0.948561
 .long 0x3932ff87  ; [361]; 0.446869
 .long 0x72823c66  ; [361]; 0.894599
 .long 0x8d7dc39b  ; [873]; -0.894599
 .long 0x3932ff87  ; [873]; 0.446869
 .long 0x60aa704f  ; [233]; 0.755201
 .long 0x53e73097  ; [233]; 0.655493
 .long 0xac18cf6a  ; [745]; -0.655493
 .long 0x60aa704f  ; [745]; 0.755201
 .long 0x09064b3a  ; [489]; 0.070505
 .long 0x7fae7494  ; [489]; 0.997511
 .long 0x80518b6d  ; [1001]; -0.997511
 .long 0x09064b3a  ; [1001]; 0.070505
 .long 0x7f9faa14  ; [25]; 0.997060
 .long 0x09cecf89  ; [25]; 0.076624
 .long 0xf6313078  ; [537]; -0.076624
 .long 0x7f9faa14  ; [537]; 0.997060
 .long 0x534ef1b5  ; [281]; 0.650847
 .long 0x612dc446  ; [281]; 0.759209
 .long 0x9ed23bbb  ; [793]; -0.759209
 .long 0x534ef1b5  ; [793]; 0.650847
 .long 0x7227d61b  ; [153]; 0.891841
 .long 0x39e6975d  ; [153]; 0.452350
 .long 0xc61968a4  ; [665]; -0.452350
 .long 0x7227d61b  ; [665]; 0.891841
 .long 0x27c737d3  ; [409]; 0.310767
 .long 0x79a98715  ; [409]; 0.950486
 .long 0x865678ec  ; [921]; -0.950486
 .long 0x27c737d3  ; [921]; 0.310767
 .long 0x7b420d79  ; [89]; 0.962953
 .long 0x22847ddf  ; [89]; 0.269668
 .long 0xdd7b8222  ; [601]; -0.269668
 .long 0x7b420d79  ; [601]; 0.962953
 .long 0x3ebfbdcc  ; [345]; 0.490226
 .long 0x6f906d83  ; [345]; 0.871595
 .long 0x906f927e  ; [857]; -0.871595
 .long 0x3ebfbdcc  ; [857]; 0.490226
 .long 0x64aa907e  ; [217]; 0.786455
 .long 0x4f0f1125  ; [217]; 0.617647
 .long 0xb0f0eedc  ; [729]; -0.617647
 .long 0x64aa907e  ; [729]; 0.786455
 .long 0x0f475bff  ; [473]; 0.119365
 .long 0x7f15b8ed  ; [473]; 0.992850
 .long 0x80ea4714  ; [985]; -0.992850
 .long 0x0f475bff  ; [985]; 0.119365
 .long 0x7e0c3d28  ; [57]; 0.984749
 .long 0x16451a83  ; [57]; 0.173984
 .long 0xe9bae57e  ; [569]; -0.173984
 .long 0x7e0c3d28  ; [569]; 0.984749
 .long 0x4961cd32  ; [313]; 0.573297
 .long 0x68e06129  ; [313]; 0.819348
 .long 0x971f9ed8  ; [825]; -0.819348
 .long 0x4961cd32  ; [825]; 0.573297
 .long 0x6bee3f62  ; [185]; 0.843208
 .long 0x44cfa73f  ; [185]; 0.537587
 .long 0xbb3058c2  ; [697]; -0.537587
 .long 0x6bee3f62  ; [697]; 0.843208
 .long 0x1ba96335  ; [441]; 0.216107
 .long 0x7cf9aeef  ; [441]; 0.976370
 .long 0x83065112  ; [953]; -0.976370
 .long 0x1ba96335  ; [953]; 0.216107
 .long 0x7747fbcd  ; [121]; 0.931884
 .long 0x2e6ec792  ; [121]; 0.362756
 .long 0xd191386f  ; [633]; -0.362756
 .long 0x7747fbcd  ; [633]; 0.931884
 .long 0x3382fa88  ; [377]; 0.402435
 .long 0x752d6c6b  ; [377]; 0.915449
 .long 0x8ad29396  ; [889]; -0.915449
 .long 0x3382fa88  ; [889]; 0.402435
 .long 0x5c6eb258  ; [249]; 0.722128
 .long 0x588b913f  ; [249]; 0.691759
 .long 0xa7746ec2  ; [761]; -0.691759
 .long 0x5c6eb258  ; [761]; 0.722128
 .long 0x02bfa9a4  ; [505]; 0.021474
 .long 0x7ff871a1  ; [505]; 0.999769
 .long 0x80078e60  ; [1017]; -0.999769
 .long 0x02bfa9a4  ; [1017]; 0.021474
 .long 0x7ffc250e  ; [5]; 0.999882
 .long 0x01f6a297  ; [5]; 0.015339
 .long 0xfe095d6a  ; [517]; -0.015339
 .long 0x7ffc250e  ; [517]; 0.999882
 .long 0x591c550d  ; [261]; 0.696177
 .long 0x5be32a66  ; [261]; 0.717870
 .long 0xa41cd59b  ; [773]; -0.717870
 .long 0x591c550d  ; [773]; 0.696177
 .long 0x757dc5c9  ; [133]; 0.917901
 .long 0x32caab6f  ; [133]; 0.396810
 .long 0xcd355492  ; [645]; -0.396810
 .long 0x757dc5c9  ; [645]; 0.917901
 .long 0x2f29ebcc  ; [389]; 0.368467
 .long 0x76fe790d  ; [389]; 0.929641
 .long 0x890186f4  ; [901]; -0.929641
 .long 0x2f29ebcc  ; [901]; 0.368467
 .long 0x7d24881a  ; [69]; 0.977677
 .long 0x1ae4f1d6  ; [69]; 0.210112
 .long 0xe51b0e2b  ; [581]; -0.210112
 .long 0x7d24881a  ; [581]; 0.977677
 .long 0x4578db93  ; [325]; 0.542751
 .long 0x6b81a3cc  ; [325]; 0.839894
 .long 0x947e5c35  ; [837]; -0.839894
 .long 0x4578db93  ; [837]; 0.542751
 .long 0x69532441  ; [197]; 0.822850
 .long 0x48bcb598  ; [197]; 0.568259
 .long 0xb7434a69  ; [709]; -0.568259
 .long 0x69532441  ; [709]; 0.822850
 .long 0x170afd8d  ; [453]; 0.180023
 .long 0x7de8a66f  ; [453]; 0.983662
 .long 0x82175992  ; [965]; -0.983662
 .long 0x170afd8d  ; [965]; 0.180023
 .long 0x7f2d1c0d  ; [37]; 0.993564
 .long 0x0e7fa99d  ; [37]; 0.113271
 .long 0xf1805664  ; [549]; -0.113271
 .long 0x7f2d1c0d  ; [549]; 0.993564
 .long 0x4faccfaa  ; [293]; 0.622461
 .long 0x642de50d  ; [293]; 0.782651
 .long 0x9bd21af4  ; [805]; -0.782651
 .long 0x4faccfaa  ; [805]; 0.622461
 .long 0x6ff27496  ; [165]; 0.874587
 .long 0x3e10320d  ; [165]; 0.484869
 .long 0xc1efcdf4  ; [677]; -0.484869
 .long 0x6ff27496  ; [677]; 0.874587
 .long 0x2345eff8  ; [421]; 0.275572
 .long 0x7b0b3d2b  ; [421]; 0.961280
 .long 0x84f4c2d6  ; [933]; -0.961280
 .long 0x2345eff8  ; [933]; 0.275572
 .long 0x79e76ca6  ; [101]; 0.952375
 .long 0x2707ebc6  ; [101]; 0.304929
 .long 0xd8f8143b  ; [613]; -0.304929
 .long 0x79e76ca6  ; [613]; 0.952375
 .long 0x3a99a057  ; [357]; 0.457813
 .long 0x71cc5626  ; [357]; 0.889048
 .long 0x8e33a9db  ; [869]; -0.889048
 .long 0x3a99a057  ; [869]; 0.457813
 .long 0x61b02876  ; [229]; 0.763188
 .long 0x52b5e545  ; [229]; 0.646176
 .long 0xad4a1abc  ; [741]; -0.646176
 .long 0x61b02876  ; [741]; 0.763188
 .long 0x0a973ba5  ; [485]; 0.082740
 .long 0x7f8fa4af  ; [485]; 0.996571
 .long 0x80705b52  ; [997]; -0.996571
 .long 0x0a973ba5  ; [997]; 0.082740
 .long 0x7fbc0409  ; [21]; 0.997925
 .long 0x083db0a7  ; [21]; 0.064383
 .long 0xf7c24f5a  ; [533]; -0.064383
 .long 0x7fbc0409  ; [533]; 0.997925
 .long 0x547ea073  ; [277]; 0.660114
 .long 0x60262dd5  ; [277]; 0.751165
 .long 0x9fd9d22c  ; [789]; -0.751165
 .long 0x547ea073  ; [789]; 0.660114
 .long 0x72db8827  ; [149]; 0.897325
 .long 0x387eda8e  ; [149]; 0.441371
 .long 0xc7812573  ; [661]; -0.441371
 .long 0x72db8827  ; [661]; 0.897325
 .long 0x2944a7a2  ; [405]; 0.322408
 .long 0x792a37fd  ; [405]; 0.946601
 .long 0x86d5c804  ; [917]; -0.946601
 .long 0x2944a7a2  ; [917]; 0.322408
 .long 0x7bac1d30  ; [85]; 0.966190
 .long 0x21009c0c  ; [85]; 0.257831
 .long 0xdeff63f5  ; [597]; -0.257831
 .long 0x7bac1d30  ; [597]; 0.966190
 .long 0x401d0320  ; [341]; 0.500885
 .long 0x6ec92682  ; [341]; 0.865514
 .long 0x9136d97f  ; [853]; -0.865514
 .long 0x401d0320  ; [853]; 0.500885
 .long 0x65a0fd0a  ; [213]; 0.793975
 .long 0x4dd14c6d  ; [213]; 0.607950
 .long 0xb22eb394  ; [725]; -0.607950
 .long 0x65a0fd0a  ; [725]; 0.793975
 .long 0x10d64dbd  ; [469]; 0.131540
 .long 0x7ee34635  ; [469]; 0.991311
 .long 0x811cb9cc  ; [981]; -0.991311
 .long 0x10d64dbd  ; [981]; 0.131540
 .long 0x7e4fc53d  ; [53]; 0.986809
 .long 0x14b8b17f  ; [53]; 0.161886
 .long 0xeb474e82  ; [565]; -0.161886
 .long 0x7e4fc53d  ; [565]; 0.986809
 .long 0x4aa9dba1  ; [309]; 0.583309
 .long 0x67f7d3c4  ; [309]; 0.812251
 .long 0x98082c3d  ; [821]; -0.812251
 .long 0x4aa9dba1  ; [821]; 0.583309
 .long 0x6cc45697  ; [181]; 0.849742
 .long 0x437b42e1  ; [181]; 0.527199
 .long 0xbc84bd20  ; [693]; -0.527199
 .long 0x6cc45697  ; [693]; 0.849742
 .long 0x1d31774d  ; [437]; 0.228072
 .long 0x7ca05ff0  ; [437]; 0.973644
 .long 0x835fa011  ; [949]; -0.973644
 .long 0x1d31774d  ; [949]; 0.228072
 .long 0x77d78da9  ; [117]; 0.936266
 .long 0x2cf72939  ; [117]; 0.351293
 .long 0xd308d6c8  ; [629]; -0.351293
 .long 0x77d78da9  ; [629]; 0.936266
 .long 0x34f219a7  ; [373]; 0.413638
 .long 0x7489571b  ; [373]; 0.910441
 .long 0x8b76a8e6  ; [885]; -0.910441
 .long 0x34f219a7  ; [885]; 0.413638
 .long 0x5d8314b0  ; [245]; 0.730563
 .long 0x57677b9c  ; [245]; 0.682846
 .long 0xa8988465  ; [757]; -0.682846
 .long 0x5d8314b0  ; [757]; 0.730563
 .long 0x0451a177  ; [501]; 0.033741
 .long 0x7fed5790  ; [501]; 0.999431
 .long 0x8012a871  ; [1013]; -0.999431
 .long 0x0451a177  ; [1013]; 0.033741
 .long 0x7fe5f107  ; [13]; 0.999205
 .long 0x051a8e5c  ; [13]; 0.039873
 .long 0xfae571a5  ; [525]; -0.039873
 .long 0x7fe5f107  ; [525]; 0.999205
 .long 0x56d42c99  ; [269]; 0.678350
 .long 0x5e0bec6e  ; [269]; 0.734739
 .long 0xa1f41393  ; [781]; -0.734739
 .long 0x56d42c99  ; [781]; 0.678350
 .long 0x74359cbc  ; [141]; 0.907886
 .long 0x35a8e624  ; [141]; 0.419217
 .long 0xca5719dd  ; [653]; -0.419217
 .long 0x74359cbc  ; [653]; 0.907886
 .long 0x2c3ab2b9  ; [397]; 0.345541
 .long 0x781d9b64  ; [397]; 0.938404
 .long 0x87e2649d  ; [909]; -0.938404
 .long 0x2c3ab2b9  ; [909]; 0.345541
 .long 0x7c71eaf8  ; [77]; 0.972226
 .long 0x1df5163f  ; [77]; 0.234042
 .long 0xe20ae9c2  ; [589]; -0.234042
 .long 0x7c71eaf8  ; [589]; 0.972226
 .long 0x42d0161e  ; [333]; 0.521975
 .long 0x6d2dd027  ; [333]; 0.852961
 .long 0x92d22fda  ; [845]; -0.852961
 .long 0x42d0161e  ; [845]; 0.521975
 .long 0x67820bb6  ; [205]; 0.808656
 .long 0x4b4ccf4d  ; [205]; 0.588282
 .long 0xb4b330b4  ; [717]; -0.588282
 .long 0x67820bb6  ; [717]; 0.808656
 .long 0x13f22f58  ; [461]; 0.155828
 .long 0x7e6fb5f3  ; [461]; 0.987784
 .long 0x81904a0e  ; [973]; -0.987784
 .long 0x13f22f58  ; [973]; 0.155828
 .long 0x7ec83719  ; [45]; 0.990485
 .long 0x119d8941  ; [45]; 0.137620
 .long 0xee6276c0  ; [557]; -0.137620
 .long 0x7ec83719  ; [557]; 0.990485
 .long 0x4d31494a  ; [301]; 0.603067
 .long 0x661abbc4  ; [301]; 0.797691
 .long 0x99e5443d  ; [813]; -0.797691
 .long 0x4d31494a  ; [813]; 0.603067
 .long 0x6e63e87f  ; [173]; 0.862424
 .long 0x40cab957  ; [173]; 0.506187
 .long 0xbf3546aa  ; [685]; -0.506187
 .long 0x6e63e87f  ; [685]; 0.862424
 .long 0x203e300d  ; [429]; 0.251898
 .long 0x7bdf5b93  ; [429]; 0.967754
 .long 0x8420a46e  ; [941]; -0.967754
 .long 0x203e300d  ; [941]; 0.251898
 .long 0x78e8cfb1  ; [109]; 0.944605
 .long 0x2a02c7b8  ; [109]; 0.328210
 .long 0xd5fd3849  ; [621]; -0.328210
 .long 0x78e8cfb1  ; [621]; 0.944605
 .long 0x37ca2a30  ; [365]; 0.435857
 .long 0x7333b882  ; [365]; 0.900016
 .long 0x8ccc477f  ; [877]; -0.900016
 .long 0x37ca2a30  ; [877]; 0.435857
 .long 0x5fa0fe1e  ; [237]; 0.747101
 .long 0x55153fd4  ; [237]; 0.664711
 .long 0xaaeac02d  ; [749]; -0.664711
 .long 0x5fa0fe1e  ; [749]; 0.747101
 .long 0x077501be  ; [493]; 0.058258
 .long 0x7fc85853  ; [493]; 0.998302
 .long 0x8037a7ae  ; [1005]; -0.998302
 .long 0x077501be  ; [1005]; 0.058258
 .long 0x7f7e648b  ; [29]; 0.996045
 .long 0x0b5f8d9f  ; [29]; 0.088854
 .long 0xf4a07262  ; [541]; -0.088854
 .long 0x7f7e648b  ; [541]; 0.996045
 .long 0x521c0cc1  ; [285]; 0.641481
 .long 0x62319b9c  ; [285]; 0.767139
 .long 0x9dce6465  ; [797]; -0.767139
 .long 0x521c0cc1  ; [797]; 0.641481
 .long 0x716fbd67  ; [157]; 0.886223
 .long 0x3b4c18b9  ; [157]; 0.463260
 .long 0xc4b3e748  ; [669]; -0.463260
 .long 0x716fbd67  ; [669]; 0.886223
 .long 0x26483f6c  ; [413]; 0.299080
 .long 0x7a24256e  ; [413]; 0.954228
 .long 0x85dbda93  ; [925]; -0.954228
 .long 0x26483f6c  ; [925]; 0.299080
 .long 0x7ad33d44  ; [93]; 0.959572
 .long 0x24070b07  ; [93]; 0.281465
 .long 0xdbf8f4fa  ; [605]; -0.281465
 .long 0x7ad33d44  ; [605]; 0.959572
 .long 0x3d600d2b  ; [349]; 0.479494
 .long 0x70536770  ; [349]; 0.877545
 .long 0x8fac9891  ; [861]; -0.877545
 .long 0x3d600d2b  ; [861]; 0.479494
 .long 0x63b0426c  ; [221]; 0.778817
 .long 0x5049c998  ; [221]; 0.627252
 .long 0xafb63669  ; [733]; -0.627252
 .long 0x63b0426c  ; [733]; 0.778817
 .long 0x0db7d376  ; [477]; 0.107172
 .long 0x7f434562  ; [477]; 0.994240
 .long 0x80bcba9f  ; [989]; -0.994240
 .long 0x0db7d376  ; [989]; 0.107172
 .long 0x7dc3d90c  ; [61]; 0.982539
 .long 0x17d0a7bc  ; [61]; 0.186055
 .long 0xe82f5845  ; [573]; -0.186055
 .long 0x7dc3d90c  ; [573]; 0.982539
 .long 0x4816ea85  ; [317]; 0.563199
 .long 0x69c4e37a  ; [317]; 0.826321
 .long 0x963b1c87  ; [829]; -0.826321
 .long 0x4816ea85  ; [829]; 0.563199
 .long 0x6b13fef4  ; [189]; 0.836548
 .long 0x4621647c  ; [189]; 0.547894
 .long 0xb9de9b85  ; [701]; -0.547894
 .long 0x6b13fef4  ; [701]; 0.836548
 .long 0x1a203e1b  ; [445]; 0.204109
 .long 0x7d4e2c7e  ; [445]; 0.978948
 .long 0x82b1d383  ; [957]; -0.978948
 .long 0x1a203e1b  ; [957]; 0.204109
 .long 0x76b3d0b3  ; [125]; 0.927363
 .long 0x2fe49ba7  ; [125]; 0.374164
 .long 0xd01b645a  ; [637]; -0.374164
 .long 0x76b3d0b3  ; [637]; 0.927363
 .long 0x3211df03  ; [381]; 0.391170
 .long 0x75ccfd41  ; [381]; 0.920318
 .long 0x8a3302c0  ; [893]; -0.920318
 .long 0x3211df03  ; [893]; 0.391170
 .long 0x5b56bfbc  ; [253]; 0.713585
 .long 0x59ac3cfd  ; [253]; 0.700569
 .long 0xa653c304  ; [765]; -0.700569
 .long 0x5b56bfbc  ; [765]; 0.713585
 .long 0x012d96b1  ; [509]; 0.009204
 .long 0x7ffe9cb1  ; [509]; 0.999958
 .long 0x80016350  ; [1021]; -0.999958
 .long 0x012d96b1  ; [1021]; 0.009204
 .long 0x7ffe9cb1  ; [3]; 0.999958
 .long 0x012d96b1  ; [3]; 0.009204
 .long 0xfed26950  ; [515]; -0.009204
 .long 0x7ffe9cb1  ; [515]; 0.999958
 .long 0x59ac3cfd  ; [259]; 0.700569
 .long 0x5b56bfbc  ; [259]; 0.713585
 .long 0xa4a94045  ; [771]; -0.713585
 .long 0x59ac3cfd  ; [771]; 0.700569
 .long 0x75ccfd41  ; [131]; 0.920318
 .long 0x3211df03  ; [131]; 0.391170
 .long 0xcdee20fe  ; [643]; -0.391170
 .long 0x75ccfd41  ; [643]; 0.920318
 .long 0x2fe49ba7  ; [387]; 0.374164
 .long 0x76b3d0b3  ; [387]; 0.927363
 .long 0x894c2f4e  ; [899]; -0.927363
 .long 0x2fe49ba7  ; [899]; 0.374164
 .long 0x7d4e2c7e  ; [67]; 0.978948
 .long 0x1a203e1b  ; [67]; 0.204109
 .long 0xe5dfc1e6  ; [579]; -0.204109
 .long 0x7d4e2c7e  ; [579]; 0.978948
 .long 0x4621647c  ; [323]; 0.547894
 .long 0x6b13fef4  ; [323]; 0.836548
 .long 0x94ec010d  ; [835]; -0.836548
 .long 0x4621647c  ; [835]; 0.547894
 .long 0x69c4e37a  ; [195]; 0.826321
 .long 0x4816ea85  ; [195]; 0.563199
 .long 0xb7e9157c  ; [707]; -0.563199
 .long 0x69c4e37a  ; [707]; 0.826321
 .long 0x17d0a7bc  ; [451]; 0.186055
 .long 0x7dc3d90c  ; [451]; 0.982539
 .long 0x823c26f5  ; [963]; -0.982539
 .long 0x17d0a7bc  ; [963]; 0.186055
 .long 0x7f434562  ; [35]; 0.994240
 .long 0x0db7d376  ; [35]; 0.107172
 .long 0xf2482c8b  ; [547]; -0.107172
 .long 0x7f434562  ; [547]; 0.994240
 .long 0x5049c998  ; [291]; 0.627252
 .long 0x63b0426c  ; [291]; 0.778817
 .long 0x9c4fbd95  ; [803]; -0.778817
 .long 0x5049c998  ; [803]; 0.627252
 .long 0x70536770  ; [163]; 0.877545
 .long 0x3d600d2b  ; [163]; 0.479494
 .long 0xc29ff2d6  ; [675]; -0.479494
 .long 0x70536770  ; [675]; 0.877545
 .long 0x24070b07  ; [419]; 0.281465
 .long 0x7ad33d44  ; [419]; 0.959572
 .long 0x852cc2bd  ; [931]; -0.959572
 .long 0x24070b07  ; [931]; 0.281465
 .long 0x7a24256e  ; [99]; 0.954228
 .long 0x26483f6c  ; [99]; 0.299080
 .long 0xd9b7c095  ; [611]; -0.299080
 .long 0x7a24256e  ; [611]; 0.954228
 .long 0x3b4c18b9  ; [355]; 0.463260
 .long 0x716fbd67  ; [355]; 0.886223
 .long 0x8e90429a  ; [867]; -0.886223
 .long 0x3b4c18b9  ; [867]; 0.463260
 .long 0x62319b9c  ; [227]; 0.767139
 .long 0x521c0cc1  ; [227]; 0.641481
 .long 0xade3f340  ; [739]; -0.641481
 .long 0x62319b9c  ; [739]; 0.767139
 .long 0x0b5f8d9f  ; [483]; 0.088854
 .long 0x7f7e648b  ; [483]; 0.996045
 .long 0x80819b76  ; [995]; -0.996045
 .long 0x0b5f8d9f  ; [995]; 0.088854
 .long 0x7fc85853  ; [19]; 0.998302
 .long 0x077501be  ; [19]; 0.058258
 .long 0xf88afe43  ; [531]; -0.058258
 .long 0x7fc85853  ; [531]; 0.998302
 .long 0x55153fd4  ; [275]; 0.664711
 .long 0x5fa0fe1e  ; [275]; 0.747101
 .long 0xa05f01e3  ; [787]; -0.747101
 .long 0x55153fd4  ; [787]; 0.664711
 .long 0x7333b882  ; [147]; 0.900016
 .long 0x37ca2a30  ; [147]; 0.435857
 .long 0xc835d5d1  ; [659]; -0.435857
 .long 0x7333b882  ; [659]; 0.900016
 .long 0x2a02c7b8  ; [403]; 0.328210
 .long 0x78e8cfb1  ; [403]; 0.944605
 .long 0x87173050  ; [915]; -0.944605
 .long 0x2a02c7b8  ; [915]; 0.328210
 .long 0x7bdf5b93  ; [83]; 0.967754
 .long 0x203e300d  ; [83]; 0.251898
 .long 0xdfc1cff4  ; [595]; -0.251898
 .long 0x7bdf5b93  ; [595]; 0.967754
 .long 0x40cab957  ; [339]; 0.506187
 .long 0x6e63e87f  ; [339]; 0.862424
 .long 0x919c1782  ; [851]; -0.862424
 .long 0x40cab957  ; [851]; 0.506187
 .long 0x661abbc4  ; [211]; 0.797691
 .long 0x4d31494a  ; [211]; 0.603067
 .long 0xb2ceb6b7  ; [723]; -0.603067
 .long 0x661abbc4  ; [723]; 0.797691
 .long 0x119d8941  ; [467]; 0.137620
 .long 0x7ec83719  ; [467]; 0.990485
 .long 0x8137c8e8  ; [979]; -0.990485
 .long 0x119d8941  ; [979]; 0.137620
 .long 0x7e6fb5f3  ; [51]; 0.987784
 .long 0x13f22f58  ; [51]; 0.155828
 .long 0xec0dd0a9  ; [563]; -0.155828
 .long 0x7e6fb5f3  ; [563]; 0.987784
 .long 0x4b4ccf4d  ; [307]; 0.588282
 .long 0x67820bb6  ; [307]; 0.808656
 .long 0x987df44b  ; [819]; -0.808656
 .long 0x4b4ccf4d  ; [819]; 0.588282
 .long 0x6d2dd027  ; [179]; 0.852961
 .long 0x42d0161e  ; [179]; 0.521975
 .long 0xbd2fe9e3  ; [691]; -0.521975
 .long 0x6d2dd027  ; [691]; 0.852961
 .long 0x1df5163f  ; [435]; 0.234042
 .long 0x7c71eaf8  ; [435]; 0.972226
 .long 0x838e1509  ; [947]; -0.972226
 .long 0x1df5163f  ; [947]; 0.234042
 .long 0x781d9b64  ; [115]; 0.938404
 .long 0x2c3ab2b9  ; [115]; 0.345541
 .long 0xd3c54d48  ; [627]; -0.345541
 .long 0x781d9b64  ; [627]; 0.938404
 .long 0x35a8e624  ; [371]; 0.419217
 .long 0x74359cbc  ; [371]; 0.907886
 .long 0x8bca6345  ; [883]; -0.907886
 .long 0x35a8e624  ; [883]; 0.419217
 .long 0x5e0bec6e  ; [243]; 0.734739
 .long 0x56d42c99  ; [243]; 0.678350
 .long 0xa92bd368  ; [755]; -0.678350
 .long 0x5e0bec6e  ; [755]; 0.734739
 .long 0x051a8e5c  ; [499]; 0.039873
 .long 0x7fe5f107  ; [499]; 0.999205
 .long 0x801a0efa  ; [1011]; -0.999205
 .long 0x051a8e5c  ; [1011]; 0.039873
 .long 0x7fed5790  ; [11]; 0.999431
 .long 0x0451a177  ; [11]; 0.033741
 .long 0xfbae5e8a  ; [523]; -0.033741
 .long 0x7fed5790  ; [523]; 0.999431
 .long 0x57677b9c  ; [267]; 0.682846
 .long 0x5d8314b0  ; [267]; 0.730563
 .long 0xa27ceb51  ; [779]; -0.730563
 .long 0x57677b9c  ; [779]; 0.682846
 .long 0x7489571b  ; [139]; 0.910441
 .long 0x34f219a7  ; [139]; 0.413638
 .long 0xcb0de65a  ; [651]; -0.413638
 .long 0x7489571b  ; [651]; 0.910441
 .long 0x2cf72939  ; [395]; 0.351293
 .long 0x77d78da9  ; [395]; 0.936266
 .long 0x88287258  ; [907]; -0.936266
 .long 0x2cf72939  ; [907]; 0.351293
 .long 0x7ca05ff0  ; [75]; 0.973644
 .long 0x1d31774d  ; [75]; 0.228072
 .long 0xe2ce88b4  ; [587]; -0.228072
 .long 0x7ca05ff0  ; [587]; 0.973644
 .long 0x437b42e1  ; [331]; 0.527199
 .long 0x6cc45697  ; [331]; 0.849742
 .long 0x933ba96a  ; [843]; -0.849742
 .long 0x437b42e1  ; [843]; 0.527199
 .long 0x67f7d3c4  ; [203]; 0.812251
 .long 0x4aa9dba1  ; [203]; 0.583309
 .long 0xb5562460  ; [715]; -0.583309
 .long 0x67f7d3c4  ; [715]; 0.812251
 .long 0x14b8b17f  ; [459]; 0.161886
 .long 0x7e4fc53d  ; [459]; 0.986809
 .long 0x81b03ac4  ; [971]; -0.986809
 .long 0x14b8b17f  ; [971]; 0.161886
 .long 0x7ee34635  ; [43]; 0.991311
 .long 0x10d64dbd  ; [43]; 0.131540
 .long 0xef29b244  ; [555]; -0.131540
 .long 0x7ee34635  ; [555]; 0.991311
 .long 0x4dd14c6d  ; [299]; 0.607950
 .long 0x65a0fd0a  ; [299]; 0.793975
 .long 0x9a5f02f7  ; [811]; -0.793975
 .long 0x4dd14c6d  ; [811]; 0.607950
 .long 0x6ec92682  ; [171]; 0.865514
 .long 0x401d0320  ; [171]; 0.500885
 .long 0xbfe2fce1  ; [683]; -0.500885
 .long 0x6ec92682  ; [683]; 0.865514
 .long 0x21009c0c  ; [427]; 0.257831
 .long 0x7bac1d30  ; [427]; 0.966190
 .long 0x8453e2d1  ; [939]; -0.966190
 .long 0x21009c0c  ; [939]; 0.257831
 .long 0x792a37fd  ; [107]; 0.946601
 .long 0x2944a7a2  ; [107]; 0.322408
 .long 0xd6bb585f  ; [619]; -0.322408
 .long 0x792a37fd  ; [619]; 0.946601
 .long 0x387eda8e  ; [363]; 0.441371
 .long 0x72db8827  ; [363]; 0.897325
 .long 0x8d2477da  ; [875]; -0.897325
 .long 0x387eda8e  ; [875]; 0.441371
 .long 0x60262dd5  ; [235]; 0.751165
 .long 0x547ea073  ; [235]; 0.660114
 .long 0xab815f8e  ; [747]; -0.660114
 .long 0x60262dd5  ; [747]; 0.751165
 .long 0x083db0a7  ; [491]; 0.064383
 .long 0x7fbc0409  ; [491]; 0.997925
 .long 0x8043fbf8  ; [1003]; -0.997925
 .long 0x083db0a7  ; [1003]; 0.064383
 .long 0x7f8fa4af  ; [27]; 0.996571
 .long 0x0a973ba5  ; [27]; 0.082740
 .long 0xf568c45c  ; [539]; -0.082740
 .long 0x7f8fa4af  ; [539]; 0.996571
 .long 0x52b5e545  ; [283]; 0.646176
 .long 0x61b02876  ; [283]; 0.763188
 .long 0x9e4fd78b  ; [795]; -0.763188
 .long 0x52b5e545  ; [795]; 0.646176
 .long 0x71cc5626  ; [155]; 0.889048
 .long 0x3a99a057  ; [155]; 0.457813
 .long 0xc5665faa  ; [667]; -0.457813
 .long 0x71cc5626  ; [667]; 0.889048
 .long 0x2707ebc6  ; [411]; 0.304929
 .long 0x79e76ca6  ; [411]; 0.952375
 .long 0x8618935b  ; [923]; -0.952375
 .long 0x2707ebc6  ; [923]; 0.304929
 .long 0x7b0b3d2b  ; [91]; 0.961280
 .long 0x2345eff8  ; [91]; 0.275572
 .long 0xdcba1009  ; [603]; -0.275572
 .long 0x7b0b3d2b  ; [603]; 0.961280
 .long 0x3e10320d  ; [347]; 0.484869
 .long 0x6ff27496  ; [347]; 0.874587
 .long 0x900d8b6b  ; [859]; -0.874587
 .long 0x3e10320d  ; [859]; 0.484869
 .long 0x642de50d  ; [219]; 0.782651
 .long 0x4faccfaa  ; [219]; 0.622461
 .long 0xb0533057  ; [731]; -0.622461
 .long 0x642de50d  ; [731]; 0.782651
 .long 0x0e7fa99d  ; [475]; 0.113271
 .long 0x7f2d1c0d  ; [475]; 0.993564
 .long 0x80d2e3f4  ; [987]; -0.993564
 .long 0x0e7fa99d  ; [987]; 0.113271
 .long 0x7de8a66f  ; [59]; 0.983662
 .long 0x170afd8d  ; [59]; 0.180023
 .long 0xe8f50274  ; [571]; -0.180023
 .long 0x7de8a66f  ; [571]; 0.983662
 .long 0x48bcb598  ; [315]; 0.568259
 .long 0x69532441  ; [315]; 0.822850
 .long 0x96acdbc0  ; [827]; -0.822850
 .long 0x48bcb598  ; [827]; 0.568259
 .long 0x6b81a3cc  ; [187]; 0.839894
 .long 0x4578db93  ; [187]; 0.542751
 .long 0xba87246e  ; [699]; -0.542751
 .long 0x6b81a3cc  ; [699]; 0.839894
 .long 0x1ae4f1d6  ; [443]; 0.210112
 .long 0x7d24881a  ; [443]; 0.977677
 .long 0x82db77e7  ; [955]; -0.977677
 .long 0x1ae4f1d6  ; [955]; 0.210112
 .long 0x76fe790d  ; [123]; 0.929641
 .long 0x2f29ebcc  ; [123]; 0.368467
 .long 0xd0d61435  ; [635]; -0.368467
 .long 0x76fe790d  ; [635]; 0.929641
 .long 0x32caab6f  ; [379]; 0.396810
 .long 0x757dc5c9  ; [379]; 0.917901
 .long 0x8a823a38  ; [891]; -0.917901
 .long 0x32caab6f  ; [891]; 0.396810
 .long 0x5be32a66  ; [251]; 0.717870
 .long 0x591c550d  ; [251]; 0.696177
 .long 0xa6e3aaf4  ; [763]; -0.696177
 .long 0x5be32a66  ; [763]; 0.717870
 .long 0x01f6a297  ; [507]; 0.015339
 .long 0x7ffc250e  ; [507]; 0.999882
 .long 0x8003daf3  ; [1019]; -0.999882
 .long 0x01f6a297  ; [1019]; 0.015339
 .long 0x7ff871a1  ; [7]; 0.999769
 .long 0x02bfa9a4  ; [7]; 0.021474
 .long 0xfd40565d  ; [519]; -0.021474
 .long 0x7ff871a1  ; [519]; 0.999769
 .long 0x588b913f  ; [263]; 0.691759
 .long 0x5c6eb258  ; [263]; 0.722128
 .long 0xa3914da9  ; [775]; -0.722128
 .long 0x588b913f  ; [775]; 0.691759
 .long 0x752d6c6b  ; [135]; 0.915449
 .long 0x3382fa88  ; [135]; 0.402435
 .long 0xcc7d0579  ; [647]; -0.402435
 .long 0x752d6c6b  ; [647]; 0.915449
 .long 0x2e6ec792  ; [391]; 0.362756
 .long 0x7747fbcd  ; [391]; 0.931884
 .long 0x88b80434  ; [903]; -0.931884
 .long 0x2e6ec792  ; [903]; 0.362756
 .long 0x7cf9aeef  ; [71]; 0.976370
 .long 0x1ba96335  ; [71]; 0.216107
 .long 0xe4569ccc  ; [583]; -0.216107
 .long 0x7cf9aeef  ; [583]; 0.976370
 .long 0x44cfa73f  ; [327]; 0.537587
 .long 0x6bee3f62  ; [327]; 0.843208
 .long 0x9411c09f  ; [839]; -0.843208
 .long 0x44cfa73f  ; [839]; 0.537587
 .long 0x68e06129  ; [199]; 0.819348
 .long 0x4961cd32  ; [199]; 0.573297
 .long 0xb69e32cf  ; [711]; -0.573297
 .long 0x68e06129  ; [711]; 0.819348
 .long 0x16451a83  ; [455]; 0.173984
 .long 0x7e0c3d28  ; [455]; 0.984749
 .long 0x81f3c2d9  ; [967]; -0.984749
 .long 0x16451a83  ; [967]; 0.173984
 .long 0x7f15b8ed  ; [39]; 0.992850
 .long 0x0f475bff  ; [39]; 0.119365
 .long 0xf0b8a402  ; [551]; -0.119365
 .long 0x7f15b8ed  ; [551]; 0.992850
 .long 0x4f0f1125  ; [295]; 0.617647
 .long 0x64aa907e  ; [295]; 0.786455
 .long 0x9b556f83  ; [807]; -0.786455
 .long 0x4f0f1125  ; [807]; 0.617647
 .long 0x6f906d83  ; [167]; 0.871595
 .long 0x3ebfbdcc  ; [167]; 0.490226
 .long 0xc1404235  ; [679]; -0.490226
 .long 0x6f906d83  ; [679]; 0.871595
 .long 0x22847ddf  ; [423]; 0.269668
 .long 0x7b420d79  ; [423]; 0.962953
 .long 0x84bdf288  ; [935]; -0.962953
 .long 0x22847ddf  ; [935]; 0.269668
 .long 0x79a98715  ; [103]; 0.950486
 .long 0x27c737d3  ; [103]; 0.310767
 .long 0xd838c82e  ; [615]; -0.310767
 .long 0x79a98715  ; [615]; 0.950486
 .long 0x39e6975d  ; [359]; 0.452350
 .long 0x7227d61b  ; [359]; 0.891841
 .long 0x8dd829e6  ; [871]; -0.891841
 .long 0x39e6975d  ; [871]; 0.452350
 .long 0x612dc446  ; [231]; 0.759209
 .long 0x534ef1b5  ; [231]; 0.650847
 .long 0xacb10e4c  ; [743]; -0.650847
 .long 0x612dc446  ; [743]; 0.759209
 .long 0x09cecf89  ; [487]; 0.076624
 .long 0x7f9faa14  ; [487]; 0.997060
 .long 0x806055ed  ; [999]; -0.997060
 .long 0x09cecf89  ; [999]; 0.076624
 .long 0x7fae7494  ; [23]; 0.997511
 .long 0x09064b3a  ; [23]; 0.070505
 .long 0xf6f9b4c7  ; [535]; -0.070505
 .long 0x7fae7494  ; [535]; 0.997511
 .long 0x53e73097  ; [279]; 0.655493
 .long 0x60aa704f  ; [279]; 0.755201
 .long 0x9f558fb2  ; [791]; -0.755201
 .long 0x53e73097  ; [791]; 0.655493
 .long 0x72823c66  ; [151]; 0.894599
 .long 0x3932ff87  ; [151]; 0.446869
 .long 0xc6cd007a  ; [663]; -0.446869
 .long 0x72823c66  ; [663]; 0.894599
 .long 0x288621b9  ; [407]; 0.316593
 .long 0x796a7553  ; [407]; 0.948561
 .long 0x86958aae  ; [919]; -0.948561
 .long 0x288621b9  ; [919]; 0.316593
 .long 0x7b77ada7  ; [87]; 0.964590
 .long 0x21c2b69c  ; [87]; 0.263755
 .long 0xde3d4965  ; [599]; -0.263755
 .long 0x7b77ada7  ; [599]; 0.964590
 .long 0x3f6eaeb8  ; [343]; 0.495565
 .long 0x6f2d532b  ; [343]; 0.868571
 .long 0x90d2acd6  ; [855]; -0.868571
 .long 0x3f6eaeb8  ; [855]; 0.495565
 .long 0x6526438e  ; [215]; 0.790230
 .long 0x4e708f8f  ; [215]; 0.612810
 .long 0xb18f7072  ; [727]; -0.612810
 .long 0x6526438e  ; [727]; 0.790230
 .long 0x100ee8ad  ; [471]; 0.125455
 .long 0x7efd1c3b  ; [471]; 0.992099
 .long 0x8102e3c6  ; [983]; -0.992099
 .long 0x100ee8ad  ; [983]; 0.125455
 .long 0x7e2e9cde  ; [55]; 0.985798
 .long 0x157f0086  ; [55]; 0.167938
 .long 0xea80ff7b  ; [567]; -0.167938
 .long 0x7e2e9cde  ; [567]; 0.985798
 .long 0x4a062fbd  ; [311]; 0.578314
 .long 0x686c9b4a  ; [311]; 0.815814
 .long 0x979364b7  ; [823]; -0.815814
 .long 0x4a062fbd  ; [823]; 0.578314
 .long 0x6c59d0a8  ; [183]; 0.846491
 .long 0x4425c923  ; [183]; 0.532403
 .long 0xbbda36de  ; [695]; -0.532403
 .long 0x6c59d0a8  ; [695]; 0.846491
 .long 0x1c6d9053  ; [439]; 0.222094
 .long 0x7ccda168  ; [439]; 0.975025
 .long 0x83325e99  ; [951]; -0.975025
 .long 0x1c6d9053  ; [951]; 0.222094
 .long 0x7790583d  ; [119]; 0.934093
 .long 0x2db330c7  ; [119]; 0.357031
 .long 0xd24ccf3a  ; [631]; -0.357031
 .long 0x7790583d  ; [631]; 0.934093
 .long 0x343aca87  ; [375]; 0.408044
 .long 0x74dbf1ee  ; [375]; 0.912962
 .long 0x8b240e13  ; [887]; -0.912962
 .long 0x343aca87  ; [887]; 0.408044
 .long 0x5cf95637  ; [247]; 0.726359
 .long 0x57f9f2f7  ; [247]; 0.687315
 .long 0xa8060d0a  ; [759]; -0.687315
 .long 0x5cf95637  ; [759]; 0.726359
 .long 0x0388a9ea  ; [503]; 0.027608
 .long 0x7ff38273  ; [503]; 0.999619
 .long 0x800c7d8e  ; [1015]; -0.999619
 .long 0x0388a9ea  ; [1015]; 0.027608
 .long 0x7fdd4eeb  ; [15]; 0.998941
 .long 0x05e36ea9  ; [15]; 0.046003
 .long 0xfa1c9158  ; [527]; -0.046003
 .long 0x7fdd4eeb  ; [527]; 0.998941
 .long 0x56400757  ; [271]; 0.673829
 .long 0x5e93dc1e  ; [271]; 0.738887
 .long 0xa16c23e3  ; [783]; -0.738887
 .long 0x56400757  ; [783]; 0.673829
 .long 0x73e0c3a2  ; [143]; 0.905297
 .long 0x365f2e3b  ; [143]; 0.424780
 .long 0xc9a0d1c6  ; [655]; -0.424780
 .long 0x73e0c3a2  ; [655]; 0.905297
 .long 0x2b7dcf17  ; [399]; 0.339777
 .long 0x786280bf  ; [399]; 0.940506
 .long 0x879d7f42  ; [911]; -0.940506
 .long 0x2b7dcf17  ; [911]; 0.339777
 .long 0x7c4242f1  ; [79]; 0.970772
 .long 0x1eb86b46  ; [79]; 0.240003
 .long 0xe14794bb  ; [591]; -0.240003
 .long 0x7c4242f1  ; [591]; 0.970772
 .long 0x42244480  ; [335]; 0.516732
 .long 0x6d963c53  ; [335]; 0.856147
 .long 0x9269c3ae  ; [847]; -0.856147
 .long 0x42244480  ; [847]; 0.516732
 .long 0x670b4443  ; [207]; 0.805031
 .long 0x4bef092c  ; [207]; 0.593232
 .long 0xb410f6d5  ; [719]; -0.593232
 .long 0x670b4443  ; [719]; 0.805031
 .long 0x132b7bf9  ; [463]; 0.149765
 .long 0x7e8e6eb1  ; [463]; 0.988722
 .long 0x81719150  ; [975]; -0.988722
 .long 0x132b7bf9  ; [975]; 0.149765
 .long 0x7eabef2b  ; [47]; 0.989622
 .long 0x1264994e  ; [47]; 0.143695
 .long 0xed9b66b3  ; [559]; -0.143695
 .long 0x7eabef2b  ; [559]; 0.989622
 .long 0x4c9087b1  ; [303]; 0.598161
 .long 0x66937e90  ; [303]; 0.801376
 .long 0x996c8171  ; [815]; -0.801376
 .long 0x4c9087b1  ; [815]; 0.598161
 .long 0x6dfd9a1b  ; [175]; 0.859302
 .long 0x4177cfb0  ; [175]; 0.511469
 .long 0xbe883051  ; [687]; -0.511469
 .long 0x6dfd9a1b  ; [687]; 0.859302
 .long 0x1f7b7480  ; [431]; 0.245955
 .long 0x7c116852  ; [431]; 0.969281
 .long 0x83ee97af  ; [943]; -0.969281
 .long 0x1f7b7480  ; [943]; 0.245955
 .long 0x78a63d10  ; [111]; 0.942573
 .long 0x2ac08026  ; [111]; 0.334000
 .long 0xd53f7fdb  ; [623]; -0.334000
 .long 0x78a63d10  ; [623]; 0.942573
 .long 0x3714f02a  ; [367]; 0.430326
 .long 0x738acc9d  ; [367]; 0.902673
 .long 0x8c753364  ; [879]; -0.902673
 .long 0x3714f02a  ; [879]; 0.430326
 .long 0x5f1ae273  ; [239]; 0.743008
 .long 0x55ab0d46  ; [239]; 0.669283
 .long 0xaa54f2bb  ; [751]; -0.669283
 .long 0x5f1ae273  ; [751]; 0.743008
 .long 0x06ac406f  ; [495]; 0.052132
 .long 0x7fd37152  ; [495]; 0.998640
 .long 0x802c8eaf  ; [1007]; -0.998640
 .long 0x06ac406f  ; [1007]; 0.052132
 .long 0x7f6be9d3  ; [31]; 0.995481
 .long 0x0c27c389  ; [31]; 0.094963
 .long 0xf3d83c78  ; [543]; -0.094963
 .long 0x7f6be9d3  ; [543]; 0.995481
 .long 0x518169a4  ; [287]; 0.636762
 .long 0x62b21c7b  ; [287]; 0.771061
 .long 0x9d4de386  ; [799]; -0.771061
 .long 0x518169a4  ; [799]; 0.636762
 .long 0x71120cc4  ; [159]; 0.883363
 .long 0x3bfdfecd  ; [159]; 0.468689
 .long 0xc4020134  ; [671]; -0.468689
 .long 0x71120cc4  ; [671]; 0.883363
 .long 0x2588349d  ; [415]; 0.293219
 .long 0x7a5fb0d7  ; [415]; 0.956045
 .long 0x85a04f2a  ; [927]; -0.956045
 .long 0x2588349d  ; [927]; 0.293219
 .long 0x7a9a0e4f  ; [95]; 0.957826
 .long 0x24c7cd32  ; [95]; 0.287347
 .long 0xdb3832cf  ; [607]; -0.287347
 .long 0x7a9a0e4f  ; [607]; 0.957826
 .long 0x3caf50da  ; [351]; 0.474100
 .long 0x70b34524  ; [351]; 0.880471
 .long 0x8f4cbadd  ; [863]; -0.880471
 .long 0x3caf50da  ; [863]; 0.474100
 .long 0x6331a9d4  ; [223]; 0.774953
 .long 0x50e5fd6c  ; [223]; 0.632019
 .long 0xaf1a0295  ; [735]; -0.632019
 .long 0x6331a9d4  ; [735]; 0.774953
 .long 0x0cefdb75  ; [479]; 0.101070
 .long 0x7f5834b6  ; [479]; 0.994879
 .long 0x80a7cb4b  ; [991]; -0.994879
 .long 0x0cefdb75  ; [991]; 0.101070
 .long 0x7d9dd559  ; [63]; 0.981379
 .long 0x18961728  ; [63]; 0.192080
 .long 0xe769e8d9  ; [575]; -0.192080
 .long 0x7d9dd559  ; [575]; 0.981379
 .long 0x47706d93  ; [319]; 0.558119
 .long 0x6a359db8  ; [319]; 0.829761
 .long 0x95ca6249  ; [831]; -0.829761
 .long 0x47706d93  ; [831]; 0.558119
 .long 0x6aa551e8  ; [191]; 0.833170
 .long 0x46c9405c  ; [191]; 0.553017
 .long 0xb936bfa5  ; [703]; -0.553017
 .long 0x6aa551e8  ; [703]; 0.833170
 .long 0x195b49ea  ; [447]; 0.198098
 .long 0x7d769bb4  ; [447]; 0.980182
 .long 0x8289644d  ; [959]; -0.980182
 .long 0x195b49ea  ; [959]; 0.198098
 .long 0x76680375  ; [127]; 0.925049
 .long 0x309ed556  ; [127]; 0.379847
 .long 0xcf612aab  ; [639]; -0.379847
 .long 0x76680375  ; [639]; 0.925049
 .long 0x3158970d  ; [383]; 0.385516
 .long 0x761b1210  ; [383]; 0.922701
 .long 0x89e4edf1  ; [895]; -0.922701
 .long 0x3158970d  ; [895]; 0.385516
 .long 0x5ac973b4  ; [255]; 0.709273
 .long 0x5a3b47aa  ; [255]; 0.704934
 .long 0xa5c4b857  ; [767]; -0.704934
 .long 0x5ac973b4  ; [767]; 0.709273
 .long 0x006487e3  ; [511]; 0.003068
 .long 0x7fffd885  ; [511]; 0.999995
 .long 0x8000277c  ; [1023]; -0.999995
 .long 0x006487e3  ; [1023]; 0.003068
 
  	.global _twiddle

unpack.asm/     1362765892  0     0     0       8756      `
;/*
; * Copyright (C) 2013 Texas Instruments Incorporated - http://www.ti.com/ 
; * 
; * 
; *  Redistribution and use in source and binary forms, with or without 
; *  modification, are permitted provided that the following conditions 
; *  are met:
; *
; *    Redistributions of source code must retain the above copyright 
; *    notice, this list of conditions and the following disclaimer.
; *
; *    Redistributions in binary form must reproduce the above copyright
; *    notice, this list of conditions and the following disclaimer in the 
; *    documentation and/or other materials provided with the   
; *    distribution.
; *
; *    Neither the name of Texas Instruments Incorporated nor the names of
; *    its contributors may be used to endorse or promote products derived
; *    from this software without specific prior written permission.
; *
; *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
; *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
; *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
; *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
; *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
; *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
; *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
; *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
; *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
; *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
; *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
; *
;*/

;***********************************************************
; Version 3.00.00                                           
;***********************************************************
; Function UNPACK
; Processor:   C55xx
; Decription: Unpacks the output of a Radix-2 DIF complex FFT using bit-reversed input 
;    data and bit-reversed twiddle table (length N/2, cosine/sine format).
;
; Usage:  void unpack(DATA *x, ushort nx);
;
; Limitations:
;   x[] must be aligned on a 32-bit boundary
;   nx must be a power of 2
;   16 <= nx <= 2048
;
; Benchmarks:
;   Cycles:
;     nx =  16:    89
;     nx =  32:   167
;     nx =  64:   319
;     nx = 128:   623
;     nx = 256:  1231
;     nx = 512:  2447
;     nx =1024:  4884
;   Code Size (in bytes):
;     .text            141
;     .const:twiddle  2048 (shared by cfft, cifft, unpack, unpacki)
;
; History;
;	- 07/17/2003	C. Iovescu changed the way the twiddle table is included
;	- 05/26/2012	Craig Leeds: 
;           - Fixed stack alignment bug putting T3 at risk
;           - optimized by 40%
;                                  
;****************************************************************

                .mmregs
                .cpl_on
                .arms_off
                .ref twiddle

;//-----------------------------------------------------------------------------
;// Program section
;//-----------------------------------------------------------------------------

                .global _unpack

                .text
_unpack:

;//-----------------------------------------------------------------------------
;// Context save / get arguments
;//-----------------------------------------------------------------------------
        PSH        T3, T2
;//-----------------------------------------------------------------------------
;// Initialization code
;//-----------------------------------------------------------------------------
     || BSET        FRCT, ST1_55            ; set FRCT
        BSET        SATD, ST1_55            ; set SATD
        BCLR        ARMS, ST2_55            ; reset ARMS
;//-----------------------------------------------------------------------------
;// Unpack for RFFT
;//-----------------------------------------------------------------------------
        MOV         XAR0, XAR1              ; AR1 = pointer to input data = rm[0]
        ADD         T0, AR1                 ; AR1 = pointer to input data = rm[N]
        SFTS        T0, #-1                 ; T0 = RFFT size/2 (req. for loop)
        MOV         T0, T1                  ; T1 = T0 = RFFT size/2
        SFTS        T1, #-1                 ; T1 = RFFT size/4 (req. for loop)
        SUB         #2, AR1                 ; element in the data buffer
        SUB         #2, T1                  ; loop = N/4 - 2
        MOV         T1, BRC0                ; and store in repeat counter
        MOV         #-1, T2
        AMOV        #twiddle, XAR2          ; pointer to sin and cos tables
        AMOV        #(twiddle+1), XAR3      ; 
        AMAR        *(AR2+T0B)              ; set to 2nd entry of bit reversed
        AMAR        *(AR3+T0B)              ; sin/cos table 
;--------------------------------------------------------------------------------
; process yre[0] (DC) and yre[0] (Nyquist)
; yre[0] = xre[0] + xim[0]    store in yre[0] 
; yre[N] = xre[0] - xim[0]    store in yim[0]
;
;Scaling by 2 added to avoid overflow
;--------------------------------------------------------------------------------
        MOV         *AR0+ << #16, AC1            ; AC1=xre[0]
        ADD         *AR0 << #16, AC1, AC0        ; AC0 = xre[0] + xim[0]
        SUB         *AR0- << #16, AC1, AC1       ; AC1 = xre[0] - xim[0]
        MOV         HI(AC0 << T2), *AR0+         ; yre[0]=0.5*xre[0]+xim[0]
        MOV         HI(AC1 << T2), *AR0+         ; yim[0]=0.5*xre[0]-xim[0]
;--------------------------------------------------------------------------------
; process y1re[1]/im[1] ...
;
;Scaling by 2 added to avoid overflow
;--------------------------------------------------------------------------------
        RPTBLOCAL   unpackLoopEnd-1              ; setup loopcounter (RFFT-size)/4 - 2
               ADD         *AR0, *AR1, AC0       ; rp = AC0 = x1Re + x2Re
               SUB         *AR0+, *AR1+, AC3     ; im = AC3 = x1Re - x2Re
            || SFTS        AC0, #-1              ; rp = 0.5*AC0 = 0.5*(x1Re+x2Re)
               SUB         *AR1, *AR0, AC1       ; ip = AC1 = x2Im - x1Im
            || SFTS        AC3, #-1              ; im = 0.5*AC3 = 0.5*(x1Re-x2Re)
               ADD         *AR0-, *AR1, AC2      ; rm = AC2 = x1Im + x2Im
            || SFTS        AC1, #-1              ; ip = 0.5*AC1 = 0.5*(x2Im-x1Im)
               SFTS        AC2, #-1              ; rm = 0.5*AC2 = 0.5*(x1Im+x2Im)
            || MOV         HI(AC3), T3           ; save im to T3
               MOV         HI(AC2), T1           ; save rm to T1
;-----------------------------------------------------------------------
               MASM        *AR2, T1, AC0, AC2    ; y2re=AC2=rp-cos*rm
               MASM        *AR2, T3, AC1, AC3    ; y2im=AC3=ip-cos*im
               MACM        *AR2, T1, AC0, AC0    ; y1re=AC0=rp+cos*rm
            || NEG         AC1, AC1
               MASM        *(AR2+T0B), T3, AC1, AC1  ; y1im=AC1=-ip-cos*im
;-----------------------------------------------------------------------
               ; y1re=rp+cos*rm-sin*im
               MASM        *AR3, T3, AC0, AC0        
               ; y1im=-ip-cos*im-sin*rm
               MASM        *AR3, T1, AC1, AC1 
            :: MOV         HI(AC0<<T2), *AR0+        
               ; y2re=rp-cos*rm+sin*im
               MACM        *AR3, T3, AC2, AC2 
            :: MOV         HI(AC1<<T2), *AR0+       
               ; y2im=ip-cos*im-sin*rm
               MASM        *(AR3+T0B), T1, AC3, AC3 
               MOV         HI(AC3<<T2), *AR1-       
               MOV         HI(AC2<<T2), *AR1       
            || ASUB        #2, AR1
unpackLoopEnd:
;//-----------------------------------------------------------------------------
;       yre(N/2) = yre(N/2)
;       yim(N/2) = - yim(N/2)
;
;  Scaling by 2 added to avoid overflow
;//-----------------------------------------------------------------------------
        MOV         dbl(*AR0), pair(HI(AC0))
        NEG         AC1, AC1
        SFTS        AC0, #-1
        SFTS        AC1, #-1
     || BCLR       SATD, ST1_55              ; restore SATD for C
        MOV         pair(HI(AC0)), dbl(*AR0)
;//-----------------------------------------------------------------------------
;// Context restore and Return
;//-----------------------------------------------------------------------------
        POP        T3, T2
     || BSET       ARMS, ST2_55              ; restore ARMS for C
        BCLR       FRCT, ST1_55              ; restore FRCT for C
     || RET

        .end
unpack32.asm/   1362765892  0     0     0       19515     `
;/*
; * Copyright (C) 2013 Texas Instruments Incorporated - http://www.ti.com/ 
; * 
; * 
; *  Redistribution and use in source and binary forms, with or without 
; *  modification, are permitted provided that the following conditions 
; *  are met:
; *
; *    Redistributions of source code must retain the above copyright 
; *    notice, this list of conditions and the following disclaimer.
; *
; *    Redistributions in binary form must reproduce the above copyright
; *    notice, this list of conditions and the following disclaimer in the 
; *    documentation and/or other materials provided with the   
; *    distribution.
; *
; *    Neither the name of Texas Instruments Incorporated nor the names of
; *    its contributors may be used to endorse or promote products derived
; *    from this software without specific prior written permission.
; *
; *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
; *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
; *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
; *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
; *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
; *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
; *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
; *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
; *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
; *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
; *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
; *
;*/

;***********************************************************
; Version 3.00.00                                           
;***********************************************************
; Function UNPACK32
; Processor:   C55xx
; Decription: Unpacks the output of a Radix-2 DIF complex FFT using bit-reversed input 
;    data and bit-reversed twiddle table (length N/2, cosine/sine format).
;
; Usage:  void unpack32(LDATA *x, ushort nx);
;
; Limitations:
;   nx must be a power of 2 between 16 and 1024
;
; Benchmarks:
;   Cycles:
;     nx =  16:    196
;     nx =  32:    403
;     nx =  64:    819
;     nx = 128:   1651
;     nx = 256:   3316
;     nx = 512:   6644
;     nx =1024:  13300
;   Code Size (in bytes):  
;     .text              262
;     .const:twiddle32  4096 (shared by cfft32, cifft32, unpack32, unpacki32)
;
; History;
;	- 11/20/2003	C. Iovescu initial implementation
;	- 06/16/2012	Craig Leeds: Optimized
;
;************************************************************************************
;
;  DFT of N-point real-valued sequence
;
; Implementation of the rfft based on the equations:
;
;   
;
;  g(n) n=0:N-1 is a real valued sequence. Purpose of the code
;  is to compute the RFFT of this signal: G(k) k=0:N-1 complex sequence. 
;
;  g(n) is split in two real sequences, odd and even part
;    
;          xe(n) = g(2n)    n=0:N/2-1
;          xo(n) = g(2n+1)  n=0:N/2-1
;
;  Form the complex sequence:
;
;         x(n) = xe(n) + jxo(n)  n=0:N/2-1
;
;  Compute the CFFT of x(n):
;
;        X(k) k=0:N/2-1
;
;  Derive from X(k) the CFFT of xe(n) and xo(n) using the equations
;
;       Xe(k) =  0.5  (X(k) + X*(N/2-k))   k=0:N/2-1  (1)
;       Xo(k) = -0.5j (X(k) - X*(N/2-k))   k=0:N/2-1  (2)
;
;  Separate in Real and Imag parts: 
;
;   Define: 
;            Xe(k) =  Xer(k)+jXei(k)
;            Xo(k) =  Xor(k)+jXoi(k)
;
;   Equations (1) and (2) yield:
;
;       Xer(k) =  0.5  (Xr(k) + Xr(N/2-k))   k=0:N/2-1  (3)
;       Xei(k) =  0.5  (Xi(k) - Xi(N/2-k))   k=0:N/2-1  (4)
;       Xor(k) =  0.5  (Xi(k) + Xi(N/2-k))   k=0:N/2-1  (5)
;       Xoi(k) = -0.5  (Xr(k) - Xr(N/2-k))   k=0:N/2-1  (6)
;
;   The previous equations have special values for:
;
;   DC Offset: 
;             k=0     Xer(0)= Xr(0)
;                     Xei(0)= 0
;                     Xor(0)= Xi(0)
;                     Xoi(0)= 0
;
;
;   Nyquist Frequency:
;             k=N/4   Xer(N/4)= Xr(N/4)
;                     Xei(N/4)= 0
;                     Xor(N/4)= Xi(N/4)
;                     Xoi(N/4)= 0
;
;
;    Computing G(k)
;
;    G(k)   = Xe(k) + W(k,N)Xo(k)     k = 0:N/2-1   (7)
;    G(N/2-k) = Xe*(k) - W(-k,N)Xo*(k)  k = 0:N/2-1   (8)
;
;  Separate in Real and Imag parts: 
;
;   Define: 
;            G(k) =  Gr(k)+jGi(k)
;            G(N-k) =  Gr(N-k)+jGi(N-k)
;            W(k,N) = cos(2Pik/N)-jsin(2Pik/N) = Wr(k)-jWi(k)
;
;   Equations (7) and (8) yield:
;
;          Gr(k)     = Xer(k) + Wr(k)Xor(k)+Wi(k)Xoi(k)   (9)
;          Gi(k)     = Xei(k) + Wr(k)Xoi(k)-Wi(k)Xor(k)   (10)
;          Gr(N/2-k) = Xer(k) - Wr(k)Xor(k)-Wi(k)Xoi(k)   (11)
;          Gi(N/2-k) =-Xei(k) + Wr(k)Xoi(k)-Wi(k)Xor(k)   (12)
;
;
;  Equations (9) through (12) will be DIVIDED BY TWO in order to avoid
;  overflow.
;
;          Gr(k)     = 0.5[Xer(k) + Wr(k)Xor(k)+Wi(k)Xoi(k)]   (13)
;          Gi(k)     = 0.5[Xei(k) + Wr(k)Xoi(k)-Wi(k)Xor(k)]   (14)
;          Gr(N/2-k) = 0.5[Xer(k) - Wr(k)Xor(k)-Wi(k)Xoi(k)]   (15)
;          Gi(N/2-k) =0.5[-Xei(k) + Wr(k)Xoi(k)-Wi(k)Xor(k)]   (16)
;
;  Special values:
;        
;     * DC Offset  k = 0                                    (17)
;
;           Gr(0) = 0.5 (Xr(0)+Xi(0)) 
;           Gi(0) = 0
;
;     * k = N/4                                             (18)
;
;           Gr(N/4) = 0.5 Xr(N/4) 
;           Gi(N/4) =-0.5 Xi(N/4)
;
;     * Nyquist Frequency  k = N/2                          (19)
;
;           Gr(N/2) = 0.5 (Xr(0)-Xi(0)) 
;           Gi(N/2) = 0
;
;
;  Practical computation of G(k) k=0:N-1
;      
;      1) Compute G(k) k=0:N/2
;             - G(0),G(N/4), G(N/2) based on special values formulae
;             - G(k) for   (0<k<N/2)
;      2) Deduct G(k) k=N/2+1:N-1 from the values computed in 1) using
;      the complex conjugate symmetry formulae (since g(n) is a real
;      sequence) 
;                   
;              G(k) = G*(N-k)  k=0:N-1
;
;  Algorithm implementation:
;    
;
;     The algorithm computes only G(k) k=0:N/2. In order to store the
;     result in the input array, G(0) and G(N/2) which have zero imag parts are
;     packed together and Gr(N/2) is stored at the location of Gi(0).
;
;        1) Compute Xer(k), Xei(k), Xor(k), Xoi(k) for k=1:N/4-1
;               ( k=0 and k=N/4 are special values)
;
;  
;
;

;****************************************************************

                .mmregs
                .cpl_on
                .arms_off
                .ref twiddle32

;//-----------------------------------------------------------------------------
;// Program section
;//-----------------------------------------------------------------------------

                .global _unpack32
                .text
_unpack32:

;//-----------------------------------------------------------------------------
;// Context save / get arguments
;//-----------------------------------------------------------------------------
  
; upon entry stack aligned on 32-bit boundary
  
        AADD    #-21,SP             ; create local frame
          
;//-----------------------------------------------------------------------------
;// Initialization code
;//-----------------------------------------------------------------------------

     || BSET    FRCT,ST1_55              ; set FRCT
        BCLR    ARMS,ST2_55              ; reset ARMS

;//-----------------------------------------------------------------------------
;// Unpack for RFFT
;//
;//  T0 = N (Rfft size) 
;//
;//
;//
;//-----------------------------------------------------------------------------
        MOV     XAR0,XAR1               ; AR0 = start ptr input data = Xr[0]
        ADD     T0,AR1                  ; AR1 = end ptr input data 
        ADD     T0,AR1                  ; 32-bit data 
        MOV     T0,T1                   ; T1 = T0 = RFFT size/2
        SFTS    T1,#-1                  ; T1 = RFFT size/2 
        SFTS    T1,#-1                  ; T1 = RFFT size/4 (req. for loop)
        SUB     #4,AR1                  ; AR1 = Xr[N/2-1] - last 32-bit elt
        SUB     #2,T1                   ; loop = N/4 - 2
        MOV     T1,BRC0                 ; and store in repeat counter
        AMOV    #twiddle32,XAR2         ; pointer to sin and cos tables
        AMOV    #(twiddle32+2),XAR3     ; 32-bit values (add 2)
        AMAR    *(AR2+T0B)              ; set to 2nd entry of bit reversed
        AMAR    *(AR3+T0B)              ; sin/cos table 
                                        ; T0 = RFFT size for bitrev because 32-bit values
        MOV     XSP,XAR4                ; XAR4 local var ptr (stack)
        ADD     #4, AR4                 ; AR4 = &SP(4)

;--------------------------------------------------------------------------------
; Step1: 
;  Special values G(0) and G(N/2):
;        
;     * DC Offset  k = 0                                    
;
;           Gr(0) = 0.5 (Xr(0)+Xi(0)) 
;           Gi(0) = 0
;
;
;     * Nyquist Frequency  k = N/2                          
;
;           Gr(N/2) = 0.5 (Xr(0)-Xi(0)) 
;           Gi(N/2) = 0
;
;     In order to store G(k) in the input array, Gr(0) and Gr(N/2) 
;     are packed as real&imag values.
;
;--------------------------------------------------------------------------------
        MOV     dbl(*AR0+),AC1           ; AC1 = Xr[0]
        ADD     dbl(*AR0),AC1,AC0        ; AC0 = Xr[0] + Xi[0]                                                                                                       
        SUB     dbl(*AR0-),AC1,AC1       ; AC1 = Xr[0] - Xi[0]
       
     || SFTS    AC0, #-1                 ; 0.5x
        SFTS    AC1, #-1                 ; 0.5x
                      
     || MOV     AC0, dbl(*AR0+)          ; Gr(0)
        MOV     AC1, dbl(*AR0+)          ; Gr(N/2)
        MOV     #6, T1                   ; T1 = 6 (for AR1 adjustment)
;--------------------------------------------------------------------------------
; Step 2: 
;
; General loop G(k) k=1:N/2-1  (k<>N/4)
;
;    Xer(k) =  0.5  (Xr(k) + Xr(N/2-k))  k=1:N/4-1  
;    Xei(k) =  0.5  (Xi(k) - Xi(N/2-k))  k=1:N/4-1 
;    Xor(k) =  0.5  (Xi(k) + Xi(N/2-k))  k=1:N/4-1  
;    Xoi(k) = -0.5  (Xr(k) - Xr(N/2-k))  k=1:N/4-1  
;
;--------------------------------------------------------------------------------
     || RPTB    unpack_end-1              ; setup loopcounter (RFFT-size)/4 - 2

                MOV     dbl(*AR1+),AC1          ; AC1= Xr[N/2-k]                                                                                    
             || ADD     #1, AR2
                ADD     dbl(*AR0),AC1,AC0       ; Xer = AC0 =   Xr[k] + Xr[N/2-k]  
                SUB     dbl(*AR0+),AC1,AC3      ; Xoi = AC3 = -(Xr[k] - Xr[N/2-k])
             || SFTS    AC0,#-1                 ; Xer = 0.5*AC0
                    
                MOV     dbl(*AR0-),AC2          ; AC2 = Xi[k]                 
             || SFTS    AC3,#-1                 ; Xoi = 0.5*AC3
                SUB     dbl(*AR1), AC2, AC1            ; Xei = AC1 =  Xi[k] - Xi[N/2-k]             
                ADD     dbl(*AR1-),AC2,AC2      ; Xor = AC2 =  Xi[k] + Xi[N/2-k]
             || SFTS    AC1,#-1                 ; Xei = 0.5*AC1 

                                               
                MOV     AC0 ,dbl(*SP(#00h))     ; save Xer
             || SFTS    AC2,#-1                 ; Xor = 0.5*AC2
                MOV     AC1 ,dbl(*SP(#02h))     ; save Xei            
                MOV     AC2 ,dbl(*SP(#04h))     ; save Xor
                MOV     AC3 ,dbl(*SP(#06h))     ; save Xoi
            
;-----------------------------------------------------------------------
;
;   Output N-point RFFT
;
;    Gr(k)     = 0.5[ Xer(k) + Wr(k)Xor(k)+Wi(k)Xoi(k)]   
;    Gi(k)     = 0.5[ Xei(k) + Wr(k)Xoi(k)-Wi(k)Xor(k)]   
;    Gr(N/2-k) = 0.5[ Xer(k) - Wr(k)Xor(k)-Wi(k)Xoi(k)]   
;    Gi(N/2-k) = 0.5[-Xei(k) + Wr(k)Xoi(k)-Wi(k)Xor(k)]  
;
;    Wr(k)     = cos(2Pik/N)
;    Wi(k)     = sin(2Pik/N)
;
;--------------------------------------------------------------------------------


             ; Wr(k)Xor(k)
                        
                         ;  AR2 -> cos_H
                         ;                   cos_L
                         ; 
                         ;  AR4 -> Xor_H
                         ;               Xor_L
                         ;
                         
                MPYM    uns(*AR2-), *AR4+, AC0        ; AC0 = cos_L*Xor_H

                MACM    *AR2, uns(*AR4-), AC0         ; AC0 = AC0 + cos_H*Xor_L
                MACM    *AR2+, *AR4, AC0 >> #16, AC0  ; AC0 = AC0>>16 + cos_H*Xor_H 
                MOV     AC0 ,dbl(*SP(#08h))           ; save cos*Xor

             ; Wi(k)Xor(k)
                        
                         ;  AR3 -> sin_H
                         ;               sin_L
                         ; 
                         ;  AR4 -> Xor_H
                         ;               Xor_L
                         ;
                         
             || AADD    #1, AR3
                MPYM    uns(*AR3-), *AR4+, AC0        ; AC0 = sin_L*Xor_H
                MACM    *AR3, uns(*AR4-), AC0         ; AC0 = AC0 + sin_H*Xor_L
                MACM    *AR3+, *AR4+, AC0 >> #16, AC0 ; AC0 = AC0>>16 + sin_H*Xor_H 
                MOV     AC0 ,dbl(*SP(#0Ah))           ; save sin*Xor
             || AADD    #1, AR4
                         
             ; Wr(k)Xoi(k)
                        
                         ;         cos_H
                         ;        AR2 -> cos_L
                         ; 
                         ;  AR4 -> Xoi_H
                         ;               Xoi_L
                         ;
                         
                MPYM    uns(*AR2-), *AR4+, AC0        ; AC0 = cos_L*Xoi_H
                MACM    *AR2, uns(*AR4-), AC0         ; AC0 = AC0 + cos_H*Xoi_L
                MACM    *AR2, *AR4, AC0 >> #16, AC0   ; AC0 = AC0>>16 + cos_H*Xoi_H 
                MOV     AC0 ,dbl(*SP(#0Ch))           ; save cos*Xoi
             
              ; Wi(k)Xoi(k)
                        
                         ;         sin_H
                         ;        AR3 -> sin_L
                         ; 
                         ;  AR4 -> Xoi_H
                         ;               Xoi_L
                         ;
            
                MPYM    uns(*AR3-), *AR4+, AC0        ; AC0 = sin_L*Xoi_H
                MACM    *AR3, uns(*AR4-), AC0         ; AC0 = AC0 + sin_H*Xoi_L
                MACM    *AR3, *AR4, AC0 >> #16, AC0   ; AC0 = AC0>>16 + sin_H*Xoi_H 
                MOV     AC0 ,dbl(*SP(#0Eh))           ; save sin*Xoi
          
                  ; update AR4, local var pointer for next loop iteration 
             || SUB     #2, AR4
            
            ; update the sin/cos pointers
            ; bit-reversed addressing used because twiddle table 
            ; is in bit-reversed format and normal format is needed
            ; in this algorithm.
            
         ;   !!!this requires special alignement of twiddle table ??

                  ;  AR2 -> cos_H
                         ;               cos_L         
                  ;  AR3 -> sin_H
                         ;               sin_L
         
            
;    Gr(k)     = 0.5[ Xer(k) + Wr(k)Xor(k)+Wi(k)Xoi(k)]            
                                                                                                  
                MOV     dbl(*SP(#00h)),AC0       ; AC0 = Xer(k)                                                                                     
                ADD     dbl(*SP(#08h)),AC0,AC1   ; AC1 = Xer(k)+Wr(k)Xor(k)                                                                                                       
                ADD     dbl(*SP(#0Eh)),AC1,AC1   ; AC1 = Xer(k)+Wr(k)Xor(k)+Wi(k)Xoi(k)
                SFTS    AC1, #-1                 ; 0.5x
             || AMAR    *(AR2+T0B)      ; cos
                MOV     AC1, dbl(*AR0+)          ; Gr(k)
                                                                                                                   
;    Gi(k)     = 0.5[ Xei(k) + Wr(k)Xoi(k)-Wi(k)Xor(k)]                                                                                                                                                            
            
                MOV     dbl(*SP(#02h)),AC1       ; AC1 = Xei(k) 
                ADD     dbl(*SP(#0Ch)),AC1,AC2   ; AC2 = Xei(k)+ Wr(k)Xoi(k)  
                SUB     dbl(*SP(#0Ah)),AC2,AC2   ; AC2 = Xei(k)+ Wr(k)Xoi(k)-Wi(k)Xor(k)  
                SFTS    AC2, #-1                 ; 0.5x    
             || AMAR    *(AR3+T0B)      ; sin
                MOV     AC2, dbl(*AR0+)          ; Gi(k)
                 
;    Gr(N/2-k) = 0.5[ Xer(k) - Wr(k)Xor(k)-Wi(k)Xoi(k)]                
             
                MOV     dbl(*SP(#00h)),AC1       ; AC1 = Xer(k) 
                SUB     dbl(*SP(#08h)),AC1,AC2   ; AC2 = Xer(k)- Wr(k)Xor(k)  
                SUB     dbl(*SP(#0Eh)),AC2,AC2   ; AC2 = Xer(k)- Wr(k)Xor(k)-Wi(k)Xoi(k)  
             
;    Gi(N/2-k) = 0.5[-Xei(k) + Wr(k)Xoi(k)-Wi(k)Xor(k)]                
             
                MOV     dbl(*SP(#0Ch)),AC1       ; AC1 = Wr(k)Xoi(k) 
             || SFTS    AC2, #-1                 ; 0.5x    
                MOV     AC2, dbl(*AR1+)          ; Gr(N/2-k)            
                SUB     dbl(*SP(#02h)),AC1,AC2   ; AC2 = -Xei(k)+ Wr(k)Xoi(k)  
                SUB     dbl(*SP(#0Ah)),AC2,AC2   ; AC2 = -Xei(k)+ Wr(k)Xoi(k)-Wi(k)Xor(k)  
                SFTS    AC2, #-1                 ; 0.5x    
                MOV     AC2, dbl(*(AR1-T1))      ; Gi(N/2-k)   ; adjust to Gr(N/2-k-1)          
unpack_end:

;--------------------------------------------------------------------------------
; Step3: 
;  Special values G(N/4):
;
;           Gr(N/4) = 0.5 Xr(N/4) 
;           Gi(N/4) =-0.5 Xi(N/4)
;
;//-----------------------------------------------------------------------------
        MOV     dbl(*AR0+),AC0              ; Xr(N/4)
        MOV     dbl(*AR0-) ,AC1             ; Xi(N/4)          
     || SFTS    AC0,#-1                     ; 0.5*Xr(N/4)           
        NEG     AC1,AC1                     ;-Xi(N/4)
        SFTS    AC1,#-1                      ;-0.5*Xi(N/4)          
     || MOV     AC0 ,dbl(*AR0+)             ;Gr(N/4) = 0.5 Xr(N/4)
        MOV     AC1 ,dbl(*AR0+)             ;Gi(N/4) =-0.5 Xi(N/4)        
                     
;//-----------------------------------------------------------------------------
;// Context restore
;//-----------------------------------------------------------------------------
        AADD    #+21,SP                     ; destroy local frame
;//-----------------------------------------------------------------------------
;// Return
;//-----------------------------------------------------------------------------
     || BCLR    FRCT,ST1_55                 ; set FRCT
        BSET    ARMS,ST2_55                 ; reset ARMS
     || RET

        .end

unpacki.asm/    1362765892  0     0     0       8587      `
;/*
; * Copyright (C) 2013 Texas Instruments Incorporated - http://www.ti.com/ 
; * 
; * 
; *  Redistribution and use in source and binary forms, with or without 
; *  modification, are permitted provided that the following conditions 
; *  are met:
; *
; *    Redistributions of source code must retain the above copyright 
; *    notice, this list of conditions and the following disclaimer.
; *
; *    Redistributions in binary form must reproduce the above copyright
; *    notice, this list of conditions and the following disclaimer in the 
; *    documentation and/or other materials provided with the   
; *    distribution.
; *
; *    Neither the name of Texas Instruments Incorporated nor the names of
; *    its contributors may be used to endorse or promote products derived
; *    from this software without specific prior written permission.
; *
; *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
; *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
; *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
; *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
; *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
; *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
; *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
; *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
; *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
; *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
; *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
; *
;*/

;***********************************************************
; Version 3.00.00                                           
;***********************************************************
; Function UNPACK
; Processor:   C55xx
; Decription: Unpacks the output of a Radix-2 DIF complex IFFT using bit-reversed input data
;    and bit-reversed twiddle table (length N/2, cosine/sine format)
;
; Usage:  void unpacki(DATA *x, ushort nx);
;
; Benchmarks:
;   Cycles:
;     (5 * nx) + 13
;        nx =  16:     93
;        nx =  32:    173
;        nx =  64:    333
;        nx = 128:    653
;        nx = 256:   1293
;        nx = 512:   2573
;        nx =1024:   5133
;   Code Size (in bytes):  
;     .text            145
;     .const:twiddle  2048 (shared by cfft, cifft, unpack, unpacki)
;
; History;
;	- 07/17/2003	C. Iovescu changed the way the twiddle table is included
;	- 05/26/2012	Craig Leeds: 
;           - Fixed stack alignment bug putting T3 at risk
;           - optimized by 40%
;****************************************************************

            .mmregs
            .cpl_on
            .arms_off
            .ref twiddle

;//-----------------------------------------------------------------------------
;// Program section
;//-----------------------------------------------------------------------------

            .global _unpacki
            .text
_unpacki:

;//-----------------------------------------------------------------------------
;// Context save / get arguments
;//-----------------------------------------------------------------------------
        PSH        T3, T2

;//-----------------------------------------------------------------------------
;// Initialization code
;//-----------------------------------------------------------------------------

     || BSET    FRCT, ST1_55            ; set FRCT
        BSET    M40, ST1_55             ; set M40
        BCLR    ARMS, ST2_55            ; reset ARMS
        
;//-----------------------------------------------------------------------------
;// Unpack for IRFFT
;//-----------------------------------------------------------------------------
        MOV     XAR0,XAR1               ; AR1 = pointer to input data = rm[0]
        ADD     T0,AR1                  ; AR1 = pointer to input data = rm[N]
        SFTS    T0,#-1                  ; T0 = RFFT size/2 (req. for loop)
        MOV     T0,T1                   ; T1 = T0 = RFFT size/2
        SFTS    T1,#-1                  ; T1 = RFFT size/4 (req. for loop)
        SUB     #2,AR1                  ; element in the data buffer
        SUB     #2,T1                   ; loop = N/4 - 2
        MOV     T1,BRC0                 ; and store in repeat counter 
        MOV     #-1,T2
        AMOV    #twiddle,XAR2           ; pointer to sin and cos tables
        AMOV    #(twiddle+1),XAR3       ; 
        AMAR    *(AR2+T0B)              ; set to 2nd entry of bit reversed
        AMAR    *(AR3+T0B)              ; sin/cos table 
            
;--------------------------------------------------------------------------------
; process yre[0] (DC) and yre[0] (Nyquist)
; yre[0] = 1/2(xre[0] + xim[0])    store in yre[0] 
; yre[N] = 1/2(xre[0] - xim[0])    store in yim[0]
;
;Scaling by 2 added to avoid overflow
;--------------------------------------------------------------------------------
        MOV     *AR0+,AC1                  ; AC1=xre[0]
        ADD     *AR0,AC1,AC0               ; AC0=xre[0]+xim[0]
        SUB     *AR0-,AC1,AC1              ; AC1=xre[0]-xim[0]
        MOV     AC0 << #-2, *AR0+          ; yre[0]=0.5*xre[0]+xim[0]
        MOV     AC1 << #-2, *AR0+          ; yim[0]=0.5*xre[0]-xim[0]
;--------------------------------------------------------------------------------
; process y1re/im
;
;Scaling by 2 added to avoid overflow
;--------------------------------------------------------------------------------
     || RPTBLOCAL   unpackiLoopEnd-1            ; setup loopcounter (RFFT-size)/4 - 2 
             ADD         *AR0,*AR1,AC0          ; AC0 = x1Re+x2Re   
             SUB         *AR0+,*AR1+,AC3        ; AC3 = x1Re-x2Re
           ||SFTS        AC0,#-1                ; rp = 0.5*AC0 = 0.5*(x1Re+x2Re)
             SUB         *AR0,*AR1,AC1          ; AC1 = x1Im-x2Im
           ||SFTS        AC3,#-1                ; rm = 0.5*AC2 = 0.5*(x1Im+x2Im)
             ADD         *AR0-,*AR1-,AC2        ;  
           ||SFTS        AC1,#-1                ; ip = 0.5*AC1 = 0.5*(x1Im-x2Im)
             NEG         AC2                    ; AC2 = -(x1Im+x2Im)
             SFTS        AC2,#-1                ; im = 0.5*AC3 = -0.5*(x1Re-x2Re)
           ||MOV         HI(AC3),T3             ; save im to T3  
             MOV         HI(AC2),T1             ; save rm to T1

;-----------------------------------------------------------------------
             MASM        *AR2,T1,AC0,AC2        ; y2re=AC2=rp-cos*rm
             MASM        *AR2,T3,AC1,AC3        ; y2im=AC3=ip-cos*im
             MACM        *AR2,T1,AC0,AC0        ; y1re=AC0=rp+cos*rm
             MACM        *(AR2+T0B),T3,AC1,AC1  ; y1im=AC1=ip+cos*im
;-----------------------------------------------------------------------
             ; y1re=rp+cos*rm-sin*im
             MASM        *AR3,T3,AC0,AC0        
             ; y1im=ip+cos*im+sin*rm                                         
             MACM        *AR3,T1,AC1,AC1 
             ::MOV       HI(AC0<<T2),*AR0+       
             ; y2re=-rp-cos*rm+sin*im
             MACM        *AR3,T3,AC2,AC2 
             ::MOV       HI(AC1<<T2),*AR0+       
             ; y2im=ip-cos*im-sin*rm
             MASM        *(AR3+T0B),T1,AC3,AC3       
             NEG         AC3
          || MOV         HI(AC2<<T2),*AR1+
             MOV         HI(AC3<<T2),*AR1
          || ASUB        #3,AR1                 ; adjust to next rm
unpackiLoopEnd: 
;//-----------------------------------------------------------------------------
;       yre(N/2) = yre(N/2)
;       yim(N/2) = - yim(N/2)
;
;Scaling by 2 added to avoid overflow
;//-----------------------------------------------------------------------------
        MOV     dbl(*AR0),pair(HI(AC0))
        NEG     AC1,AC1
        SFTS    AC0,#-1,AC0            
        SFTS    AC1,#-1,AC1            
        MOV     pair(HI(AC0)),dbl(*AR0)
;//-----------------------------------------------------------------------------
;// Context restore and return
;//-----------------------------------------------------------------------------

        BCLR    FRCT, ST1_55              ; restore FRCT for C
        BSET    ARMS, ST2_55              ; restore ARMS for C
     || POP     T3, T2
        BCLR    M40, ST1_55               ; restore M40 for C
     || RET

        .end

unpacki32.asm/  1362765892  0     0     0       18045     `
;/*
; * Copyright (C) 2013 Texas Instruments Incorporated - http://www.ti.com/ 
; * 
; * 
; *  Redistribution and use in source and binary forms, with or without 
; *  modification, are permitted provided that the following conditions 
; *  are met:
; *
; *    Redistributions of source code must retain the above copyright 
; *    notice, this list of conditions and the following disclaimer.
; *
; *    Redistributions in binary form must reproduce the above copyright
; *    notice, this list of conditions and the following disclaimer in the 
; *    documentation and/or other materials provided with the   
; *    distribution.
; *
; *    Neither the name of Texas Instruments Incorporated nor the names of
; *    its contributors may be used to endorse or promote products derived
; *    from this software without specific prior written permission.
; *
; *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
; *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
; *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
; *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
; *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
; *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
; *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
; *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
; *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
; *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
; *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
; *
;*/

;***********************************************************
; Version 3.00.00                                           
;***********************************************************
; Function UNPACKI32
; Processor:   C55xx
; Decription: Unpacks the output of a Radix-2 DIF complex FFT using bit-reversed input 
;    data and bit-reversed twiddle table (length N/2, cosine/sine format).
;
; Usage:  void unpacki32(LDATA *x, ushort nx);
;
; Limitations:
;   nx must be a power of 2 between 16 and 1024
;
; Benchmarks:
;   Cycles:
;     nx =  16:    185
;     nx =  32:    381
;     nx =  64:    773
;     nx = 128:   1557
;     nx = 256:   3125
;     nx = 512:   6261
;     nx =1024:  12533
;   Code Size (in bytes):  
;     .text              259
;     .const:twiddle32  4096 (shared by cfft32, cifft32, unpack32, unpacki32)
;
; History;
;	- 11/20/2003	C. Iovescu initial implementation
;	- 05/26/2012	Craig Leeds: Optimized
;************************************************************************************
;
;  IDFT of N-point frequency domain sequence obtained from
;  a real-valued sequence.      
;
; Implementation of the rifft based on the derivation
;   
;  g(n) n=0:N-1 is a real valued sequence. The RFFT of this signal is
;  denoted G(k) k=0:N-1 complex sequence. The objective of the code is to
;  recover g(n) based on G(k).
;
;  g(n) is split in two real sequences, odd and even part
;    
;          xe(n) = g(2n)    n=0:N/2-1
;          xo(n) = g(2n+1)  n=0:N/2-1
;
;  Form the complex sequence:
;
;         x(n) = xe(n) + jxo(n)  n=0:N/2-1
;
;  The CFFT of x(n)can be expressed as:
;
;        X(k) k=0:N/2-1
;
;        X(k) = Xe(k) +j*Xo(k) k=0:N/2-1                (1)
;
;  The RFFT of g(n)can be expressed as:
;
;      G(k)     = Xe(k) + W(k,N)Xo(k)     k = 0:N/2-1   (2)
;      G(N/2+k) = Xe(k) - W(k,N)Xo(k)     k = 0:N/2-1   (3)
;
;   where W(k,n) = cos(2*PI*k/N)-j*sin(2*PI*k/N)
;         W(k,n) = Wr(k)-j*Wi(k)
;
;  (2) and (3) yield
;
;      Xe(k) = (G(k) + G(N/2+k))/2          k = 0:N/2-1       
;      Xo(k) = (G(k) - G(N/2+k))/(2*W(k,N)) k = 0:N/2-1
;
;  since g(n) is a real valued sequence the DFT has the complex
;  conjugate symmetry:
;
;     G(k) = G*(N-k)                      k = 0:N-1     (4)
;
;   And since 1/W(k,N) = W(-k, N)
;   Therefore:
;   
;     Xe(k) = (G(k) + G*(N/2-k))/2          k = 0:N/2-1  (5) 
;     Xo(k) = W(-k,N)(G(k) - G*(N/2-k))/2   k = 0:N/2-1  (6)
;
;  Separate in Real and Imag parts: 
;
;    Xr(k)+j*Xi(k) = (Xer(k)+ j*Xei(k)) +j*(Xor(k)+jXoi(k)) k=0:N/2-1 
;
;  define:
;
;     Grp(k) = (Gr(k) + Gr(N/2-k))/2   k = 0:N/2-1     (7)
;     Grm(k) = (Gr(k) - Gr(N/2-k))/2   k = 0:N/2-1     (8)
;     Gip(k) = (Gi(k) + Gi(N/2-k))/2   k = 0:N/2-1     (9)
;     Gim(k) = (Gi(k) - Gi(N/2-k))/2   k = 0:N/2-1     (10)
;
;
;    Xr(k)     = 0.5 [Grp(k)-Gip(k)*Wr(k)-Grm(k)*Wi(k)]       k = 0:N/2-1  (11)
;    Xi(k)     = 0.5 [Gim(k)+Grm(k)*Wr(k)-Gip(k)*Wi(k)]       k = 0:N/2-1  (12)
;    Xr(N/2-k) = 0.5 [Grp(k)+Gip(k)*Wr(k)+Grm(k)*Wi(k)]       k = 0:N/2-1  (13)
;    Xi(N/2-k) = 0.5 [-Gim(k)+Grm(k)*Wr(k)-Gip(k)*Wi(k)]       k = 0:N/2-1  (14)
;       
;  Special values:
;        
;     * DC Offset  k = 0                                 
;
;     Xr(0) = 0.5*0.5*(Gr(0)+Gr(N/2))
;     Xi(0) = 0.5*0.5*(Gr(0)-Gr(N/2))
;
;    This was derived based on:
;
;           Wr(0) = 1
;           Wi(0) = 0
;           Gi(0) = Gi(N/2) = 0
;
;     * Nyquist Frequency  k = N/4                          
;
;      Xr(N/4) =  0.5*Gr(N/4) 
;      Xi(N/4) = -0.5*Gi(N/4)
;
;     This was derived based on:
;
;           Wr(N/4) = 0
;           Wi(N/4) = 1
;
;
;****************************************************************

           .mmregs
           .cpl_on
           .arms_off
           .ref twiddle32

;//-----------------------------------------------------------------------------
;// Program section
;//-----------------------------------------------------------------------------

           .global _unpacki32

Gip           .set  0x0
GrmR          .set  0x2
Grp           .set  0x4
Gim           .set  0x6
cosGip        .set  0x8
sinGip        .set  0xa
cosGrm        .set  0xc
sinGrm        .set  0xe
RawFrameSize  .set  0x10
FrameSize     .set  (RawFrameSize+1)

           .text
          .align 4    ; needed for optimization due to RPTB too big for RPTBLOCAL
_unpacki32:

;//-----------------------------------------------------------------------------
;// Context save / get arguments
;//-----------------------------------------------------------------------------
  
; upon entry stack aligned on 32-bit boundary
  
        AADD    #-FrameSize, SP               ; create local frame
          
;//-----------------------------------------------------------------------------
;// Initialization code
;//-----------------------------------------------------------------------------

     || BSET    FRCT, ST1_55              ; set FRCT
        BCLR    ARMS, ST2_55              ; reset ARMS
        BSET    M40

;//-----------------------------------------------------------------------------
;// Unpack for RIFFT
;//
;//  T0 = N (Rfft size) 
;//
;//
;//
;//-----------------------------------------------------------------------------
        MOV     XAR0, XAR1               ; AR0 = start ptr input data = Xr[0]
        ADD     T0, AR1                  ; AR1 = end ptr input data 
        ADD     T0, AR1                  ; 32-bit data 
        MOV     T0, T1                   ; T1 = T0 = RFFT size/2
        SFTS    T1, #-1                  ; T1 = RFFT size/2 
        SFTS    T1, #-1                  ; T1 = RFFT size/4 (req. for loop)
        SUB     #4, AR1                  ; AR1 = Xr[N/2-1] - last 32-bit elt
        SUB     #2, T1                   ; loop = N/4 - 2
        MOV     T1, BRC0                 ; and store in repeat counter
        AMOV    #twiddle32, XAR2         ; pointer to sin and cos tables
        AMAR    *AR2(2), XAR3            ; 32-bit values (add 2)
        AMAR    *SP(#Gip), XAR4           ; XAR4 local var ptr (stack)
        AMAR    *(AR2+T0B)               ; set to 2nd entry of bit reversed
        ; T0 = RFFT size for bitrev because 32-bit values

;--------------------------------------------------------------------------------
; Step1: 
;  Special values X(0):
;        
;     * DC Offset  k = 0                                    
;
;           Xr(0) = 0.5*0.5 (Gr(0)+Gi(N/2)) 
;           Xi(0) = 0.5*0.5 (Gr(0)-Gi(N/2))
;
;     Note: Gi(N/2) is stored as the imag part of G(0).
;
;--------------------------------------------------------------------------------
        MOV     dbl(*AR0+), AC1                  ; AC1 = Gr[0]
        ADD     dbl(*AR0), AC1, AC0              ; AC0 = Gr[0] + Gi[N/2]                                                                                                       
        SUB     dbl(*AR0-), AC1, AC1             ; AC1 = Gr[0] - Gi[N/2]
       
     || SFTS    AC0, #-2                         ; 0.25x
        SFTS    AC1, #-2                         ; 0.25x
                 
     || MOV     AC0, dbl(*AR0+)                  ; Xr(0)
        MOV     AC1, dbl(*AR0+)                  ; Xi(0)
     || MOV     #6, T1                           ; for AR1
        AMAR    *(AR3+T0B)               ; sin/cos table 
;--------------------------------------------------------------------------------
; Step 2: 
;
; General loop X(k) k=1:N/2-1  k<>N/4 (X(k)&X(N/2-k) computed in same iteration)
;  
;     Grp(k) = 0.5 (Gr(k) + Gr(N/2-k))   k = 1:N/4-1     
;     Grm(k) = 0.5 (Gr(k) - Gr(N/2-k))   k = 1:N/4-1     
;     Gip(k) = 0.5 (Gi(k) + Gi(N/2-k))   k = 1:N/4-1     
;     Gim(k) = 0.5 (Gi(k) - Gi(N/2-k))   k = 1:N/4-1      
;
;--------------------------------------------------------------------------------
     || RPTB    unpackiLoopEnd-1                 ; setup loopcounter (RFFT-size)/4 - 2
                MOV     dbl(*AR0+), AC3          ; AC3 = Gr[k]                                                                                    
              ||ADD     #1, AR2
                ADD     dbl(*AR1), AC3, AC0      ; Grp = AC0 =   Gr[k] + Gr[N/2-k]  
              ||ADD     #1, AR3
                SUB     dbl(*AR1+), AC3          ; Grm = AC3 =   Gr[k] - Gr[N/2-k]
              ||SFTS    AC0, #-1                 ; Grp = 0.5*AC0
                       
                MOV     dbl(*AR0-), AC2          ; AC2 = Gi[k]                 
              ||SFTS    AC3, #-1                 ; Grm = 0.5*AC3
                ADD     dbl(*AR1), AC2, AC1      ; Gip = AC1 =  Gi[k] + Gi[N/2-k]             
                SUB     dbl(*AR1-), AC2, AC2     ; Gim = AC2 =  Gi[k] - Gi[N/2-k]
              ||SFTS    AC1, #-1                 ; Gip = 0.5*AC1 
                
                MOV     AC0, dbl(*SP(Grp))       ; save Grp
              ||SFTS    AC2, #-1                 ; Gim = 0.5*AC2
                MOV     AC1, dbl(*AR4+)          ; save Gip   *SP(0)
                MOV     AC2, dbl(*SP(Gim))       ; save Gim
                MOV     AC3, dbl(*AR4-)          ; save GrmR  *SP(2)
            
;-----------------------------------------------------------------------
;
;   Output for N/2-point CIFFT
;
;    Xr(k)     = 0.5 [Grp(k)-Gip(k)*Wr(k)-Grm(k)*Wi(k)]      
;    Xi(k)     = 0.5 [Gim(k)+Grm(k)*Wr(k)-Gip(k)*Wi(k)]       
;    Xr(N/2-k) = 0.5 [Grp(k)+Gip(k)*Wr(k)+Grm(k)*Wi(k)]       
;    Xi(N/2-k) = 0.5 [-Gim(k)+Grm(k)*Wr(k)-Gip(k)*Wi(k)]         
;
;    Wr(k)     = cos(2Pik/N)
;    Wi(k)     = sin(2Pik/N)
;
;--------------------------------------------------------------------------------

                ; Wr(k)Gip(k)
                ;  AR2 -> cos_H
                ;             cos_L
                ; 
                ;  AR4 -> Gip_H
                ;             Gip_L
                ;

                MPYM    uns(*AR2-), *AR4+, AC0         ; AC0 = cos_L*Gip_H
                MACM    *AR2, uns(*AR4-), AC0          ; AC0 = AC0 + cos_H*Gip_L
                MACM    *AR2+, *AR4, AC0 >> #16, AC0   ; AC0 = AC0>>16 + cos_H*Gip_H 
                MOV     AC0, dbl(*SP(cosGip))          ; save cos*Gip

                ; Wi(k)Gip(k)
                ;  AR3 -> sin_H
                ;             sin_L
                ; 
                ;  AR4 -> Gip_H
                ;             Gip_L
                ;
                    
                MPYM    uns(*AR3-), *AR4+, AC0         ; AC0 = sin_L*Gip_H
                MACM    *AR3, uns(*AR4-), AC0          ; AC0 = AC0 + sin_H*Gip_L
                MACM    *AR3+, *AR4+, AC0 >> #16, AC0  ; AC0 = AC0>>16 + sin_H*Gip_H 
                MOV     AC0, dbl(*SP(sinGip))          ; save sin*Gip
              ||AADD    #1, AR4
                    
                ; Wr(k)Grm(k)
                ;         cos_H
                ;  AR2 -> cos_L
                ; 
                ;  AR4 -> Grm_H
                ;             Grm_L
                ;
                    
                MPYM    uns(*AR2-), *AR4+, AC0       ; AC0 = cos_L*Grm_H
                MACM    *AR2, uns(*AR4-), AC0        ; AC0 = AC0 + cos_H*Grm_L
                MACM    *AR2, *AR4, AC0 >> #16, AC0  ; AC0 = AC0>>16 + cos_H*Grm_H 
                MOV     AC0, dbl(*SP(cosGrm))        ; save cos*Grm
   
                ; Wi(k)Grm(k)
                ;         sin_H
                ;        AR3 -> sin_L
                ; 
                ;  AR4 -> Grm_H
                ;               Grm_L
                ;
                    
                MPYM    uns(*AR3-), *AR4+, AC0       ; AC0 = sin_L*Grm_H
                MACM    *AR3, uns(*AR4-), AC0        ; AC0 = AC0 + sin_H*Grm_L
                MACM    *AR3, *AR4-, AC0 >> #16, AC0 ; AC0 = AC0>>16 + sin_H*Grm_H 
                MOV     AC0, dbl(*SP(sinGrm))        ; save sin*Grm
          
                ; update AR4, local var pointer for next loop iteration 
                SUB     #1, AR4
             || MAR     *(AR3+T0B)                   ; sin
            
                ; update the sin/cos pointers
                ; bit-reversed addressing used because twiddle table 
                ; is in bit-reversed format and normal format is needed
                ; in this algorithm.
                ;
                ;  AR2 -> cos_H
                ;               cos_L         
                ;  AR3 -> sin_H
                ;               sin_L
            
;     Xr(k)     =0.5 [Grp(k)-Gip(k)*Wr(k)-Grm(k)*Wi(k)]                       
                                                                                             
                MOV     dbl(*SP(Grp)), AC0           ; AC0 = Grp(k)                                                                                     
                SUB     dbl(*SP(cosGip)), AC0, AC1   ; AC1 = Grp(k)-Wr(k)Gip(k)                                                                                                       
                SUB     dbl(*SP(sinGrm)), AC1, AC1   ; AC1 = Grp(k)-Wr(k)Gip(k)-Wi(k)Grm(k)
                SFTS    AC1, #-1                     ; 0.5x
             || AMAR    *(AR2+T0B)                   ; cos
                MOV     AC1, dbl(*AR0+)              ; Xr(k)

;    Xi(k)     =0.5 [Gim(k)+Grm(k)*Wr(k)-Gip(k)*Wi(k)]                                                                                                                        
                                                                                                                                                       
                MOV     dbl(*SP(cosGrm)), AC1        ; AC1 = Gim(k) 
                ADD     dbl(*SP(Gim)), AC1, AC2      ; AC2 = Gim(k)+ Wr(k)Grm(k)  
                SUB     dbl(*SP(sinGip)), AC2, AC2   ; AC2 = Gim(k)+ Wr(k)Grm(k)-Wi(k)Gip(k)  
                SFTS    AC2, #-1                     ; 0.5x    

;    Xr(N/2-k) =0.5 [Grp(k)+Gip(k)*Wr(k)+Grm(k)*Wi(k)]                   
        
             || ADD     dbl(*SP(cosGip)), AC0, AC3   ; AC3 = Grp(k)+ Wr(k)Gip(k)  
                ADD     dbl(*SP(sinGrm)), AC3, AC3   ; AC3 = Grp(k)+ Wr(k)Gip(k)+Wi(k)Grm(k)  
                SFTS    AC3, #-1                     ; 0.5x    
             || MOV     AC2, dbl(*AR0+)              ; Xi(k)

;    Xi(N/2-k) =0.5 [-Gim(k)+Grm(k)*Wr(k)-Gip(k)*Wi(k)]                              
        
                SUB     dbl(*SP(Gim)), AC1, AC2      ; AC2 = -Gim(k)+ Wr(k)Grm(k)  
                SUB     dbl(*SP(sinGip)), AC2, AC2   ; AC2 = -Gim(k)+ Wr(k)Grm(k)-Wi(k)Gip(k)  
                MOV     AC3, dbl(*AR1+)              ; Xr(N/2-k)            
             || SFTS    AC2, #-1                     ; 0.5x    
                MOV     AC2, dbl(*(AR1-T1))          ; Xi(N/2-k) ; adjust to Gr(N/2-k-1)          
unpackiLoopEnd:

;--------------------------------------------------------------------------------
; Step3: 
;  Special values G(N/4):
;
;           Gr(N/4) = 0.5 Xr(N/4) 
;           Gi(N/4) =-0.5 Xi(N/4)
;
;//-----------------------------------------------------------------------------
        MOV     dbl(*AR0+), AC0          ; Xr(N/4)
        MOV     dbl(*AR0-), AC1          ; Xi(N/4)          
     || SFTS    AC0, #-1                 ; 0.5*Xr(N/4)           
        NEG     AC1, AC1                 ;-Xi(N/4)
     || MOV     AC0, dbl(*AR0+)          ;Gr(N/4) = 0.5 Xr(N/4)
        SFTS    AC1, #-1                 ;-0.5*Xi(N/4)          
        MOV     AC1, dbl(*AR0+)          ;Gi(N/4) =-0.5 Xi(N/4)        
;//-----------------------------------------------------------------------------
;// Context restore
;//-----------------------------------------------------------------------------
     || AADD    #+FrameSize, SP          ; destroy local frame
;//-----------------------------------------------------------------------------
;// Return
;//-----------------------------------------------------------------------------
        BSET    ARMS, ST2_55             ; set ARMS for C
        BCLR    FRCT, ST1_55             ; reset FRCT for C
        BCLR    M40
     || RET

        .end

Dsplib.h/       1362765902  0     0     0       7084      `
/*
 * Copyright (C) 2013 Texas Instruments Incorporated - http://www.ti.com/ 
 * 
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/

/***********************************************************/
/* Version 2.30.00                                         */
/***********************************************************/
#ifndef _DSPLIB
#define _DSPLIB

#include <tms320.h>

/* 32-bit fft */

void cfft32_SCALE(LDATA *x, ushort nx);
void cfft32_NOSCALE(LDATA *x, ushort nx);
void cifft32_SCALE (LDATA *x,  ushort nx);
void cifft32_NOSCALE (LDATA *x,  ushort nx);

/* 32-bit bit reversal */

void cbrev32 (LDATA *x, LDATA *y, ushort n);


/* 16-bit fft */

void cfft_SCALE(DATA *x, ushort nx);
void cfft_NOSCALE(DATA *x, ushort nx);
void cifft_SCALE (DATA *x,  ushort nx);
void cifft_NOSCALE (DATA *x,  ushort nx);

void unpack(DATA *x, ushort nx);
void unpacki(DATA *x, ushort nx);
void unpack32(LDATA *x, ushort nx);
void unpacki32(LDATA *x, ushort nx);
/* void rfft(DATA *x, ushort nx, ushort scale); */
/* void rifft(DATA *x,  ushort nx, ushort scale); */

/* 16-bit bit reversal */

void cbrev (DATA *x, DATA *y, ushort n);


/* correlations */

ushort acorr_raw(DATA *x, DATA *r, ushort nx, ushort nr);
ushort acorr_bias(DATA *x, DATA *r, ushort nx, ushort nr);
ushort acorr_unbias(DATA *x, DATA *r, ushort nx, ushort nr);

ushort corr_raw	(DATA *x, DATA *y, DATA *r, ushort nx, ushort ny);
ushort corr_bias  (DATA *x, DATA *y, DATA *r, ushort nx, ushort ny);
ushort corr_unbias  (DATA *x, DATA *y, DATA *r, ushort nx, ushort ny);

/* filtering and convolution */

ushort convol(DATA *x, DATA *h, DATA *r, ushort nr, ushort nh);
ushort convol1(DATA *x, DATA *h, DATA *r, ushort nr, ushort nh);
ushort convol2(DATA *x, DATA *h, DATA *r, ushort nr, ushort nh);

ushort fir(DATA *x, DATA *h, DATA *r, DATA *dbuffer, ushort nx, ushort nh);
ushort fir2(DATA *x, DATA *h, DATA *r, DATA *dbuffer, ushort nx, ushort nh);
ushort firs(DATA *x, DATA *h, DATA *r, DATA *dbuffer, ushort nx, ushort nh2);
ushort cfir(DATA *x, DATA *h, DATA *r, DATA *dbuffer, ushort nx, ushort nh);

ushort iircas4(DATA *x, DATA *h,  DATA *r, DATA *dbuffer, ushort nbiq, ushort nx);
ushort iircas5(DATA *x, DATA *h,  DATA *r, DATA *dbuffer, ushort nbiq, ushort nx);
ushort iircas51(DATA *x, DATA *h,  DATA *r, DATA *dbuffer, ushort nbiq, ushort nx);

ushort firlat (DATA *x, DATA *h, DATA *r, DATA *pbuffer, int nx, int nh);
ushort iirlat (DATA *x, DATA *h, DATA *r, DATA *pbuffer, int nx, int nh);

ushort hilb16(DATA *x, DATA *h, DATA*r, DATA *dbuffer, ushort nx, ushort nh);
ushort firdec(DATA *x, DATA *h, DATA *r, DATA *dbuffer, ushort nh, ushort nx, ushort D);
ushort firinterp(DATA *x, DATA *h, DATA *r, DATA *dbuffer, ushort nh, ushort nx, ushort I);
ushort iir32(DATA *x,LDATA *h,DATA *r,LDATA *d, ushort nbiq, ushort nx);

/* adaptive filtering */

ushort dlms(DATA *x, DATA *h, DATA *r, DATA *des, DATA *dbuffer, DATA step, ushort nh,  ushort nx);
ushort dlmsfast(DATA *x, DATA *h, DATA *r, DATA *des, DATA *dbuffer, DATA step, ushort nh,  ushort nx);


/* math */
ushort add(DATA *x, DATA *y,  DATA *r,  ushort nx,  ushort scale);
ushort sub(DATA *x, DATA *y,  DATA *r,  ushort nx,  ushort scale);
ushort neg (DATA *x, DATA *r, ushort nx);
ushort neg32 (LDATA *x, LDATA *r, ushort nx);
ushort power (DATA *x, LDATA *r, ushort nx);

ushort sqrt_16(DATA *x, DATA *r, short nx);
void ldiv16(LDATA *x, DATA *y,DATA *r, DATA *rexp, ushort nx);
void recip16(DATA *x, DATA *r, DATA *rexp, ushort nx);

ushort mul32(LDATA *x, LDATA *y,  LDATA *r, ushort nx);

ushort expn(DATA *x, DATA *r, ushort nx);
ushort logn(DATA *x, LDATA *r, ushort nx);
ushort log_2(DATA *x, LDATA *r, ushort nx);
ushort log_10(DATA *x, LDATA *r, ushort nx);
short bexp (DATA *x, ushort nx);


short maxidx (DATA *x, ushort ng, ushort ng_size);
short maxidx34 (DATA *x, ushort nx);
short maxval (DATA *x, ushort nx);
short minidx (DATA *x, ushort ng, ushort ng_size);
short minval (DATA *x, ushort nx);

void maxvec (DATA *x, ushort nx, DATA *val, DATA *idx);
void minvec (DATA *x, ushort nx, DATA *val, DATA *idx);

/* matrix */

ushort mmul(DATA *x1,short row1,short col1,DATA *x2,short row2,short col2,DATA *r);
ushort mtrans(DATA *x, short row, short col, DATA *r);


/* trigonometric */

ushort atan16(DATA *x, DATA *r, ushort nx);
ushort atan2_16(DATA *i, DATA *q, DATA *r, ushort nx);
ushort sine(DATA *x, DATA *r, ushort nx);


/* miscellaneous */

ushort fltoq15(float *x, DATA *r, ushort nx);
ushort q15tofl(DATA *x, float *r, ushort nx);

ushort rand16(DATA *r, ushort nr);
void rand16init(void);




/* macro definition */

#define SCALE 1
#define NOSCALE 0

#define cfft(x,nx, type)   cfft_##type(x,nx)
#define cifft(x,nx, type)   cifft_##type(x,nx)


#define acorr(n1, n2, n3, n4, type) acorr_##type(n1, n2, n3, n4)
#define corr(n1, n2, n3, n4, n5, type) corr_##type(n1, n2, n3, n4, n5)
#define rfft(x,nx,type)\
    (\
         cfft_##type(x,nx/2),\
         cbrev(x,x,nx/2),\
         unpack(x,nx)\
    )

#define rifft(x,nx,type)\
    (\
        unpacki(x, nx),\
        cifft_##type(x,nx/2),\
        cbrev(x,x,nx/2)\
    )


#define rfft32(x,nx,type)\
    (\
         cfft32_##type(x,nx/2),\
         cbrev32(x,x,nx/2),\
         unpack32(x,nx)\
    )

#define rifft32(x,nx,type)\
    (\
        unpacki32(x, nx),\
        cifft32_##type(x,nx/2),\
        cbrev32(x,x,nx/2)\
    )

#endif
Dsplib_c.h/     1362765902  0     0     0       2993      `
/*
 * Copyright (C) 2013 Texas Instruments Incorporated - http://www.ti.com/ 
 * 
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/

/***********************************************************/
/* Version 2.30.00                                         */
/***********************************************************/
#ifndef _DSPLIBC
#define _DSPLIBC

#include <tms320.h>


/* correlations */

void acorr_c_raw(DATA *x, DATA *r, ushort nx, ushort nr);
void acorr_c_bias(DATA *x, DATA *r, ushort nx, ushort nr);
void acorr_c_unbias(DATA *x, DATA *r, ushort nx, ushort nr);

/* filtering and convolution */


void fir_c(DATA *x, DATA *h, DATA *r, DATA *dbuffer, ushort nx, ushort nh);
void fir2_c(DATA *x, DATA *h, DATA *r, DATA *dbuffer, ushort nx, ushort nh);
void firs_c(DATA *x, DATA *h, DATA *r, DATA *dbuffer, ushort nx, ushort nh2);
void cfir_c(DATA *x, DATA *h, DATA *r, DATA *dbuffer, ushort nx, ushort nh);

void iircas4_c(DATA *x, DATA *h,  DATA *r, DATA *dbuffer, ushort nbiq, ushort nx);
void iircas5_c(DATA *x, DATA *h,  DATA *r, DATA *dbuffer, ushort nbiq, ushort nx);
void iircas51_c(DATA *x, DATA *h,  DATA *r, DATA *dbuffer, ushort nbiq, ushort nx);


/* adaptive filtering */

void dlms_c(DATA *x, DATA *h, DATA *r, DATA *des, DATA *dbuffer, DATA step, ushort nh,  ushort nx);


/* macro definition */


#define acorr_c(n1, n2, n3, n4, type) acorr_c_##type(n1, n2, n3, n4)

#endif

math.h/         1362764594  0     0     0       4322      `
/********************************************************************************************
 * Copyright (C) 2013 Texas Instruments Incorporated - http://www.ti.com/ 
 * 
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *********************************************************************************************
*/

/***********************************************************/
/* Version 2.30.00                                         */
/***********************************************************/
#ifndef _MATH
#define _MATH

#if _INLINE
#define __INLINE static inline
#else
#define __INLINE
#endif

#define HUGE_VAL  3.40232347E+38F

/***************************************************************/
/* FUNCTION DECLARATIONS.                                      */
/***************************************************************/
         double asin(double _x);
         double acos(double _x);
         double atan(double _x);
         double atan2(double _y, double _x);
__INLINE double ceil(double _x);
         double cos(double _x);
         double cosh(double _x);
         double exp(double _x);
         double fabs(double _x);
__INLINE double floor(double _x);
__INLINE double fmod(double _x, double _y);
         double frexp(double _x, int *_exp);
         double ldexp(double _x, int _exp);
         double log(double _x);
         double log10(double _x);
         double modf(double _x, double *_iptr);
         double pow(double _x, double _y);
         double sin(double _x);
         double sinh(double _x);
         double sqrt(double _x);
         double tan(double _x);
         double tanh(double _x);

#if _INLINE
/****************************************************************************/
/*  ceil()       				                            */
/****************************************************************************/
static inline double ceil(double x)
{
     double y; 
     return (modf(x, &y) > 0 ? y + 1.0 : y);
}

/****************************************************************************/
/*  floor()      				                            */
/****************************************************************************/
static inline double floor(double x)
{
     double y; 
     return (modf(x, &y) < 0 ? y - 1.0 : y);
}

/****************************************************************************/
/*  fmod()       				                            */
/****************************************************************************/
static inline double fmod(double x, double y)
{
   double d = fabs(x); 

   if (d - fabs(y) == d) return (0.0);
   modf(x/y, &d);
   return (x - d * y);
}
#endif /* _INLINE */
#undef __INLINE

#endif /* _MATH   */
MISC.H/         1362764594  0     0     0       2233      `
/********************************************************************************************
 * Copyright (C) 2013 Texas Instruments Incorporated - http://www.ti.com/ 
 * 
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *********************************************************************************************
*/

/***********************************************************/
/* Version 2.30.00                                         */
/***********************************************************/
#ifndef _MISC
#define _MISC

#define PI	  3.14159265358979323846 // PI value
#define CONV	  32767.999999	   	// Q15-> float conversion value = 2^15- 2^1-15 

#endif


stdio.h/        1362764594  0     0     0       12000     `
/********************************************************************************************
 * Copyright (C) 2013 Texas Instruments Incorporated - http://www.ti.com/ 
 * 
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *********************************************************************************************
*/

/***********************************************************/
/* Version 2.30.00                                         */
/***********************************************************/
#ifndef _STDIO 
#define _STDIO

/****************************************************************************/
/* TYPES THAT ANSI REQUIRES TO BE DEFINED                                   */
/****************************************************************************/
#ifndef _SIZE_T                                                    
#define _SIZE_T                                                    
typedef unsigned size_t;                                           
#endif

typedef struct {
         int fd;                    /* File descriptor */
         unsigned char* buf;        /* Pointer to start of buffer */
         unsigned char* pos;        /* Position in buffer */
         unsigned char* bufend;     /* Pointer to end of buffer */
         unsigned char* buff_stop;  /* Pointer to last read char in buffer */
         unsigned int   flags;      /* File status flags (see below) */
         int index;                 /* Location in ftable */
} FILE;

#ifndef _FPOS_T
#define _FPOS_T
typedef long fpos_t;
#endif

/****************************************************************************/
/* MACROS THAT DEFINE AND USE FILE STATUS FLAGS                             */
/****************************************************************************/
#define _IOFBF       0x0001
#define _IOLBF       0x0002
#define _IONBF       0x0004
#define _BUFFALOC    0x0008
#define _MODER       0x0010
#define _MODEW       0x0020
#define _MODERW      0x0040
#define _MODEA       0x0080
#define _MODEBIN     0x0100
#define _STATEOF     0x0200
#define _STATERR     0x0400
#define _UNGETC      0x0800
#define _TMPFILE     0x1000

#define _SET(_fp, _b)      (((_fp)->flags) |= (_b))
#define _UNSET(_fp, _b)    (((_fp)->flags) &= ~(_b))
#define _STCHK(_fp, _b)    (((_fp)->flags) & (_b))
#define _BUFFMODE(_fp)     (((_fp)->flags) & (_IOFBF | _IOLBF | _IONBF))
#define _ACCMODE(_fp)      (((_fp)->flags) & (_MODER | _MODEW))

/****************************************************************************/
/* MACROS THAT ANSI REQUIRES TO BE DEFINED                                  */
/****************************************************************************/
#define BUFSIZ          256 
#define FOPEN_MAX       12
#define FILENAME_MAX    256  
#define TMP_MAX         65535

#define SEEK_SET  (0x0000)
#define SEEK_CUR  (0x0001)
#define SEEK_END  (0x0002)

#ifndef NULL
#define NULL (void *) 0
#endif

#ifndef EOF
#define EOF    (-1)
#endif

#define stdin     (&_ftable[0])      
#define stdout    (&_ftable[1])
#define stderr    (&_ftable[2])

#define L_tmpnam  (sizeof(P_tmpdir) + 15)

/******** END OF ANSI MACROS ************************************************/

#define P_tmpdir        ""                   /* Path for temp files         */

/****************************************************************************/
/* DEVICE AND STREAM RELATED DATA STRUCTURES AND MACROS                     */
/****************************************************************************/
/*- If you modify these values, be sure to also modify the ftable[] to     -*/
/*- correctly initialize the entries.  This is necessary since we do no    -*/
/*- clear bss by default!                                                  -*/
/****************************************************************************/
#define _NFILE          20                   /* Max number of files open    */
#define _NSTREAM        20                   /* Size of stream table        */
#define _NDEVICE        3                    /* Size of device table        */

#define _SSA      (0x0000)             /* Single Stream allowed       */
#define _BUSY     (0x0001)             /* Device busy                 */
#define _MSA      (0x0002)             /* Multiple Streams Allowed    */

#define stdevice        (&_device[0])        /* Default device (host)       */

typedef struct {                             
   char  name[9];
   unsigned short flags;
   int (*OPEN) ();
   int (*CLOSE) ();
   int (*READ) ();
   int (*WRITE) ();
   long (*LSEEK) ();
   int (*UNLINK) ();
   int (*RENAME) ();
} _DEVICE;

extern FILE _ftable[_NFILE];
extern char _tmpnams[_NFILE][L_tmpnam];

/****************************************************************************/
/*   FUNCTION DEFINITIONS  - ANSI                                           */
/****************************************************************************/
/****************************************************************************/
/* OPERATIONS ON FILES                                                      */
/****************************************************************************/
       int     remove(const char *_file);
extern int     rename(const char *_old, const char *_new);
extern FILE   *tmpfile(void);
extern char   *tmpnam(char *_s);

/****************************************************************************/
/* FILE ACCESS FUNCTIONS                                                    */
/****************************************************************************/
extern int    fclose(FILE *_fp); 
extern FILE   *fopen(const char *_fname, const char *_mode);
extern FILE   *freopen(const char *_fname, const char *_mode,
               register FILE *_fp);
extern void    setbuf(register FILE *_fp, char *_buf);
extern int     setvbuf(register FILE *_fp, register char *_buf, 
                       register int _type,  register size_t _size); 
extern int     fflush(register FILE *_fp); 

/****************************************************************************/
/* FORMATTED INPUT/OUTPUT FUNCTIONS                                         */
/****************************************************************************/
extern int     fprintf(FILE *_fp, const char *_format, ...);
extern int     fscanf(FILE *_fp, const char *_fmt, ...);
extern int     printf(const char *_format, ...);
extern int     scanf(const char *_fmt, ...);
extern int     sprintf(char *_string, const char *_format, ...);
extern int     sscanf(const char *_str, const char *_fmt, ...);
extern int     vfprintf(FILE *_fp, const char *_format, char *_ap);
extern int     vprintf(const char *_format, char *_ap);
extern int     vsprintf(char *_string, const char *_format, char *_ap);

/****************************************************************************/
/* CHARACTER INPUT/OUTPUT FUNCTIONS                                         */
/****************************************************************************/
extern int     fgetc(register FILE *_fp);
extern char   *fgets(char *_ptr, register int _size, register FILE *_fp);
extern int     fputc(int _c, register FILE *_fp);
extern int     fputs(const char *_ptr, register FILE *_fp);
extern int     getc(FILE *_p);
       int     getchar(void);
extern char   *gets(char *_ptr); 
extern int     putc(int _x, FILE *_fp);
       int     putchar(int _x);
extern int     puts(const char *_ptr); 
extern int     ungetc(int _c, register FILE *_fp);

/****************************************************************************/
/* DIRECT INPUT/OUTPUT FUNCTIONS                                            */
/****************************************************************************/
extern size_t    fread(void *_ptr, size_t _size, size_t _count, FILE *_fp);
extern size_t    fwrite(const void *_ptr, size_t _size, size_t _count,
                        register FILE *_fp); 

/****************************************************************************/
/* FILE POSITIONING FUNCTIONS                                               */
/****************************************************************************/
extern int       fgetpos(FILE *_fp, fpos_t *_pos);
extern int       fseek(register FILE *_fp, long _offset, int _ptrname);
extern int       fsetpos(FILE *_fp, const fpos_t *_pos);
extern long  ftell(FILE *_fp);
extern void  rewind(register FILE *_fp); 

/****************************************************************************/
/* ERROR-HANDLING FUNCTIONS                                                 */
/****************************************************************************/
       void      clearerr(FILE *_fp);
extern int       feof(FILE *_fp);
       int       ferror(FILE *_fp);
extern void      perror(const char *_s);
                

#define _getchar()      getc(stdin)
#define _putchar(_x)    putc((_x), stdout)
#define _clearerr(_fp)   ((void) ((_fp)->flags &= ~(_STATERR | _STATEOF)))

#define _ferror(_x)     ((_x)->flags & _STATERR)

#define _remove(_fl)    (unlink((_fl)))

/******* END OF ANSI FUNCTIONS  *********************************************/


/****************************************************************************/
/* GETENV IS SUPPOSED TO BE IN STDLIB.H IN THE RTS.LIB, BUT BECAUSE STDIO.H */
/* IS THE ONLY HEADER FILE THAT USES ROUTINES TO INTERFACE WITH THE HOST    */
/* OPERATING SYSTEM, GETENV WAS PLACED HERE.                                */
/****************************************************************************/
char            *getenv(const char *_string);

/****************************************************************************/
/* LOW LEVEL FUNCTION PROTOTYPES                                            */
/****************************************************************************/
extern int       add_device(char           *name,
                            unsigned        flags,
                  int            (*dopen)(),
                  int            (*dclose)(),
                  int            (*dread)(),
                  int            (*dwrite)(),
                  long           (*dlseek)(),
                  int            (*dunlink)(),
                  int            (*drename)());
#endif
TMS320.H/       1362765902  0     0     0       2165      `
/*
 * Copyright (C) 2013 Texas Instruments Incorporated - http://www.ti.com/ 
 * 
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/

/***********************************************************/
/* Version 2.30.00                                         */
/***********************************************************/
#ifndef _TMS320
#define _TMS320
 
typedef unsigned int   uint;
typedef unsigned short ushort;  
#define PASS -1


  typedef short DATA;
  typedef long LDATA;
  #define ABSVAL abs
  #define SHIFT15 >>15
  #define SHIFT1  /2
  #define ROUND 0x400
  #define DIV2	>>1

#endif

